import org.apache.batik.transcoder.image.PNGTranscoder;
import org.apache.batik.transcoder.TranscoderInput;
import org.apache.batik.transcoder.TranscoderOutput;

buildscript {
  ext {
    springBootVersion = '1.2.7'
  }
  repositories {
    jcenter { 
      url 'http://dl.bintray.com/radl/RADL'
    }
    mavenCentral()
    maven { url 'https://repo.spring.io/milestone' }
    maven { url 'http://repository.jboss.org/nexus/content/groups/public/' }
  }
  
  dependencies {
    classpath 'org.jboss.jdocbook:gradle-jdocbook:1.2.2', 
              'org.jboss:jbossorg-docbook-xslt:1.1.1',
              "org.apache.xmlgraphics:batik-transcoder:$batikVersion",
              "org.apache.xmlgraphics:batik-codec:$batikVersion",
              "radl:radl-gradle:$radlGradleVersion",
              "org.springframework.boot:spring-boot-gradle-plugin:1.2.6.RELEASE"
  }
}

apply plugin: 'java'

sourceCompatibility = 1.8
group = 'com.github.apisecray'
version = '1.0.0'

repositories {
  maven { url 'https://repo.spring.io/snapshot' }
  mavenCentral()
  jcenter { 
    url 'http://dl.bintray.com/radl/RADL'
  }
}

apply plugin: 'spring-boot'

dependencies {
  compile 'org.springframework.boot:spring-boot-starter-web',
      'org.springframework.boot:spring-boot-starter-data-jpa',
      'org.springframework.hateoas:spring-hateoas:0.20.0.BUILD-SNAPSHOT',
      'com.fasterxml.jackson.core:jackson-core:2.5.4',
      'com.jayway.jsonpath:json-path',
      'commons-io:commons-io:2.4',
      'commons-lang:commons-lang:2.6',
      'de.escalon.hypermedia:hydra-spring:0.2.0-beta2',
      'org.json:json:20141113',
      'org.javamoney:moneta:1.0'
  testCompile 'junit:junit:4.12','org.jbehave:jbehave-core:4.0.3', 
      'org.springframework.boot:spring-boot-starter-test'
  runtime("com.h2database:h2")
}

jar {
  baseName = 'restbucks'
  version = '1.0.0'
}

test {
  outputs.upToDateWhen { false }
  doFirst {
    file('target').mkdirs() // Required by JBehave
  }
  doLast {
    // Prepare pretty HTML report
    def dir = file("$buildDir/reports/acceptance-tests")
    def resultDir = file('target/jbehave')
    ant.move(todir: dir.path) {
      fileset(dir: new File(resultDir, 'view').path, excludes: "**/*.xml.html")
    }
    def testResourcesDir = sourceSets.test.resources.srcDirs[0].path
    ant.copy(todir: dir.path) {
      fileset(dir: testResourcesDir, includes: "**/*.css")
      fileset(dir: testResourcesDir, includes: "**/*.png")
    }
    
    // Count results
    def numTested = 0
    def numFailed = 0
    def numPending = 0
    resultDir.listFiles().findAll { it.name.endsWith('.xml') && !it.name.endsWith('Stories.xml') }.each {
      new XmlSlurper().parse(it).scenario.each {
        def failed = false
        def pending = false
        it.step.each {
          if (it.@outcome == 'failed') {
            failed = true
          } else if (it.@outcome == 'pending') {
            pending = true
          }
        }
        numTested++
        if (failed) {
          numFailed++
        } else if (pending) {
          numPending++
        }
      }
    }
    def message = "Acceptance tests: $numTested scenarios, $numFailed failed, $numPending pending"
    ant.delete(dir: file('target').path, failonerror: false)
    if (numFailed > 0) {
      throw new GradleException(message)
    }
    println message
  }
}


apply plugin: 'eclipse'

eclipse {
  classpath {
    defaultOutputDir = file('classes')
  }
}


apply plugin: 'radl-gradle'

radl {
  coreVersion = radlCoreVersion
  serviceName = 'RESTBucks'
  packagePrefix = 'restbucks.rest'
  generateSpring = true
}


apply plugin: 'jdocbook'

jdocbook {
  restApiDevelopment {
    masterSourceDocumentName = 'book.xml'
    transformerParameters([
      'section.autolabel': '1',
      'section.label.includes.component.label': '1',
      'generate.toc': 'appendix nop  book toc,title  part nop'
    ])
    format {
      name = 'html_single'
      finalName = 'restApiDevelopment.html'
    }
    format {
      name = 'pdf'
      finalName = 'restApiDevelopment.pdf'
    }
  }
}

tasks.findAll { it.name.toLowerCase().contains('docbook') }.each {
  it.inputs.dir file('src/main/docbook')
}

build.dependsOn 'buildDocs'
defaultTasks 'buildDocs'


/*
gradle.taskGraph.whenReady { graph ->
  graph.allTasks.findAll { it.name.startsWith('renderDocBook_') }.each { task ->
    task.inputs.dir file('src/main/docbook')
    task.dependsOn 'generateImages'
  }
}

task generateImages {
  def baseDir = file('src/main/docbook/restApiDevelopment/en-US')
  def svgDir = new File(baseDir, 'figures') 
  def imagesDir = new File(baseDir, 'images')
  doLast {
    svgDir.listFiles().findAll { it.name.endsWith('.svg') }.each { source ->
      def target = new File(imagesDir, source.name.substring(0, source.name.lastIndexOf('.') + 1) + 'png')
      exportToPng(source, target)
    }
  }
}

def exportToPng(source, target) {
  try {
    def input = new TranscoderInput(source.toURL().toString())
    def stream = new FileOutputStream(target.path)
    def output = new TranscoderOutput(stream)
    try {
      new PNGTranscoder().transcode(input, output)
    } finally {  
      stream.flush();
      stream.close();
    }
  } catch (Exception e) {
    target.delete()
    throw new GradleException("Error exporting $source.name to $target.name:\n$e.message", e)
  }
}
*/

task wrapper(type: Wrapper) {
  gradleVersion = 2.7
}
