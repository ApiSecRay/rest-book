<chapter id="radl">
  <title>REST API Description Language (RADL)</title>

  <section>
    <title>API Description Languages</title>
    <para>
      The ever increasing number of APIs requires tooling to manage. Such tools need to understand the APIs they're 
      managing, which leads to a need to describe APIs in a machine-processable way. A language for doing so is 
      known as an <firstterm>API description language</firstterm>.
    </para>
    <para>
      There have been several attempts at API description languages. WSDL is the language of choice for SOAP-based APIs
      <citation>WSDL</citation>. For HTTP-based APIs, we've seen a bunch of languages pop up <citation>WADL</citation>
      <citation>RAML</citation> <citation>Swagger</citation>.
    </para>
    <para>
      While these description languages work and have tooling ecosystems of varying maturity around them, they don't 
      have special provisions for the hypermedia aspect of truly RESTful APIs. In terms of the maturity model (see
      <xref linkend="maturity"/>), they can only describe APIs up to level 2. The documentation they generate is filled
      with URLs that will tightly couple the client to the server.
    </para>
    <para>
      API Blueprint supports link relations, and as such can be used to describe level 3 APIs 
      <citation>API Blueprint</citation>. It is based on Markdown syntax, which makes it relatively easy to read and 
      write by a human. However, there is no schema language that can be used to describe and validate Markdown and 
      there are several different flavors. Also, Markdown is a format for human-readable documentation, not necessarily
      machine-processable description. The API Blueprint specification is therefore a lot less readable
      than it could have been and it places a greater burden on tooling to validate API descriptions than desirable.
    </para>
    <para>
      An API description language's primary function is to enable tooling. Optimizing for human readers and writers 
      should come second. XML meets those requirements much better than Markdown.
    </para>
    <para>
      Many developers struggle with REST concepts, which is why we wrote this book. It would therefore be advantageous 
      if the description language could guide them when making their choices. The structure of the description language 
      should take the developer by the hand and make it easy to do the right thing. In particular, it would be great if
      the description language would guide developers and API designers through the API design process of 
      <xref linkend="design"/> or a similarly detailed process.
      API Blueprint has no such facilities. It merely records the end product and provides no help along the way.
    </para>
    <para>
      Another problem that API Blueprint shares with RAML and Swagger is that it encourages certain anti-patterns. For 
      instance, each HTTP method must include a response which must include a status code. This encourages clients to 
      expect only the documented status codes for a given method on a given URI, introducing tight coupling. It would 
      be better for clients to have general status code handling capabilities, so that they don't break whenever the 
      server changes. The same holds true for HTTP headers.
    </para>
  </section>

  <section>
    <title>RESTful API Description Language</title>
    <para>
      Since none of the existing API description languages seem to meet our requirements, we've invented our own.
      <firstterm>RESTful API Description Language</firstterm> (RADL) is an XML-based API description language that can 
      describe semantic, hypermedia-driven APIs (level 4).
      It's unfortunate that we had to introduce yet another language into an already fragmented landscape, but we 
      believe the benefits are worth it.
    </para>
    <para>
      The RADL language and tooling around it are open source <citation>RADL</citation>. At the time of writing, the 
      tools are far from complete, but functional enough for use in real world APIs. The RADL community encourages
      feedback and contributions.
    </para>
    <para>
      The RADL language has a place for all the concepts described in this book. Here's the basic structure: 
    </para>
    <programlisting><![CDATA[<service name="..." xmlns="urn:radl:service">
  <states>
    <!-- The state diagram -->
  </states>

  <link-relations>
    <!-- All link relations used -->
  </link-relations>

  <data-models>
    <!-- The data in the messages -->
  </data-models>

  <problems>
    <!-- The error conditions -->
  </problems>

  <media-types>
    <!-- All media types used -->
  </media-types>

  <resources>
    <!-- The resource model -->
  </resources>
</service>]]></programlisting>
    <para>
      The <literal>&lt;states&gt;</literal> element captures the state diagram. It contains a 
      <literal>&lt;start-state&gt;</literal> element that holds the transition to the initial state. This transition 
      will usually correspond to a <literal>GET</literal> on the billboard URI.
      Transitions point to other <literal>&lt;state&gt;</literal> elements as required to implement the state diagram.
    </para>
    <para>
      Things in RADL are identified by name. This is true for states and transitions and many other elements that we
      will see shortly. The name is captured in the <literal>name</literal> attribute of the element. The value of
      this attribute is a human-readable string.
    </para>
    <para>
      Many elements in RADL support the <literal>&lt;documentation&gt;</literal> element that contains information 
      that is intended to be read by a human. Documentation is mostly meant for client developers that program 
      against the REST API, but it can also be used to give information to server developers. Documentation may
      contain HTML markup. Remember to declare the XML namespace, <literal>http://www.w3.org/1999/xhtml</literal>, if 
      you want to use HTML.
    </para>
    <para>
      The next section contains the link relations used by the API. For standard link relations you can use the
      <literal>&lt;specification&gt;</literal> element to point to where the link relation is defined. For extension
      link relations, you may add <literal>&lt;documentation&gt;</literal> as desired. The 
      <literal>&lt;link-relation&gt;</literal> element also contains the transitions implemented by the link relation.
    </para>
    <para>
      The structure of the messages is captured in the <literal>&lt;data-models&gt;</literal> section. Each data model
      if a list of properties, which can be nested. Each <literal>&lt;property&gt;</literal> element may contain a
      <literal>uri</literal> parameter that points to the vocabulary definition.
    </para>
    <para>
      You can capture the problem types of an API using the <literal>&lt;problems&gt;</literal> element. It contains
      multiple <literal>&lt;problem&gt;</literal> elements that can hold documentation. You can also assign URIs to the
      problems using the <literal>uri</literal> attribute.
    </para>
    <para>
      Next up is a list of media types used. Most APIs will have a primary media type that they use for most messages.
      An API may also occasionally use other media types, for instance for uploading documents. Like a link relation,
      a <literal>&lt;media-type&gt;</literal> element may contain a <literal>&lt;specification&gt;</literal>.
    </para>
    <para>
      The final section of a RADL document is the resource model. The information in this part is comparable to an
      entire RAML or Swagger definition. Each <literal>&lt;resource&gt;</literal> contains a 
      <literal>&lt;location&gt;</literal> element that captures the URI or URI template. It also contains the methods.
      A <literal>&lt;method&gt;</literal> links to the transitions it implements and contains the request and response,
      if applicable.
    </para>
  </section>
  
  <section>
    <title>RESTBucks in RADL</title>
    <para>
      To see RADL in action, we're going to walk through the steps of procedure 
      "<xref linkend="design-rest-api"/>" for RESTBucks:
    </para>
    <orderedlist>
      <listitem>
       <para>
         Document requirements with state diagrams.
       </para>
       <para>
         We saw the state diagram for the RESTBuck customer in <xref linkend="sd-customer"/>.
         Here's what that looks like in RADL:
       </para>
       <programlisting><![CDATA[<service xmlns="urn:radl:service" name="restbucks">
  <start-state>
    <transitions>
      <transition name="Arrive" to="Arrived">
        <documentation>
          The process starts when the customer walks into the store.
        </documentation>
      </transition>
    </transitions>
  </start-state>

  <state name="Arrived">
    <transitions>
      <transition name="Read menu" to="Deciding">
        <documentation>
          Once the customer has arrived in the store, she reads the 
          menu to see what the store offers.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Deciding">
    <properties name="menu"/>
    <transitions>
      <transition name="Place order" to="Ordered">
        <documentation>
          The customer composes an order from the items on the menu
          and places the order with the cashier.
        </documentation>
        <input>
          <properties name="order"/>
        </input>
      </transition>
    </transitions>
  </state>

  <state name="Ordered">
    <properties name="order"/>
    <transitions>
      <transition name="Change" to="Ordered">
        <documentation>
          As long as the customer hasn't paid, she can change her 
          order.
        </documentation>
        <input>
          <properties name="order"/>
        </input>
      </transition>
      <transition name="Cancel" to="Canceled">
        <documentation>
          The customer may decide she doesn't want anything after
          all and cancel the whole order.
        </documentation>
      </transition>
      <transition name="Pay" to="Paid">
        <documentation>
          The customer pays for the order.
        </documentation>
        <input>
          <properties name="payment"/>
        </input>
      </transition>
    </transitions>
  </state>

  <state name="Canceled"/>

  <state name="Paid">
    <properties name="receipt"/>
    <transitions>
      <transition name="Take receipt" to="Waiting">
        <documentation>
          The customer accepts the confirmation of her payment.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Waiting">
    <transitions>
      <transition name="Wait" to="Waiting">
        <documentation>
          The customer has to wait a while.
        </documentation>
      </transition>
      <transition name="Receive notification" to="Served">
        <documentation>
          The barista notifies the customer once he has prepared
          her serving.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Served">
    <properties name="serving"/>
    <transitions>
      <transition name="Take serving" to="Happy">
        <documentation>
          The customer picks up her serving.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Happy"/>
</service>]]></programlisting>
      </listitem>
      <listitem>
       <para>
         Discover resources and methods from state transitions.
       </para>
       <para>
         The resources and methods for RESTbucks are listed in <xref linkend="restbucks-customer-resources"/>.
         Here's what that looks like in RADL:
       </para>
       <programlisting><![CDATA[<resources>
</resource>]]></programlisting>
      </listitem>
      <listitem>
       <para>
         Name resources with URIs.
       </para>
       <para>
       </para>
      </listitem>
      <listitem>
       <para>
         Name state transitions with link relations.
       </para>
       <para>
       </para>
      </listitem>
      <listitem>
       <para>
         Design messages.
       </para>
       <para>
       </para>
      </listitem>
      <listitem>
       <para>
         Document application semantics.
       </para>
       <para>
       </para>
      </listitem>
      <listitem>
       <para>
         Select a media type to serialize messages.
       </para>
       <para>
       </para>
      </listitem>
      <listitem>
       <para>
         Document the error conditions.
       </para>
      </listitem>
      <listitem>
       <para>
         Validate the design.
       </para>
       <para>
         There is no markup for validating the design, but the tooling around RADL can validate the API
         description up to a certain point. It will catch things like transitions that are not 
         implemented using a method, or unreachable states. We can envision more elaborate validation, 
         like comparison with the design patterns listed in <xref linkend="patterns"/>, but this task 
         will fundamentally remain one for humans to complete.
       </para>
      </listitem>
    </orderedlist>
  </section>

  <section id="tools">
    <title>RADL Tooling</title>
    <para>
      One thing that all API description languages are used for, is to generate documentation for developers of client
      applications. The output is usually HTML, but sometimes other formats are supported as well. API description
      formats based on Markdown can use existing tools to generate PDF, for instance. 
    </para>
    <para>
      Since RADL is based on XML, we can use the rich suite of XML tools to process it. For generating HTML
      documentation, an XSLT stylesheet is provided. It wouldn't be hard to use XSL:FO to produce PDF output as well.
      The HTML documentation for RESTBucks is shown in <xref linkend="restbucks-api-doc"/>.  
    </para>
    <figure id="restbucks-api-doc">
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/restbucks-api-doc.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <title>HTML documentation generated from RADL describing the RESTBucks API.</title>
    </figure>
    <para>
      While documentation is essential for any API, there are many more things one can use RADL for. At the time of
      writing, there is a modest collection of tools around RADL that make working with it easy and efficient.
    </para>
    <para>
      This book assumes a greenfield project, where you have the luxury of designing your API before you start coding
      it. Your situation may very well be different. Many existing products are in the process of adding APIs on top
      of existing code. RADL tries very hard to be useful in both API-first and code-first approaches to API design.
    </para>
    <para>
    </para>
  </section>
  
  <section>
    <title>Summary</title>
  </section>
</chapter>
