<chapter id="radl">
  <title>API Description</title>

  <section id="api-description">
    <title>API Description Languages</title>
    <para>
      The ever increasing number of APIs makes it worthwhile to develop an ecosystem of tools that aid humans in
      working with APIs.
    </para>
    <para>
      One tool could produce human-readable documentation, say in HTML or PDF form, that supports client developers.
      Another tool could produce skeleton code for a server implementing the API, a client consuming it, or an SDK 
      for developing a client for it (see <xref linkend="sdk"/>). Yet another tool could test whether a server 
      implements the documented API correctly. Another one could fuzz requests
      to test input validation (see <xref linkend="input-validation"/> and <xref linkend="test-security"/>).
      There are many possibilities.
    </para>
    <para>
      These tools can significantly increase the speed of the development process. Some shorten or reduce manual
      activities, while others run completely autonomously and thus can be included in a continuous integration or
      deployment pipeline <citation>HumbleFarley10</citation>.
    </para>
    <para>
      All these tools need to understand the APIs they work with, which means we need to be able to describe APIs in a
      machine-processable way. A language for doing so is known as an <firstterm>API description language</firstterm>.
    </para>
    <para>
      There have been several attempts at API description languages. Web Service Description Language is the standard 
      description language for SOAP-based APIs <citation>WSDL</citation>. We've recently seen a bunch of new description 
      languages pop up that vie for the same status in the REST space <citation>API Blueprint</citation>
      <citation>RADL</citation> <citation>RAML</citation> <citation>Swagger</citation> <citation>WADL</citation>.
    </para>
    <para>
      The sheer number of them makes it difficult to choose. We propose the following criteria that
      API description languages must meet, in order of importance:
    </para>
    <orderedlist>
      <listitem>
        <para>
          The API description language must be able to describe APIs on the highest levels (3 and 4) of the maturity 
          model (see <xref linkend="maturity"/>). It would be nice if it can also describe lower levels, but that
          doesn't have much priority for us since we want to encourage higher-level APIs.
        </para>
      </listitem>
      <listitem>
        <para>
          The description language must be machine-processable, so that it can support tools. It would be nice if the
          language is also somewhat human-readable, but that is not a priority since editing tools can hide most
          (if not all) of the syntax.
        </para>
      </listitem>
      <listitem>
        <para>
          The language must allow for capturing both structured and unstructured data. Ideally most of the data is
          stored in a structured way, so that tools can more easily process it, but there will always be a need to
          store free-form documentation to capture more subtle points about the API.
        </para>
      </listitem>
      <listitem>
        <para>
          The language should support both the design-first and the code-first style of API development. In this book, 
          we're focusing on design-first, because that's a more convenient approach to teach. It is not the only way, 
          however, or the best way in every situation. For existing projects, it can be much more convenient to work 
          your way back from the code that already exists to arrive at a design and then improve or expand the design.
          This is especially true when there is no design documentation, or when that documentation is out-of-date.
        </para>
      </listitem>
      <listitem>
        <para>
          The language should take the API designer by the hand and guide them into making the right choices. It should
          be easy to do the right thing, even if the designer isn't 100% up to speed with what the right thing actually
          is.
          In particular, it would be great if the description language would guide people through the API design process
          of <xref linkend="design"/>, or a similarly detailed process. This guidance must not, however, restrict more
          experienced API designers. Nor must it get in the way of a code-first approach.
        </para>
      </listitem>
    </orderedlist>
    <para>
      It is also important that the API description language is an open standard and that the tooling around it is open
      source. Since this is the case for all contenders, we won't discuss this criterion any further. 
    </para>
    <para>
      <xref linkend="api-description-languages"/> shows how the existing API description languages score on these
      requirements. Only RADL supports semantic profiles and only RADL guides the API designer. It scores about
      the same as other API description languages on the other criteria. In our view that makes it the winner, but we
      are RADL contributors so we may be biased. Hopefully the criteria listed above will help you make your own
      informed decision.
    </para>
    <para>
      One potential downside of RADL is that its community is much smaller than that of some of the others, in
      particular RAML and Swagger. You'll have to weigh the pros and cons to make the best choice for your situation.
      In the remainder of this book we'll use RADL.
    </para>
    <table pgwide="1" id="api-description-languages">
      <title>Comparison Of API Description Languages</title>
      <thead>
        <tr>
          <th>Criterion</th>
          <th>API Blueprint</th>
          <th>RADL</th>
          <th>RAML</th>
          <th>Swagger</th>
          <th>WADL</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Supported maturity levels</td>
          <td>0-3</td>
          <td>0-4</td>
          <td>0-2</td>
          <td>0-2</td>
          <td>0-2</td>
        </tr>
        <tr>
          <td>Machine-processable</td>
          <td>Markdown has limited support, but API Blueprint AST has JSON and YAML serializations</td>
          <td>XML is widely supported</td>
          <td>YAML has decent support</td>
          <td>JSON is widely supported; YAML has decent support</td>
          <td>XML is widely supported</td>
        </tr>
        <tr>
          <td>Structured vs unstructured</td>
          <td>GitHub Flavored Markdown for structured and unstructured data</td>
          <td>Mostly structured, can add free-form text and HTML in <literal>&lt;documentation&gt;</literal> elements</td>
          <td>YAML for structured data; Markdown for documentation</td>
          <td>JSON or YAML for structured data; GitHub-flavored Markdown for documentation</td>
          <td>Mostly structured, can add free-form text in <literal>&lt;doc&gt;</literal> elements</td>
        </tr>
        <tr>
          <td>Supports code-first</td>
          <td>Grape (GrapeApiary)</td>
          <td>JAX-RS and Spring (radl-java)</td>
          <td>JAX-RS (RAML for JAX-RS)</td>
          <td>JAX-RS (JAX-RS analyzer)</td>
          <td>JAX-RS (Jersey)</td>
        </tr>
        <tr>
          <td>Guides designer</td>
          <td>No</td>
          <td>Yes</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <title>RADL</title>
    <para>
      <firstterm>RESTful API Description Language</firstterm> (RADL) is an XML-based API description language that can 
      describe semantic, hypermedia-driven APIs (level 4).
    </para>
    <para>
      The RADL language and tooling around it are open source. At the time of writing, the tools are incomplete but
      functional enough for real world usage. The RADL community keeps adding more capabilities and encourages feedback
      and contributions.
    </para>
    <para>
      The RADL language has a place for all the concepts described in this book. Here's the basic structure: 
    </para>
    <programlisting><![CDATA[<service name="..." xmlns="urn:radl:service">
  <states>
    <!-- The state diagram -->
  </states>

  <link-relations>
    <!-- All link relations used -->
  </link-relations>

  <property-groups>
    <!-- The properties in the messages -->
  </property-groups>

  <media-types>
    <!-- All media types used -->
  </media-types>

  <errors>
    <!-- The error conditions -->
  </errors>

  <resources>
    <!-- The resource model -->
  </resources>
</service>]]></programlisting>
    <para>
      The <literal>&lt;states&gt;</literal> element captures the state diagram we discussed in
      <xref linkend="state-diagrams"/>. It contains a <literal>&lt;start-state&gt;</literal> element that holds the 
      transition to the initial state. This transition will usually correspond to a <literal>GET</literal> on the 
      billboard URI. Transitions point to other <literal>&lt;state&gt;</literal> elements as required to implement the 
      state diagram.
    </para>
    <para>
      Items in RADL are identified by name. This is true for states and transitions and many other elements that we
      will see shortly. The name is captured in the <literal>name</literal> attribute of the element. The value of
      this attribute is a human-readable string. Some elements can refer to other elements by name.
    </para>
    <para>
      Most items in RADL, like states and transitions, support the <literal>&lt;documentation&gt;</literal> element that 
      contains information that is intended to be read by a human. Documentation is mostly meant for client developers 
      that program against the REST API, but it can also be used for other purposes, like giving information to server
      developers.
      Documentation may contain HTML markup by using the <literal>http://www.w3.org/1999/xhtml</literal> namespace.
    </para>
    <para>
      The next section contains the link relations used by the API. 
      For standard link relations you can use the <literal>&lt;specification&gt;</literal> element to point the standard
      that defines the link relation. For extension link relations, you may add <literal>&lt;documentation&gt;</literal>
      as desired.
    </para>
    <para>
      The <literal>&lt;link-relation&gt;</literal> element contains the transitions implemented by the 
      link relation. A client developer can use the state diagram to determine how to accomplish its goal, and then
      discover the link relations the client must follow to transition to the subsequent states. The tooling around
      RADL presents this information in an easy to consume way so that you don't have to manually hunt down references.
    </para>
    <para>
      The structure of the data that is exchanged between client and server is captured in the 
      <literal>&lt;property-groups&gt;</literal> section. Each property group holds a list of properties and/or nested
      property groups.
      Each <literal>&lt;property-group&gt;</literal> and <literal>&lt;property&gt;</literal> element may contain a
      <literal>uri</literal> attribute that points to the semantic definition of the property (group).
      You can also add examples to a property group.
    </para>
    <para>
      States and transitions may be linked to property groups. For a state, the property group describes what
      information is available in that state. For a transition, the property group describes what information
      the client must present to the server to follow that transition. Property groups are separate from the
      state model so that they can be re-used between states and transitions, as we saw in
      <xref linkend="design-messages"/>.
    </para>
    <para>
      Next up is a list of media types used. Most APIs will have a default media type that they use for most messages,
      which you can indicate with the <literal>default</literal> attribute on <literal>&lt;media-types&gt;</literal>.
      An API may also use other media types, for instance for uploading documents. Like a 
      <literal>&lt;link-relation&gt;</literal>, a <literal>&lt;media-type&gt;</literal> element may contain a 
      <literal>&lt;specification&gt;</literal> and/or <literal>&lt;documentation&gt;</literal>.
    </para>
    <para>
      You can capture the error conditions of an API using the <literal>&lt;errors&gt;</literal> element. It contains
      multiple <literal>&lt;error&gt;</literal> elements that can hold documentation. As always in RADL, you can use the
      <literal>name</literal> attribute to name the error. This can be a simple human-readable name, but it can also be
      a URI that defines the semantics of the error.
    </para>
    <para>
      Errors are not linked to states, transitions, or even resources, because RADL tries to encourage both servers and
      clients to follow the best practice of building centralized error handling capabilities, as we'll see in
      <xref linkend="controller"/> and <xref linkend="resilience"/>.
    </para>
    <para>
      The final section of a RADL document is the resource model. The information in this part is comparable to an
      entire RAML or Swagger API description. Each <literal>&lt;resource&gt;</literal> contains a 
      <literal>&lt;location&gt;</literal> element that captures the URI or URI template. It also contains the methods.
      A <literal>&lt;method&gt;</literal> captures which transitions it implements and also indicates the request and/or 
      response media types supported.
    </para>
    <para>
      This is just a high-level overview of RADL. There are more elements, for instance for capturing headers and URI
      query string parameters. Please refer to the RADL specification and examples for more information
      <citation>RADL</citation>.
    </para>
    <para>
      At the time of writing the only support for creating RADL files is by extracting it from code. For the
      design-first approach, creating an API description in RADL is a manual activity. But it's easy to see how in the
      future tooling could be built to help with that.
    </para>
    <para>
      For instance, an IDE plug-in could walk an API designer through the steps of procedure
      "<xref linkend="state-diagram-to-resource-model"/>" (see <xref linkend="design"/>) using a wizard. It's even
      conceivable that API descriptions can be kickstarted from BDD scenarios, following procedure
      "<xref linkend="bdd-scenario-to-state-diagram"/>" of <xref linkend="bdd-to-sd"/>.
    </para>
  </section>
  
  <section>
    <title>RESTBucks in RADL</title>
    <para>
      The structure of RADL guides the API designer through the process of designing an API, from requirements captured
      by the state model to the resources and error conditions. We'll show you how that works by going through the steps
      of procedure "<xref linkend="design-rest-api"/>" in <xref linkend="error"/> for RESTBucks:
    </para>
    <orderedlist>
      <listitem>
       <para>
         Document requirements with state diagrams.
       </para>
       <para>
         We saw the state diagram for the RESTBuck customer in <xref linkend="sd-customer"/>.
         Here's what that looks like in RADL:
       </para>
       <programlisting><![CDATA[<service xmlns="urn:radl:service" name="restbucks">
  <start-state>
    <transitions>
      <transition name="Arrive" to="Arrived">
        <documentation>
          The process starts when the customer walks into the store.
        </documentation>
      </transition>
    </transitions>
  </start-state>

  <state name="Arrived">
    <transitions>
      <transition name="Read menu" to="Deciding">
        <documentation>
          Once the customer has arrived in the store, she reads the 
          menu to see what the store offers.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Deciding"/>
    <transitions>
      <transition name="Place order" to="Ordered">
        <documentation>
          The customer composes an order from the items on the menu
          and places the order with the cashier.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Ordered"/>
    <transitions>
      <transition name="Change" to="Ordered">
        <documentation>
          As long as the customer hasn't paid, she can change her 
          order.
        </documentation>
      </transition>
      <transition name="Cancel" to="Canceled">
        <documentation>
          The customer may decide she doesn't want anything after
          all and cancel the whole order.
        </documentation>
      </transition>
      <transition name="Pay" to="Paid">
        <documentation>
          The customer pays for the order.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Canceled"/>

  <state name="Paid">
    <transitions>
      <transition name="Take receipt" to="Waiting">
        <documentation>
          The customer accepts the confirmation of her payment.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Waiting">
    <transitions>
      <transition name="Wait" to="Waiting">
        <documentation>
          The customer has to wait a while.
        </documentation>
      </transition>
      <transition name="Receive notification" to="Served">
        <documentation>
          The barista notifies the customer once he has prepared
          her serving.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Served">
    <transitions>
      <transition name="Take serving" to="Happy">
        <documentation>
          The customer picks up her serving.
        </documentation>
      </transition>
    </transitions>
  </state>

  <state name="Happy"/>
</service>]]></programlisting>
      </listitem>
      <listitem>
       <para>
         Discover resources and methods from state transitions.
       </para>
       <para>
         Each transition in the state diagram needs to be implemented by some method on some resource. The
         RADL validation tool will issue warnings if there are unimplemented transitions. By adding an implementing
         method for the transition you can make that warning go away. In this sense, the RADL structure and tooling
         guide the API designer in the design process.
       </para>
       <para>
         The resources and methods for RESTbucks are listed in <xref linkend="restbucks-customer-resources"/>.
         Here's what that looks like in RADL:
       </para>
       <programlisting><![CDATA[<resources>
  <resource name="Home">
    <methods>
      <method name="GET">
        <transitions>
          <transition name="Arrive"/>
        </transitions>
      </method>
    </method>
  </resource>
  
  <resource name="Menu">
    <methods>
      <method name="GET">
        <transitions>
          <transition name="Read menu"/>
        </transitions>
      </method>
    </methods>
  </resource>
  
  <resource name="Orders">
    <methods>
      <method name="POST">
        <transitions>
          <transition name="Place order"/>
        </transitions>
      </method>
    </methods>
  </resource>
  
  <resource name="Order">
    <methods>
      <method name="PUT">
        <transitions>
          <transition name="Change order"/>
        </transitions>
      </method>
      <method name="DELETE">
        <transitions>
          <transition name="Cancel"/>
        </transitions>
      </methods>
    </methods>
  </resource>
  
  <resource name="Payments"
    <methods>
      <method name="POST">
        <transitions>
          <transition name="Pay"/>
        </transitions>
      </method>
    </methods>
  </resource>
  
  <resource name="Receipt">
    <methods>
      <method name="GET">
        <transitions>
          <transition name="Take receipt"/>
        </transitions>
      </method>
    </methods>
  </resource>
  
  <resource name="Serving">
    <methods>
      <method name="GET">
        <transitions>
          <transition name="Receive notification"/>
        </transitions>
      </method>
      <method name="DELETE">
        <transitions>
          <transition name="Take serving"/>
        </transitions>
      </method>
    </methods>
  </resource>
</resource>]]></programlisting>
      </listitem>
      <listitem>
       <para>
         Name resources with URIs.
       </para>
       <para>
        The <literal>&lt;location&gt;</literal> element captures the URI or URI Template of a
        <literal>&lt;resource&gt;</literal>. As soon as you add a resource in the previous step, the validation tool
        will issue a warning about a missing <literal>&lt;location&gt;</literal>. Again, the structure and tooling
        around RADL guide you in your next step.
       </para>
       <para>
         The URIs for the RESTBucks resources are in <xref linkend="restbucks-resources"/>. Here's what that looks in
         RADL:
       </para>
       <programlisting><![CDATA[<resources>
  <resource name="Home">
    <location uri="/"/>
    <!-- Methods omitted for brevity -->
  </resource>
  
  <resource name="Menu">
    <location uri="/menu/"/>
    <!-- Methods omitted for brevity -->
  </resource>
  
  <resource name="Orders"
    <location uri="/orders/"/>
    <!-- Methods omitted for brevity -->
  </resource>
  
  <resource name="Order">
    <location uri-template="/orders/{order-id}/"/>
    <!-- Methods omitted for brevity -->
  </resource>
  
  <resource name="Payments"
    <location uri-template="/orders/{order-id}/payments/"/>
    <!-- Methods omitted for brevity -->
  </resource>
  
  <resource name="Receipt">
    <location uri-template="/orders/{order-id}/receipt/"/>
    <!-- Methods omitted for brevity -->
  </resource>
  
  <resource name="Serving">
    <location uri-template="/orders/{order-id}/serving/"/>
    <!-- Methods omitted for brevity -->
  </resource>
</resource>]]></programlisting>
      </listitem>
      <listitem>
        <para>
          Name state transitions with link relations.
        </para>
        <para>
          The RADL validation tool also issues a warning for every transition that isn't discoverable through a link
          relation.
          The link relations for RESTBucks are in <xref linkend="restbucks-link-relations"/>. Here's what that looks
          like in RADL:
        </para>
        <programlisting><![CDATA[<link-relations>
  <link-relation name="@id">
    <specification href="http://www.w3.org/TR/json-ld/"/>
    <transitions>
      <transition ref="Wait"/>
    </transitions>
  </link-relation>

  <link-relation name="ListenAction">
    <specification href="https://schema.org/ListenAction"/>
    <transitions>
      <transition ref="Receive notification"/>
    </transitions>
  </link-relation>

  <link-relation name="ReplaceAction">
    <specification href="https://schema.org/ReplaceAction"/>
    <transitions>
      <transition ref="Change"/>
    </transitions>
  </link-relation>
  
  <link-relation name="DeleteAction">
    <specification href="https://schema.org/DeleteAction"/>
    <transitions>
      <transition ref="Cancel"/>
    </transitions>
  </link-relation>

  <link-relation name="ReceiveAction">
    <specification href="http://schema.org/ReceiveAction"/>
    <transitions>
      <transition ref="Take serving"/>
    </transitions>
  </link-relation>
  
  <link-relation name="PayAction">
    <specification href="https://schema.org/PayAction"/>
    <transitions>
      <transition ref="Pay"/>
    </transitions>
  </link-relation>

  <link-relation name="menu">
    <specification href="http://schema.org/menu"/>
    <transitions>
      <transition ref="Read menu"/>
    </transitions>
  </link-relation>

  <link-relation name="OrderAction">
    <specification href="http://schema.org/OrderAction"/>
    <transitions>
      <transition ref="Place order"/>
    </transitions>
  </link-relation>

  <link-relation name="Order">
    <specification href="http://schema.org/Order"/>
    <transitions>
      <transition ref="Take receipt"/>
    </transitions>
  </link-relation>
  
</link-relations>]]></programlisting>
      </listitem>
      <listitem>
       <para>
        Design data.
       </para>
       <para>
         The RADL validation tool knows which HTTP methods require requests and/or responses. In RADL, a 
         <literal>&lt;method&gt;</literal>'s <literal>&lt;request&gt;</literal> is linked to a
         <literal>&lt;transition&gt;</literal> and its <literal>&lt;response&gt;</literal> to a 
         <literal>&lt;state&gt;</literal>, so the validation tool can issue a warning whenever the
         corresponding <literal>&lt;transition&gt;</literal> or <literal>&lt;state&gt;</literal> doesn't refer to a
         <literal>&lt;property-group&gt;</literal>.
       </para>
       <para>
         The data for RESTBucks messages are in <xref linkend="restbucks-messages"/>. Here are the corresponding
         property groups in RADL:
       </para>
       <programlisting><![CDATA[<property-groups>
  <property-group name="home"/>

  <property-group name="item">
    <property name="name"/>
    <property name="size"/>
    <property name="milk"/>
    <property name="price"/>
    <property name="currency"/>
  </property-group>

  <property-group name="menu">
    <property-group name="item" ref="item" repeats="true"/>
  </property-group>

  <property-group name="order">
    <property-group name="item" ref="item" repeats="true"/>
    <property name="customer"/>
    <property name="total"/>
    <property name="currency"/>
  </property-group>

  <property-group name="receipt">
    <property name="dateTime"/>
    <property name="shop"/>
    <property-group name="item" ref="item" repeats="true"/>
    <property name="total"/>
    <property name="currency"/>
    <property name="paymentMethod"/>
  </property-group>

  <property-group name="payment">
    <property name="amount"/>
    <property name="currency"/>
    <property name="paymentMethod"/>
    <property name="cardholderName"/>
    <property name="cardNumber"/>
    <property name="expiryMonth"/>
    <property name="expiryYear"/>
    <property name="cardSecurityCode"/>
  </property-group>

  <property-group name="serving"/>
</property-groups>]]></programlisting>
      <para>
        The next step is to refer to the property groups from the states and transitions:
      </para>
      <programlisting><![CDATA[<states>
  <state name="Arrived" property-group="home">
    <!-- Rest omitted for brevity -->
  </state>
  
  <state name="Deciding" property-group="menu">
    <transitions>
      <transition name="Place order" to="Ordered" property-group="order">
        <!-- Rest omitted for brevity -->
      </transition>
    </transitions>
    <!-- Rest omitted for brevity -->
  </state>
  
  <state name="Ordered" property-group="order">
    <transitions>
      <transition name="Change" to="Ordered" property-group="order">
        <!-- Rest omitted for brevity -->
      </transition>
      <transition name="Pay" to="Paid" property-group="payment">
        <!-- Rest omitted for brevity -->
      </transition>
    </transitions>
    <!-- Rest omitted for brevity -->
  </state>
  
  <state name="Canceled" property-group="order"/>

  <state name="Paid" property-group="receipt">
    <!-- Rest omitted for brevity -->
  </state>
  
  <state name="Waiting" property-group="serving">
    <!-- Rest omitted for brevity -->
  </state>

  <state name="Served" property-group="serving">
    <!-- Rest omitted for brevity -->
  </state>
</states>]]></programlisting>
    </listitem>
    <listitem>
      <para>
        Document application semantics.
      </para>
      <para>
        At the time of writing, APIs at maturity level 4 (see <xref linkend="maturity"/>) unfortunately make up only a
        small minority of all APIs. So the RADL validation tool doesn't issue any warnings for missing semantics and
        by default. You can change this through configuration. (As an aside, any warnings can be suppressed; this is
        true for both individual instances and whole classes of warnings.)
      </para>
      <para>
        The semantics for RESTBucks are defined in <xref linkend="restbuck-semantics"/>. Here's what that looks like 
        in RADL:
      </para>
      <programlisting><![CDATA[<property-groups>
  <property-group name="home" uri="http://schema.org/CafeOrCoffeeShop"/>

  <property-group name="item" uri="http://schema.org/Product">
    <property name="name" uri="http://schema.org/name"/>
    <property name="size" uri="http://schema.org/height"/>
    <property name="milk" uri="http://www.productontology.org/doc/Milk"/>
    <property name="price" uri="http://schema.org/price" type="number"/>
    <property name="currency" uri="http://schema.org/priceCurrency"/>
  </property-group>

  <property-group name="menu" uri="http://schema.org/menu">
    <property-group name="item" ref="item" repeats="true"/>
  </property-group>

  <property-group name="order" uri="http://schema.org/Order">
    <property-group name="item" ref="item" repeats="true"/>
    <property name="customer" uri="http://schema.org/customer"/>
    <property name="total" uri="http://schema.org/totalPrice" type="number"/>
    <property name="currency" uri="http://schema.org/priceCurrency"/>
  </property-group>

  <property-group name="receipt" uri="http://schema.org/Order">
    <property name="dateTime" uri="http://schema.org/orderDate"
        type="xsd:dateTime"/>
    <property name="shop" uri="http://schema.org/seller"/>
    <property-group name="item" ref="item" repeats="true"/>
    <property name="total" uri="http://schema.org/totalPrice" type="number"/>
    <property name="currency" uri="http://schema.org/priceCurrency"/>
    <property name="paymentMethod"
        uri="http://schema.org/acceptedPaymentMethod"/>
  </property-group>

  <property-group name="payment"
      uri="http://reference.data.gov.uk/def/payment#payment">
    <property name="amount" uri="http://schema.org/totalPrice"
        type="number"/>
    <property name="currency" uri="http://schema.org/priceCurrency"/>
    <property name="paymentMethod"
        uri="http://schema.org/acceptedPaymentMethod"/>
    <property name="cardholderName"
        uri="https://w3id.org/creditcard/v1/name"/>
    <property name="cardNumber"
        uri="https://w3id.org/creditcard/v1/number"/>
    <property name="expiryMonth"
        uri="https://w3id.org/creditcard/v1/expiryMonth" type="number"/>
    <property name="expiryYear"
        uri="https://w3id.org/creditcard/v1/expiryYear" type="number"/>
    <property name="cardSecurityCode"
        uri="https://w3id.org/creditcard/v1/verificationCode"/>
  </property-group>

  <property-group name="serving" uri="http://schema.org/Order"/>
</property-groups>]]></programlisting>
      </listitem>
      <listitem>
       <para>
         Select a media type to serialize messages.
       </para>
       <para>
         Each <literal>&lt;request&gt;</literal> and <literal>&lt;response&gt;</literal> must be
         serialized using some media type. The RADL validation tool issues a warning when they are not.
       </para>
       <para>
         For RESTBucks we selected JSON-LD. Here's what that looks in RADL:
       </para>
       <programlisting><![CDATA[<media-types default="application/ld+json">
  <media-type name="application/ld+json">
    <specification href="http://www.w3.org/TR/json-ld/"/>
  </media-type>
</media-types>

<resources>
  <resource name="home">
    <methods>
      <method name="GET">
        <!-- Rest omitted for brevity -->
        <response/>
      </method>
    </method>
    <!-- Rest omitted for brevity -->
  </resource>
  
  <resource name="Orders"
    <methods>
      <method name="POST">
        <!-- Rest omitted for brevity -->
        <request/>
        <response/>
      </method>
    </methods>
  </resource>
  
  <resource name="Order">
    <methods>
      <method name="PUT">
        <!-- Rest omitted for brevity -->
        <request/>
        <response/>
      </method>
      <!-- Rest omitted for brevity -->
    </methods>
    <!-- Rest omitted for brevity -->
  </resource>
  
  <!-- Other resources -->
</resources>]]></programlisting>
        <para>
          The <literal>&lt;response&gt;</literal> element in this example is empty. Leaving out a media type that the
          response produces is a shorthand notation that avoids duplication. It means that the default media type is
          consumed (for a request) or produced (for a response). The default media type is set using the
          <literal>default</literal> attribute on the <literal>&lt;media-types&gt;</literal> element.
          So <literal>&lt;response/&gt;</literal> in the above example is equivalent to:
        </para>
        <programlisting><![CDATA[<response>
  <representations>
    <representation media-type="application/ld+json"/>
  </representations>        
</response>]]></programlisting>
      </listitem>
      <listitem>
       <para>
         Document the error conditions.
       </para>
       <para>
         Since <literal>&lt;error&gt;</literal> elements are optional and not connected to any other RADL element, the
         RADL validation tool can't help out and you are on your own here.
       </para>
       <para>
         The error conditions for RESTBucks are in <xref linkend="restbucks-errors"/>. Here's what that looks like in
         RADL:
       </para>
       <programlisting><![CDATA[<errors>
  <error name="http://errors.restbucks.com/missing-item"
      status-code="400">
    <documentation>
      The order you provided doesn't contain any menu item.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/unknown-item"
      status-code="400">
    <documentation>
      The menu item you requested is unknown to the server.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/invalid-item"
      status-code="400">
    <documentation>
      The attributes you provided are invalid for the requested menu item.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/item-out-of-stock"
      status-code="400">
    <documentation>
      The menu item you requested is temporarily out of stock.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/missing-customer"
      status-code="400">
    <documentation>
      The order you provided doesn't contain a customer name.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/invalid-payment"
      status-code="400">
    <documentation>
      The payment details you provided contain invalid values.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/overpaid"
      status-code="400">
    <documentation>
      The amount of money you paid is more than what the order costs.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/payment-not-processed"
      status-code="400">
    <documentation>
      The payment you provided could not be processed.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/already-paid"
      status-code="400">
    <documentation>
      The order is already paid and cannot be changed anymore.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/not-found"
      status-code="404">
    <documentation>
      The URI you requested doesn't exists or is not accessible by you.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/method-not-allowed"
      status-code="405">
    <documentation>
      The method you used is not supported on this URI.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/not-acceptible"
      status-code="406">
    <documentation>
      The media type you requested in the Accept header is not supported
      for this method on this URI.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/server-error"
      status-code="500">
    <documentation>
      Something went wrong on our side. We have logged the problem so
      our staff can look into it. We are sorry for the inconvenience.
    </documentation>
  </error>
  <error name="http://errors.restbucks.com/service-unavailable"
      status-code="503">
    <documentation>
      The server is temporarily not able to handle the request.
    </documentation>
  </error>
</errors>]]></programlisting>
      </listitem>
      <listitem>
       <para>
         Validate the design.
       </para>
       <para>
         We've seen how the RADL validation tool helps (up to a certain point) with validating the design.
         We can envision more elaborate validation, like comparison with the design patterns listed in
         <xref linkend="patterns"/>, but we also believe that the task of design validation will fundamentally remain
         one for humans to complete.
       </para>
      </listitem>
    </orderedlist>
    <para>
      The complete RADL description for RESTBucks can be found in the examples section of the RADL website
      <citation>RADL</citation>.
      Here's an impression of what the HTML documentation generated from that API description would look like:
    </para>
    <!-- TODO: Capture picture of documentation -->
    <figure id="restbucks-api-doc">
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/restbucks-api-doc.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <title>HTML documentation generated from RADL describing the RESTBucks API.</title>
    </figure>
  </section>

  <section>
    <title>Summary</title>
    <para>
      This chapter introduced the concept of an API description language, a machine-processable representation of an
      API around which tooling can be built. We also saw what what an API description in RADL looks like. We'll talk
      more about RADL later on in the book.
    </para>
    <para>
      This chapter concludes our advice about API design. In the next part of the book, we will turn our focus to the
      API's implementation.
    </para>
  </section>
</chapter>
