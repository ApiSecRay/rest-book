<chapter id="design">
  <title>Design Methodology</title>
  <para>
    This chapter presents our approach to designing REST APIs. Designing a REST APIs is actually fairly straightforward 
    once you have sorted out the requirements that you must meet. Here are the steps you should follow:
  </para>
  <procedure id="state-diagram-to-resource-model">
    <title>Design a REST API</title>
    <step>
      <para>Document the requirements as a state diagram.</para>
    </step>
    <step>
      <para>Discover the resources and methods from the transitions.</para>
    </step>
    <step>
      <para>Name the resources with URIs.</para>
    </step>
    <step>
      <para>Design the messages.</para>
    </step>
    <step>
      <para>Select media types to serialize the messages.</para>
    </step>
    <step>
      <para>Assign link relations to the transitions.</para>
    </step>
    <step>
      <para>Add documentation as required.</para>
    </step>
  </procedure>
  <para>
    Note that this is a variation of the design process described in <citation>Richardson07</citation>. Let's look at
    each of the steps in details. 
  </para>
  
  <section>
    <title>Document the Requirements As a State Diagram</title>
	  <para>
		  We covered this in a lot of detail in <xref linkend="state-diagrams"/>. A state diagram consists of all the
		  possible states a client can be in and the transitions that the client can make between them. Note that a single
		  REST API can serve more than one type of client, in which case you'd probably have one state diagram for each
		  type. If you're in that situation, then just follow this procedure for each state diagram and merge the results. 
	  </para> 
	  <para>
		  A state diagram is a very concise way of capturing functional requirements, but it's also the basis for 
		  discovering the resource model.
	    The <firstterm>resource model</firstterm> is the collection of resources (see <xref linkend="uniform-interface"/>)
	    that we offer, plus the methods that they support. The resource model is about how we implement the interface we
	    came up with to meet our requirements. This means we're now shifting our focus from the client to the server. 
		  Let's see how that works.
		</para>
  </section>

  <section>
    <title>Discover the resources and methods from the transitions</title>
    <para>
      Each transition in the state diagram will move the client from one state to the next. But the state diagram is
      nothing more than an abstract representation of the client's possibilities. To actually make anything happen, the 
      client will have to do something concrete, namely execute an HTTP method against a URI, as we saw in  
      <xref linkend="client-flow"/>.
    </para>
    <para>
      So for each transition, we have to decide on two things: which HTTP method to execute, and against which URI to
      execute it. We'll take an intermediary step here to reach that goal. We'll look at the HTTP method in detail, but 
      we'll push out the decision on URIs until the next step. Instead, we'll just use a simple placeholder name for the
      resource.
      You can certainly combine these sub-steps, but we think it's better to first focus on the interaction dynamics
      and leave the decision on how to identify the resources with URIs for later.
    </para>
    <para>
      Here's how we can build up the resource model from the state diagram:
    </para>
    <procedure>
      <title>Derive the Resource Model From the State Diagram</title>
      <step>
        <para>
          Start with the initial state.
        </para>
      </step>
      <step>
        <para>
          Create (or re-use) a resource with a representation that corresponds to this state.
        </para>
      </step>
      <step>
        <para>
          For each transition starting from the current state, make sure there is a corresponding method in some
          resource that implements the transition.
        </para>
      </step>
      <step>
        <para>
          Repeat for all transitions in each of the remaining states.
        </para>
      </step>
    </procedure>
    <para>
      TODO: Use the full state diagram instead
      Let's see how that works on the state diagram in <xref linkend="sd-customer-happy-path"/>:
    </para>
    <orderedlist>
      <listitem>
        <para>
          We start with the initial state, <literal>Arrived</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          We have no resources yet, so we can't re-use any and thus have to create a new one. What shall we name it? 
          Well, the client is in the state arrived, which means she has come into our store. For us, that's home, so 
          let's call this resource <literal>Home</literal>.
        </para>
        <para>
          Most APIs have a resource similar to <literal>Home</literal>. This is the resource identified by the
          billboard URI. Executing <literal>GET</literal> on this resource returns a representation that corresponds to
          the initial state in the state diagram. We'll have more to say about home resources in <xref linkend="home"/>.
        </para>
	      <informaltable>
	        <thead>
	          <tr>
	            <th>Resource</th>
	            <th>Method</th>
	            <th>Transition</th>
	          </tr>
	        </thead>
	        <tbody>
	          <tr>
	            <td>Home</td>
	            <td>GET</td>
	            <td></td>
	          </tr>
	        </tbody>
	      </informaltable>
      </listitem>
      <listitem>
        <para>
          There is one transition from the current state, <literal>Read menu</literal>. We have to pick an HTTP method
          for it, and a resource.
        </para>
        <para>
          When selecting the HTTP method, we should carefully look at the characteristics of the interaction. Refer to 
          the sidebar "<xref linkend="http-methods"/>" in <xref linkend="maturity"/> for an explanation of the HTTP 
          methods' properties to guide you in this selection.
        </para>
        <para>
          We think that reading a menu should be a safe thing to do, so we pick the <literal>GET</literal> method. We 
          simply name the resource <literal>Menu</literal>. Note how the HTTP method followed by the resource name
          (<literal>GET </literal> Menu) sounds a lot like the transition name (<literal>Read menu</literal>). 
          This is no coincidence.
        </para>
        <para>
          We could have made the menu part of the representation returned by the home resource. That would
          have saved the client from following one link, but it also would have tied our service to the menu. We like
          to keep one level of indirection at the start, so that we always have a place to add additional functionality
          in a backwards compatible way. We'll discuss this topic in more detail in 
          <xref linkend="maintenance"/>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We now move to the next state, <literal>Deciding</literal>, which has two outgoing transitions, 
          <literal>Select from menu</literal> and <literal>Order</literal>.
        </para>
        <para>
          The <literal>Select from menu</literal> transition doesn't change anything on the server. At this point, the 
          customer is still composing her order, which is application state rather than resource state (refer to
          <xref linkend="rest"/> for an explanation of the difference). So we don't need to execute any HTTP method at 
          all for this transition.
        </para>
        <para>
          The <literal>Order</literal> transition is where the client informs the server about the order composed from 
          the items on the menu. This operation is neither safe nor idempotent, because ordering twice will get you 
          twice as many hot beverages as ordering once. So we should use the <literal>POST</literal> method to implement 
          this transition.
        </para>
        <para>
          What resource should offer this <literal>POST</literal> method? Remember that resources are things and
          thus described by nouns. So we should always try to convert the verbs that describe the actions that we want
          to implement into nouns. In this case, the verb is "order", which also happens to be a noun. So instead of
          "ordering" we'll be "creating an order". This is an example of the Create pattern, which we'll see more of
          in <xref linkend="create"/>. In this pattern, you create an object by sending a <literal>POST</literal> 
          against the collection that will end up containing the created object. So the resource we're looking for
          is the collection of orders. Let's name it <literal>Orders</literal>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          The next state is <literal>Ordered</literal> and it has only one outgoing transition, 
          <literal>Pay</literal>. Converting the verb <literal>Pay</literal> to a noun gives 
          <literal>Payment</literal>. Instead of "paying", we should think of "creating a payment". Once we do that, we
          see that we can employ the Create pattern again with a <literal>POST</literal> method on the 
          <literal>Payments</literal> resource. 
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          The next state is <literal>Paid</literal> with the <literal>Take receipt</literal> outgoing transition. 
          Although you can only take a receipt once in the real world, there really isn't anything destructive about
          it from an information point of view. In other words, the transition is safe and we should use 
          <literal>GET</literal> to implement it. It makes sense to simply name the resource <literal>Receipt</literal>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          Next up is <literal>Waiting</literal> with the <literal>Receive notification</literal> transition. This is
          an interesting case, because the transition isn't actually caused by something the client does, but rather
          by a state change on the server: the barista is done preparing the order. 
        </para>
        <para>
          There are two ways to implement this. We can try to stay as close to the abstract model as possible, and
          have the server notify us, or the client can repeatedly ask the server for its current status. In the real
          world the latter would be quite annoying, but machines don't suffer from such petty emotions. Server push
          is an advanced pattern that we'll talk more about in <xref linkend="notifications"/>, but here we'll go with
          the simpler pull model where the client polls the server repeatedly until it sees the changed state.
        </para>
        <para>
          Polling the server means nothing more than repeatedly asking the server for its current status until that 
          status has changed. Asking for a status is absolutely safe, so we can use the <literal>GET</literal> method.
        </para>
        <para>
          What resource should we offer this method on? Well, we're waiting for the order to change state from 
          preparing to ready, so the <literal>Order</literal> resource is the perfect candidate.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>GET</td>
              <td>Receive notification</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We're now at the <literal>Served</literal> state, with the <literal>Take order</literal> transition.
          This is not a safe or idempotent transition, because you can only take your order once, even in a purely 
          virtual world. So we could use <literal>POST</literal> again.
          Looking at the name of the transition makes a strong case for using the <literal>Order</literal> resource.
        </para>
        <para>
          Although this is solution is fine, we can do even better. The <literal>POST</literal> method is very
          non-descriptive, in the sense that it doesn't have a well-defined meaning like other methods (e.g. 
          <literal>GET</literal> and <literal>DELETE</literal>) do. We use <literal>POST</literal> a lot for the
          Create pattern, but we're not creating anything here. We're really only updating the status of the order.
          We can make that intention clearer by using the <literal>PATCH</literal> method.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>GET</td>
              <td>Receive notification</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>PATCH</td>
              <td>Take order</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We're now at the accepting state and our resource model is complete.
        </para>
      </listitem>
    </orderedlist>
    <table>
      <title>Resource Model To Support RESTBucks Customer</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry><para>Resource</para></entry>
            <entry><para>Method</para></entry>
            <entry><para>Transition</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Home</para></entry>
            <entry><para>GET</para></entry>
            <entry><para></para></entry>
          </row>
          <row>
            <entry><para>Menu</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Read menu</para></entry>
          </row>
          <row>
            <entry><para>Orders</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Receive notification</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>PATCH</para></entry>
            <entry><para>Take order</para></entry>
          </row>
          <row>
            <entry><para>Payments</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Pay</para></entry>
          </row>
          <row>
            <entry><para>Receipt</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Take receipt</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>
  
  <section>
    <title>Name the Resources With URIs</title>
    <para>
      Every resource should be identified by a URI. From the client’s perspective, this is an implementation detail,
      but we still need to do this before we can implement the server. We should follow existing best practices for URIs 
      that were developed for the human Web. The sidebar "<xref linkend="uris"/>" discusses the most relevant ones for 
      our current purpose.
    </para>

	  <sidebar id="uris">
	    <title>Conventions around Uniform Resource Identifiers (URIs)</title>
	    <para>
	      One important URI convention is that URIs should be cool <citation>CoolUris</citation>, which means they won't 
	      change. This is to avoid breaking bookmarks. Although bookmarks are less important for REST APIs than for the
	      human Web, it's still nice to be able to support them.
	      In order to keep URIs stable, we shouldn't put information in them that is likely to change. For instance,
	      if we were to build a REST API for a social media platform, we shouldn't put usernames in the URIs, but rather
	      internal IDs. This doesn't read as nicely, but that's okay since URIs are discovered anyway. Assuming the API
	      is implemented by a cluster of servers, you'll need a way to assign internal IDs without conflict. Universially
	      Unique Identifiers (UUIDs) are perfect for this.
	    </para>
	    <para>
	      An extremely common convention used in URIs is to indicate hierarchical relationships with slashes. So if we
	      have a collection of users at <literal>/users/</literal>, then an individual user would live at 
	      <literal>/users/{id}/</literal>. Note that this is not technically a URI, because the <literal>{</literal>
	      and <literal>}</literal> symbols are not allowed in URIs according to RFC 3986. It's rather a concise way of 
	      indicating a whole collection of URIs, like <literal>/users/1/</literal>, <literal>/users/2/</literal>, etc. 
	      This is also known as a URI Template <citation>UriTemplate</citation>.
	    </para>
	    <para>
	      Another common convention is to use only lowercase letters from the US ASCII character set. This ensures that
	      the URIs will work without any problems with any URI handling technology. For non-English speakers, this may
	      seem like a severe limitation, but it doesn't have to be. We advise to use English names in your URIs anyway,
	      since that will ensure that they are understandable for a very large part of the world's population.
	    </para>
	    <para>
	      A less common, but still very useful convention is to end all URIs with a slash (<literal>/</literal>). The 
	      rationale behind this is that it makes it very easy to resolve URIs, even if they're relative. Relative URIs are
	      very useful in deeply hierarchical cases. As as example, resolving the relative URI <literal>1/</literal> against 
	      the base URI <literal>/users/</literal> gives the intended <literal>/users/1/</literal>, whereas resolving the 
	      same relative URI against the base URI <literal>/users</literal> results in <literal>/1/</literal>.
	      We'll talk more about resolving URIs in <xref linkend="client"/>.
	    </para>
	  </sidebar>
	
    <para>
      Armed with this knowledge, let's take a swing at identifying our RESTBucks resources with URIs:
    </para>
    <table>
      <title>Partial resource model for RESTBucks customer</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry><para>Resource</para></entry>
            <entry><para>URI (Template)</para></entry>
            <entry><para>Method</para></entry>
            <entry><para>Transition</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Home</para></entry>
            <entry><para>/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para></para></entry>
          </row>
          <row>
            <entry><para>Menu</para></entry>
            <entry><para>/menu/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Read menu</para></entry>
          </row>
          <row>
            <entry><para>Orders</para></entry>
            <entry><para>/orders/</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Receive notification</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>PATCH</para></entry>
            <entry><para>Take order</para></entry>
          </row>
          <row>
            <entry><para>Payments</para></entry>
            <entry><para>/orders/{id}/payments/</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Pay</para></entry>
          </row>
          <row>
            <entry><para>Receipt</para></entry>
            <entry><para>/orders/{id}/receipt/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Take receipt</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>
      We've put our home resource at <literal>/</literal>, which is a common choice. Note that this is a relative URI.
      For our design it doesn't matter what the absolute URI is, that's more of an implementation detail. It could be
      <literal>http://api.restbucks.com/</literal>, for instance, or <literal>http://buycoffeeonline.com/</literal>.
      While the billborad URI is an important decision from a marketing perspective, it's not all that important from
      a technical perspective.
    </para>
    <para>
      We have two top-level resources, <literal>/menu/</literal> for the menu, and <literal>/orders/</literal> for the
      orders. The latter contains sub-resources for specific orders, including their payments and receipts.
    </para>
  </section>

  <section>
    <title>Design the Messages</title>
    <para>
      At this point we almost have a complete resource model. All that is left to do, is design our representations.
      In this step we'll design the structure of the messages that client and server exchange. In the next step, we'll
      serialize the messages into a series of bytes using media types.
    </para>
    <para>
      We start with indicating which of our HTTP methods require a request and which require a response. This decision 
      is usually dictated by our choice of methods. The <literal>GET</literal> method, for instance, doesn't support
      a request but does almost always expect a response.
    </para>
    <informaltable>
      <thead>
        <tr>
          <th>Resource</th>
          <th>Method</th>
          <th>Transition</th>
          <th>Request</th>
          <th>Response</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Home</td>
          <td>GET</td>
          <td></td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Menu</td>
          <td>GET</td>
          <td>Read menu</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Orders</td>
          <td>POST</td>
          <td>Order</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Order</td>
          <td>GET</td>
          <td>Receive notification</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Order</td>
          <td>PATCH</td>
          <td>Take order</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Payments</td>
          <td>POST</td>
          <td>Pay</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Receipt</td>
          <td>GET</td>
          <td>Take receipt</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </informaltable>
    <para>
      There are ten entries marked with Yes in the above table, but the number of messages is smaller because messages
      are re-used. We really only need the home document, a menu, an order, a payment, and a receipt. The home document
      is extremely simple, because it only consists of links. The other messages are easy to design, since we've done
      our homework during the analysis phase.
    </para>
    <para>
      The <literal>menu</literal> message consists of all the items that our customers can order. We could use a 
      generic item that can be sold by any shop, but we're not just any shop, we're RESTBucks. So we want to make it 
      easier on our clients to provide correct orders by giving our items a bit more structure. Each item is a type of
      drink, so we add the <literal>drink</literal> property to our items. This is the main identifying property of an
      item. We serve our drinks in different sizes, so we also add a <literal>size</literal> property. Finally, our hot 
      beverages also differ in how much milk they contain, so we add a <literal>milk</literal> property. Our menu
      is really nothing more than a list of items. We could go further and put the items into categories. This is quite
      a common trick to help human users, but our software clients don't mind going through a seemingly endless list of
      items, so we're not going to bother.
    </para>
    <para>
      An order contains of a number of items that the customer wants to purchase. These are the same items that are on
      the menu, of course, so we can re-use the item design. We need a couple of other properties. The barista needs to
      call the customer when the order is prepared, so we should add a <literal>customer</literal> property for this 
      purpose. We also like to include a <literal>total</literal>. One could argue that this can be calculated from the
      items, but there may be complications like quantum discounts and whatnot that we want to be prepared for. Finally,
      we need a <literal>status</literal> property to keep track of the various state changes that we saw earlier.
    </para>
    <para>
      A payment could take many forms. We could go overboard and design a very flexible solution that will cater to
      any and all payment methods, but this book is about REST, not payments. Since RESTBucks is an online store, we'll
      simply assume a credit card payment. So we'll need the following properties: <literal>amount</literal>, 
      <literal>cardholderName</literal>, <literal>cardNumber</literal>, <literal>expiryMonth</literal>, and 
      <literal>expiryYear</literal>. To be future-proof, we'll throw in a <literal>type</literal> field as well, so that
      we can add different payment methods later.
    </para>
    <para>
      The receipt should have <literal>date</literal> and <literal>time</literal> properties and show the 
      <literal>shop</literal> to be RESTBucks. It should also have a list of the purchased <literal>item</literal>s and 
      their <literal>price</literal>s, and a <literal>total</literal> price. Finally, it should have a 
      <literal>paymentMethod</literal> so that customers can crosscheck the receipt with their credit card statements.
    </para>
  </section>
  
  <section id="media-types">
    <title>Select Media Types To Serialize the Messages</title>
    <para>
      When extending an existing design, you should stick with the already selected media type(s). For new APIs, you
      have to decide what media type(s) to use.
    </para>
    <para>
      There are different kinds of media types. <firstterm>Application-specific media types</firstterm> are designed for 
      a single application or service. For instance, <literal>application/vnd.github+json</literal> is the media type 
      used by the GitHub API <citation>GitHubApi</citation>. <firstterm>Domain-specific media types</firstterm> are 
      designed to represent problems in one particular domain. For instance, Scalable Vector Graphics (SVG, 
      <literal>image/svg+xml</literal>) <citation>SVG</citation> deals only with vector graphics. 
      <firstterm>General purpose media types</firstterm> can be used for any service in any domain. The best known 
      general purpose media type is of course HTML (<literal>text/html</literal>) <citation>HTML</citation>.
    </para>
    <para>
      Another way to categorize media types is by who defined them <citation>RichAmun13</citation>. 
      <firstterm>Fiat standards</firstterm> are informal descriptions of the way someone does something. They don't try 
      to convince other people to do things the same way. <firstterm>Personal standards</firstterm> do invite people
      to follow them, but they're still just one person's opinion. <firstterm>Corporate standards</firstterm> are
      are created by a single company or a consortium of companies to solve recurring problems. Finally, an
      <firstterm>open standard</firstterm> has gone through a process of design by committee and is blessed by some
      sort of standards body.
    </para>
    <para>
      Media types that are described by a standard are usually registered with the Internet Assigned Numbers Authority 
      (IANA) <citation>IANA</citation>. This makes them easy to discover. Registered media types are of the form
      type<literal>/</literal>sub-type, where the number of types is fixed. For REST APIs, most media types will fall
      within the <literal>application</literal> type. 
      The IANA registry is made up of several trees. The so-called vendor tree is for registering personal and corporate 
      standards, while the standards tree contains open standards. Media types in the vendor tree start thee sub-type
      with <literal>vnd</literal>, we'll see shortly.
    </para>
    <para>
      There is some correlation between these two dimensions. An application-specific media type will have little 
      chance of getting adopted as an open standard, for instance. However, SVG and HTML are both open standards, but 
      one is domain-specific while the other is general purpose.
    </para>
    <para>
      In general, it makes sense to select a general purpose media type defined as an open standard. This choice means
      you won't have to document anything; you can simply point to an existing specification. Chances are that there
      are existing tools and/or libraries available to work with the media type, so you can save yourself and your 
      clients some coding effort. You can also profit from a lot of thinking that went into the existing standard.
    </para>
    <para>
      The problem with a general purpose media type is, well, that it isn't specifically tailored to your needs. You 
      will have to find a way to express your particular domain in the media type. Remember from 
      <xref linkend="maturity"/> that semantic profiles can bridge that gap. If you're lucky enough to work in a domain
      for which such a semantic profile already exists, then you can re-use that. But even if you're not that lucky,
      you can still save yourself a lot of work by selecting a general purpose media type. You only have to describe
      your semantics, instead of the semantics, plus the protocol, plus the data format.  
    </para>
    <para>
      Most media types are derived from an existing base format like XML (e.g. SVG) or JSON (e.g. GitHub). The default
      these days is to use JSON-based media types, so if you don't have a strong reason to use something else, you 
      should go with JSON.
    </para>
    <para>
      Note that JSON itself, <literal>application/json</literal>, is not a hypermedia type, since JSON doesn’t define 
      links. You can, of course, use a convention on top of JSON, for instance that there should be a 
      <literal>links</literal> property with a certain structure to describes the links. The problem with this approach
      is that it's a fiat or personal standard, and we've already seen that open standards are better. In the following
      sections we will take a look at some JSON-based media types that are defined by open standards and that allow
      the inclusion of hyperlinks.
    </para>
    <para>
      As of this writing, the jury is still out on which of the following media types is going to win out as the 
      <emphasis>de facto</emphasis> standard media type for REST APIs. If you pick one format now, chances are that
      you picked the wrong one, and will want to change it later. You can minimize the impact of such a change by
      being careful when implementing your service. We'll come back to that in <xref linkend="implementation"/>.
    </para>
    
    <section>
      <title>HAL</title>
    </section>
    <para>
      Since <literal>application/json</literal> has no provisions for linking, we can't use it as a hypermedia format.
      In other words, you can use JSON for REST maturity levels 0, 1, and 2, but not for levels 3 or 4 (see 
      <xref linkend="maturity"/>). To get to level 3, we need to add linking capabilities. 
    </para>
    <para>
      That's exactly what Hypermedia Application Language (HAL) provides <citation>HAL</citation>. HAL, or 
      <literal>application/hal+json</literal> is a JSON-based language that adds a <literal>_links</literal> property. 
      The underscore is an attempt to avoid naming conflicts, since JSON doesn't have the equivalent of XML namespaces. 
      Here's what a RESTBuck order could look like in HAL:
    </para>
    <programlisting>
			{ "_links": {
			    "self": { 
			      "href": "http://api.restbucks.com/order/1234/"
			    },
			    "curies": [{
			      "name": "relations",
			      "href": "http://relations.restbucks.com/"
			    }],
			    "relations:cancel": { 
			      "href": "http://api.restbucks.com/order/1234/"
			    },
			    "payment": {
			      "href": "http://api.restbucks.com/order/1234/payments/"
			    }
			    "edit": { 
			      "href": "http://api.restbucks.com/order/1234/"
			    }
			  },
			  "_embedded": {
			    "item": [{
			      "size": "tall",
			      "milk": "whole",
			      "drink": "caffe latte"
			    }]
			  },
			  "total": 2.75,
			  "status": "unpaid"
			}
    </programlisting>
    <para>
      The value of the <literal>_links</literal> property is a JSON object where each property is a link relation
      (More on link relations below). The object itself must at least have an <literal>href</literal> property that 
      contains the URL of the linked to resource.
    </para>
    <para>
      HAL supports curies, which are ways to shorten URLs. For example, the <literal>relations</literal> curie above 
      shortens the URL for the <literal>cancel</literal> link relation. Curies are optional.
    </para>
    <para>
      There are pros and cons to using curies. They achive slightly shorter messages, which could translate to smaller
      transmission times. On the other hand, JSON is a textual format and therefore compresses very well, so it's
      doubtful that the effect of curies would be noticeable when you use compression. Curies make the JSON a bit easier 
      to read for humans, but a bit more difficult to parse for computer programs. Given that REST APIs are really meant
      for machine-to-machine communication, we advise not to use them. It puts an extra burden on your clients that we
      feel isn't worth the small benefit. 
    </para>
    <para>
      HAL only allows simple properties in the JSON object. But sometimes, that model doesn't fit your data. In the
      RESTBucks example, an order is made up of potentially more than one item. HAL uses the <literal>_embedded</literal>
      property to handle such sub-entities.
    </para>
    <para>
      Remember that a level 3 REST API must support both links and forms (see <xref linkend="maturity"/>). While HAL
      provides hyperlinking capabilities using the <literal>_links</literal> property, it doesn't have anything for
      handling forms. So with HAL you can only build level 3a APIs. Yet HAL is a big improvement over plain JSON, and 
      it is quite popular. For instance, it is used by default in Spring HATEOAS <citation>SpringHateaos</citation>.
      This no doubt is due to its simplicity.
    </para>
    <para>
      HAL is a registered in the open standards tree of IANA, but it hasn't reached the status of standard yet. At the
      point of writing, HAL is a Internet Draft (ID). Internet Drafts are the vehicle of the IETF standards body to
      propose new standards. Once an Internet Draft is vetted by reviewers, it may turn into a full standard, or RFC.
      HTTP is one example of an RFC.
    </para>
    
    <section>
      <title>Mason</title>
    </section>
    <para>
      The Mason <citation>Mason</citation> media type, <literal>application/vnd.mason+json</literal>, fills the gap that
      HAL leaves. Like HAL, Mason supports links (using the <literal>@links</literal> property), including curies (using 
      the <literal>@namespaces</literal> property). In addition, it supports the forms using the 
      <literal>@actions</literal> property. Here's how a RESTBucks order could look like in Mason:
    </para>
    <programlisting>
			{ "@namespaces": {
			    "relations": {
			      "name": "http://relations.restbucks.com/"
			    }
			  },
			  "item": [{
			    "size": "tall",
			    "milk": "whole",
			    "drink": "caffe latte"
			  }],
			  "total": 2.75,
			  "status": "unpaid",
			  "@links": {
			    "self": { 
			      "href": "http://api.restbucks.com/order/1234/"
			    }
			  },
			  "@actions": {
			    "relations:cancel": { 
			      "href": "http://restbucks.com/order/1234/",
			      "type": "void",
			      "method": "DELETE"
			    },
			    "payment": {
			      "href": "http://api.restbucks.com/order/1234/payments/",
			      "title": "Pay the order",
			      "type": "any",
			      "method": "POST",
			      "template": {
			        "payment": {
			          "amount": 2.75,
			          "type": "creditcard",
			          "cardholderName": "",
			          "cardNumber": "",
			          "expiryMonth": "",
			          "expiryYear": ""
			        }
			      }
			    },
			    "edit": { 
			      "href": "http://api.restbucks.com/order/1234/",
			      "type": "any",
			      "method": "PATCH",
			      "template": {
			        "item": [{
			          "size": "tall",
			          "milk": "whole",
			          "drink": "caffee latte"
			        }],
			        "total": 2.75,
			        "status": "unpaid"
			      }
			    }
			  }
			}
    </programlisting>
    <para>
      Mason allows for natural sub-objects, rather than HAL's <literal>_embedded</literal> property. But the main
      advantage of Mason over HAL is the <literal>@actions</literal> property that supports forms. Mason is thus
      suited to build REST APIs at level 3b. The <literal>method</literal> property allows specifying which HTTP
      method to use, so clients no longer have to hard-code that knowledge. This gives you the opportunity to switch
      from <literal>POST</literal> to <literal>PATCH</literal>, for instance, and not break existing clients.
    </para>
    <para>
      For HTTP methods that require input, the <literal>template</literal> property specifies what that input should
      look like. This makes it easy to translate the JSON message into an HTML form, or to dynamically build your 
      mobile UI.
    </para>
    <para>
      A peculiarity of the <literal>@actions</literal> is the <literal>type</literal> property, which can be 
      <literal>void</literal>, <literal>json</literal>, <literal>json-files</literal>, or <literal>any</literal>.
      One would have expected a media type there instead.
    </para>
    <para>
      As you can tell from the <literal>vnd.</literal> prefix in the sub-type, Mason is a personal standard. We're not
      aware of any efforts to move this to an open standard.
    </para>
    
    <section>
      <title>Siren</title>
    </section>
    <para>
      HAL and Mason use keywords starting with <literal>_</literal> or <literal>@</literal> so that they don't
      conflict with user-defined properties. Siren <citation>Siren</citation>, 
      or <literal>application/vnd.siren+json</literal>, does things a bit differently. It prescribes the structure of 
      the message, so that it's always clear what part is defined by Siren and what part is specific to the service.
      This has the benefit of clarity at the cost of a more deeply nested structure.
    </para>
    <programlisting>
			{ "class": [ "order" ],
			  "properties": [{
			    "total": 2.75,
			    "status": "unpaid"
			  },
			  "entities": [{
			    "class": [ "item" ],
			    "rel": [ "http://relations.restbucks.com/item" ],
			    "properties": {
			      "size": "tall",
			      "milk": "whole",
			      "drink": "caffe latte"
			    }
			  }],
			  "actions": [{
			    "name": "http://relations.restbucks.com/cancel",
			    "title": "Cancel the order",
			    "method": "DELETE",
			    "href": "http://api.restbucks.com/order/1234/"
			  }, {
			    "name": "payment",
			    "title": "Pay the order",
			    "href": "http://api.restbucks.com/orders/1234/payments/",
			    "type": "application/vnd.siren+json",
			    "method": "POST",
			    "fields": [{
			      "name": "amount",
			      "type": "number",
			      "value": 2.75
			    }, {
			      "name": "type",
			      "type": "text"
			      "value": "creditcard"
			    }, {
			      "name": "cardholderName",
			      "type": "text"
			    }, {
			      "name": "cardNumber",
			      "type": "text"
			    }, {
			      "name": "expiryMonth",
			      "type": "number"
			    }, {
			      "name": "expiryYear",
			      "type": "number"
			    }],
			  }, {
			    "name": "edit",
			    "href": "http://api.restbucks.com/order/1234/",
			    "method": "PATCH",
			    "type": "application/vnd.siren.json"
          "fields": [{
            "name": "status",
            "type": "text",
            "value": "unpaid"
          }]
			  }],
			  "links": [{ 
			    "rel": "self",
			    "href": "http://api.restbucks.com/order/1234/"
			  }]
			}
    </programlisting>
    <para>
      Siren uses the <literal>properties</literal> property to capture the properties of the object being transmitted.
      The <literal>entities</literal> property is similar to the <literal>_embedded</literal> property of HAL.
      Siren uses the <literal>actions</literal> property much like Mason uses <literal>@actions</literal>, but it
      adds HTML types to the fields. For clients that use HTML, this allows for a seamless translation into forms.
    </para>
    <para>
      Siren and Mason are very similar. The big difference is that Siren uses the <literal>class</literal> property
      much like HTML does for semantic descriptors. In combination with semantic profiles, this feature makes it 
      possible to use Siren in a level 4 API, which is not possible with Mason.
    </para>
    
    <section>
      <title>UBER</title>
    </section>
    <para>
      Uniform Basis for Exchanging Representations (UBER) <citation>UBER</citation> is another media type that allows 
      level 4 APIs. This format is optimized for the number of design elements used. While that keeps the specification
      fairly short, it does make the messages a bit more difficult to read.
    </para>
    <programlisting>
			{ "uber": {
			  "version": "1.0",
			  "data": [{
			    "rel": [ "self" ],
			    "url": "http://api.restbucks.com/order/1234/"
			  }, {
			    "id": "order",
			    "data": [{
			      "name": "item",
			      "data": [{
			        "name": "milk",
			        "value": "whole"
			      }, {
			        "name": "size", 
			        "value": "tall",
			      }, {
			        "name": "drink",
			        "value": "caffe latte"
			      }]
			    }, {
			      "name": "total",
			      "value": 2.75
			    }, {
			      "name": "status",
			      "value": "unpaid"
			    }]
			  }, {
			    "rel": "http://relations.restbucks.com/cancel",
			    "url": "http://api.restbucks.com/order/1234/",
			    "action": "remove"
			  }, {
			    "rel": "payment",
			    "url": "http://api.restbucks.com/order/1234/payments/",
			    "sending": "application/vnd.uber+json",
			    "action": "append",
			    "data": [{
			      "name": "amount",
			      "value": 2.75
			    }, {
			      "name": "type",
            "value": "creditcard"
			    }, {
			      "name": "cardholderName",
			    }, {
			      "name": "cardNumber",
			    }, {
			      "name": "expiryMonth",
			    }, {
			      "name": "expiryYear",
			    }],
			  }, {
			    "rel": "edit",
			    "url": "http://api.restbucks.com/order/1234/",
			    "action": "replace",
			    "sending": "application/vnd.uber.json"
			  }]
			}
    </programlisting>
    <para>
      There is nothing in the REST architectural style that ties it to HTTP, although that is the most commonly used
      protocol for transmitting the messages. UBER acknowledges this fact by abstracting away the HTTP methods. Instead
      of using <literal>POST</literal>, one would use <literal>append</literal>, for instance. When you use a protocol
      like CoAP <citation>CoAP</citation> instead of HTTP, that may make sense, but the vast majority of APIs don't do
      that.
    </para>
    <para>
      UBER also makes a distinction between the media types used in the request and response, using the 
      <literal>sending</literal> and <literal>accepting</literal> properties. Siren only allows one value in its
      <literal>type</literal> property.
    </para>
    
    <section>
      <title>Hydra</title>
    </section>
    <para>
      TODO: describe
    </para>
    
    <section>
      <title>JSON-LD</title>
    </section>
    <para>
      TODO: describe
    </para>
    
    <section>
      <title>Selecting a media type</title>
    </section>
    <para>
      The previous sections presented a bunch of media types and listed their pros and cons. At this point in time, 
      there is no no media type that is an open standard, supports level 4 APIs, and is widely accepted and implemented.
    </para>
    <para>
      So which one should you pick for your API? The answer depends on how comfortable you are building on a personal 
      standard versus an open standard. It also depends on how far up the maturity ladder you want to be. And it even
      depends on taste.
    </para>
    <para>
      For RESTBucks, we want a media type that supports level 4 APIs. We don't like the lack of readability of UBER.
      So we're going to pick Siren for now. We understand that this choice may change in the future and we will be 
      careful to minimize the impact of that change.
    </para>
  </section>

  <section>
    <title>Assign Link Relations To the Transitions</title>
    <para>
      A REST client follows transitions in the state diagram by discovering links in representations. This discovery
      process is made possible by link relations.
      Link relations decouple the client from the URIs that the server uses,
      giving the server the freedom to change
      its URI structure at will without breaking any clients. Link relations are
      therefore an important part of any
      REST API.
    </para>
    <para>
      We should try to use existing link relations as much as possible. They don’t cover every case, however, so
      sometimes you need to invent your own.
    </para>
  </section>

  <section>
    <title>Add Documentation As Required</title>
    <para>
      In order to help developers build clients that work against your API, you will most likely want to add some
      documentation that explains certain more subtle points.
      Examples are very helpful to illustrate those points.
      You
      may also add instructions for server developers that will implement the API, like what caching to use.
    </para>
    <section>
      <title>Show Examples</title>
    </section>
  </section>
</chapter>
