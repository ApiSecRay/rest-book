<chapter id="design">
  <title>Design Methodology</title>
  <para>
    This chapter presents our approach to designing REST APIs. Designing a REST APIs is actually fairly straightforward 
    once you have sorted out the requirements that you must meet. Here are the steps you should follow:
  </para>
  <procedure id="state-diagram-to-resource-model">
    <title>Design a REST API</title>
    <step>
      <para>Document the requirements as a state diagram.</para>
    </step>
    <step>
      <para>Discover the resources and methods from the transitions.</para>
    </step>
    <step>
      <para>Name the resources with URIs.</para>
    </step>
    <step>
      <para>Select media types to serialize the representations.</para>
    </step>
    <step>
      <para>Assign link relations to the transitions.</para>
    </step>
    <step>
      <para>Add documentation as required.</para>
    </step>
  </procedure>
  <para>
    Note that this is a variation of the design process described in <citation>Richardson07</citation>. Let's look at
    each of the steps in details. 
  </para>
  
  <section>
    <title>Document the Requirements As a State Diagram</title>
	  <para>
		  We covered this in a lot of detail in <xref linkend="state-diagrams"/>. A state diagram consists of all the
		  possible states a client can be in and the transitions that the client can make between them. Note that a single
		  REST API can serve more than one type of client, in which case you'd probably have one state diagram for each
		  type. If you're in that situation, then just follow this procedure for each state diagram and merge the results. 
	  </para> 
	  <para>
		  A state diagram is a very concise way of capturing functional requirements, but it's also the basis for 
		  discovering the resource model.
	    The <firstterm>resource model</firstterm> is the collection of resources (see <xref linkend="uniform-interface"/>)
	    that we offer, plus the methods that they support. The resource model is about how we implement the interface we
	    came up with to meet our requirements. This means we're now shifting our focus from the client to the server. 
		  Let's see how that works.
		</para>
  </section>

  <section>
    <title>Discover the resources and methods from the transitions</title>
    <para>
      Each transition in the state diagram will move the client from one state to the next. But the state diagram is
      nothing more than an abstract representation of the client's possibilities. To actually make anything happen, the 
      client will have to do something concrete, namely execute an HTTP method against a URI, as we saw in  
      <xref linkend="client-flow"/>.
    </para>
    <para>
      So for each transition, we have to decide on two things: which HTTP method to execute, and against which URI to
      execute it. We'll take an intermediary step here to reach that goal. We'll look at the HTTP method in detail, but 
      we'll push out the decision on URIs until the next step. Instead, we'll just use a simple placeholder name for the
      resource.
      You can certainly combine these sub-steps, but we think it's better to first focus on the interaction dynamics
      and leave the decision on how to identify the resources with URIs for later.
    </para>
    <para>
      Here's how we can build up the resource model from the state diagram:
    </para>
    <procedure>
      <title>Derive the Resource Model From the State Diagram</title>
      <step>
        <para>
          Start with the initial state.
        </para>
      </step>
      <step>
        <para>
          Create (or re-use) a resource with a representation that corresponds to this state.
        </para>
      </step>
      <step>
        <para>
          For each transition starting from the current state, make sure there is a corresponding method in some
          resource that implements the transition.
        </para>
      </step>
      <step>
        <para>
          Repeat for all transitions in each of the remaining states.
        </para>
      </step>
    </procedure>
    <para>
      Let's see how that works on the state diagram in <xref linkend="sd-customer-happy-path"/>:
    </para>
    <orderedlist>
      <listitem>
        <para>
          We start with the initial state, <literal>Arrived</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          We have no resources yet, so we can't re-use any and thus have to create a new one. What shall we name it? 
          Well, the client is in the state arrived, which means she has come into our store. For us, that's home, so 
          let's call this resource <literal>Home</literal>.
        </para>
        <para>
          Most APIs have a resource similar to <literal>Home</literal>. This is the resource identified by the
          billboard URI. Executing <literal>GET</literal> on this resource returns a representation that corresponds to
          the initial state in the state diagram. We'll have more to say about home resources in <xref linkend="home"/>.
        </para>
	      <informaltable>
	        <thead>
	          <tr>
	            <th>Resource</th>
	            <th>Method</th>
	            <th>Transition</th>
	          </tr>
	        </thead>
	        <tbody>
	          <tr>
	            <td>Home</td>
	            <td>GET</td>
	            <td></td>
	          </tr>
	        </tbody>
	      </informaltable>
      </listitem>
      <listitem>
        <para>
          There is one transition from the current state, <literal>Read menu</literal>. We have to pick an HTTP method
          for it, and a resource.
        </para>
        <para>
          When selecting the HTTP method, we should carefully look at the characteristics of the interaction. Refer to 
          the sidebar "<xref linkend="http-methods"/>" in <xref linkend="maturity"/> for an explanation of the HTTP 
          methods' properties to guide you in this selection.
        </para>
        <para>
          We think that reading a menu should be a safe thing to do, so we pick the <literal>GET</literal> method. We 
          simply name the resource <literal>Menu</literal>. Note how the HTTP method followed by the resource name
          (<literal>GET </literal> Menu) sounds a lot like the transition name (<literal>Read menu</literal>). 
          This is no coincidence.
        </para>
        <para>
          We could have made the menu part of the representation returned by the home resource. That would
          have saved the client from following one link, but it also would have tied our service to the menu. We like
          to keep one level of indirection at the start, so that we always have a place to add additional functionality
          in a backwards compatible way. We'll discuss this topic in more detail in 
          <xref linkend="maintenance"/>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We now move to the next state, <literal>Deciding</literal>, which has two outgoing transitions, 
          <literal>Select from menu</literal> and <literal>Order</literal>.
        </para>
        <para>
          The <literal>Select from menu</literal> transition doesn't change anything on the server. At this point, the 
          customer is still composing her order, which is application state rather than resource state (refer to
          <xref linkend="rest"/> for an explanation of the difference). So we don't need to execute any HTTP method at 
          all for this transition.
        </para>
        <para>
          The <literal>Order</literal> transition is where the client informs the server about the order composed from 
          the items on the menu. This operation is neither safe nor idempotent, because ordering twice will get you 
          twice as many hot beverages as ordering once. So we should use the <literal>POST</literal> method to implement 
          this transition.
        </para>
        <para>
          What resource should offer this <literal>POST</literal> method? Remember that resources are things and
          thus described by nouns. So we should always try to convert the verbs that describe the actions that we want
          to implement into nouns. In this case, the verb is "order", which also happens to be a noun. So instead of
          "ordering" we'll be "creating an order". This is an example of the Create pattern, which we'll see more of
          in <xref linkend="create"/>. In this pattern, you create an object by sending a <literal>POST</literal> 
          against the collection that will end up containing the created object. So the resource we're looking for
          is the collection of orders. Let's name it <literal>Orders</literal>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          The next state is <literal>Ordered</literal> and it has only one outgoing transition, 
          <literal>Pay</literal>. Converting the verb <literal>Pay</literal> to a noun gives 
          <literal>Payment</literal>. Instead of "paying", we should think of "creating a payment". Once we do that, we
          see that we can employ the Create pattern again with a <literal>POST</literal> method on the 
          <literal>Payments</literal> resource. 
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          The next state is <literal>Paid</literal> with the <literal>Take receipt</literal> outgoing transition. 
          Although you can only take a receipt once in the real world, there really isn't anything destructive about
          it from an information point of view. In other words, the transition is safe and we should use 
          <literal>GET</literal> to implement it. It makes sense to simply name the resource <literal>Receipt</literal>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          Next up is <literal>Waiting</literal> with the <literal>Receive notification</literal> transition. This is
          an interesting case, because the transition isn't actually caused by something the client does, but rather
          by a state change on the server: the barista is done preparing the order. 
        </para>
        <para>
          There are two ways to implement this. We can try to stay as close to the abstract model as possible, and
          have the server notify us, or the client can repeatedly ask the server for its current status. In the real
          world the latter would be quite annoying, but machines don't suffer from such petty emotions. Server push
          is an advanced pattern that we'll talk more about in <xref linkend="notifications"/>, but here we'll go with
          the simpler pull model where the client polls the server repeatedly until it sees the changed state.
        </para>
        <para>
          Polling the server means nothing more than repeatedly asking the server for its current status until that 
          status has changed. Asking for a status is absolutely safe, so we can use the <literal>GET</literal> method.
        </para>
        <para>
          What resource should we offer this method on? Well, we're waiting for the order to change state from 
          preparing to ready, so the <literal>Order</literal> resource is the perfect candidate.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>GET</td>
              <td>Receive notification</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We're now at the <literal>Served</literal> state, with the <literal>Take order</literal> transition.
          This is not a safe or idempotent transition, because you can only take your order once, even in a purely 
          virtual world. So we could use <literal>POST</literal> again.
          Looking at the name of the transition makes a strong case for using the <literal>Order</literal> resource.
        </para>
        <para>
          Although this is solution is fine, we can do even better. The <literal>POST</literal> method is very
          non-descriptive, in the sense that it doesn't have a well-defined meaning like other methods (e.g. 
          <literal>GET</literal> and <literal>DELETE</literal>) do. We use <literal>POST</literal> a lot for the
          Create pattern, but we're not creating anything here. We're really only updating the status of the order.
          We can make that intention clearer by using the <literal>PATCH</literal> method.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>GET</td>
              <td>Receive notification</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>PATCH</td>
              <td>Take order</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We're now at the accepting state and our resource model is complete.
        </para>
      </listitem>
    </orderedlist>
    <table>
      <title>Resource Model To Support RESTBucks Customer</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry><para>Resource</para></entry>
            <entry><para>Method</para></entry>
            <entry><para>Transition</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Home</para></entry>
            <entry><para>GET</para></entry>
            <entry><para></para></entry>
          </row>
          <row>
            <entry><para>Menu</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Read menu</para></entry>
          </row>
          <row>
            <entry><para>Orders</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Receive notification</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>PATCH</para></entry>
            <entry><para>Take order</para></entry>
          </row>
          <row>
            <entry><para>Payments</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Pay</para></entry>
          </row>
          <row>
            <entry><para>Receipt</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Take receipt</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>
  
  <section>
    <title>Name the Resources With URIs</title>

	  <sidebar id="uris">
	    <title>Conventions around Uniform Resource Identifiers (URIs)</title>
	    <para>
	      One important URI convention is that URIs should be cool <citation>CoolUris</citation>, which means they won't 
	      change. This is to avoid breaking bookmarks. Although bookmarks are less important for REST APIs than for the
	      human Web, it's still nice to be able to support them.
	      In order to keep URIs stable, we shouldn't put information in them that is likely to change. For instance,
	      if we were to build a REST API for a social media platform, we shouldn't put usernames in the URIs, but rather
	      internal IDs. This doesn't read as nicely, but that's okay since URIs are discovered anyway. Assuming the API
	      is implemented by a cluster of servers, you'll need a way to assign internal IDs without conflict. Universially
	      Unique Identifiers (UUIDs) are perfect for this.
	    </para>
	    <para>
	      An extremely common convention used in URIs is to indicate hierarchical relationships with slashes. So if we
	      have a collection of users at <literal>/users/</literal>, then an individual user would live at 
	      <literal>/users/{id}/</literal>. Note that this is not technically a URI, because the <literal>{</literal>
	      and <literal>}</literal> symbols are not allowed in URIs according to RFC 3986. It's rather a concise way of 
	      indicating a whole collection of URIs, like <literal>/users/1/</literal>, <literal>/users/2/</literal>, etc. 
	      This is also known as a URI Template <citation>UriTemplate</citation>.
	    </para>
	    <para>
	      Another common convention is to use only lowercase letters from the US ASCII character set. This ensures that
	      the URIs will work without any problems with any URI handling technology. For non-English speakers, this may
	      seem like a severe limitation, but it doesn't have to be. We advise to use English names in your URIs anyway,
	      since that will ensure that they are understandable for a very large part of the world's population.
	    </para>
	    <para>
	      A less common, but still very useful convention is to end all URIs with a slash (<literal>/</literal>). The 
	      rationale behind this is that it makes it very easy to resolve URIs, even if they're relative. Relative URIs are
	      very useful in deeply hierarchical cases. As as example, resolving the relative URI <literal>1/</literal> against 
	      the base URI <literal>/users/</literal> gives the intended <literal>/users/1/</literal>, whereas resolving the 
	      same relative URI against the base URI <literal>/users</literal> results in <literal>/1/</literal>.
	      We'll talk more about resolving URIs in <xref linkend="client"/>.
	    </para>
	  </sidebar>
	
    <para>
      Every resource should be identified by a URI. From the client’s perspective, this is an implementation detail,
      but we still need to do this before we can implement the server. We should follow existing best practices for URIs 
      that were developed for the human Web. The sidebar "<xref linkend="uris"/>" discusses the most relevant ones for 
      our current purpose.
    </para>
    <para>
      Armed with this knowledge, let's take a swing at identifying our RESTBucks resources with URIs:
    </para>
    <table>
      <title>Resource Model To Support RESTBucks Customer</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry><para>Resource</para></entry>
            <entry><para>URI (Template)</para></entry>
            <entry><para>Method</para></entry>
            <entry><para>Transition</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Home</para></entry>
            <entry><para>/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para></para></entry>
          </row>
          <row>
            <entry><para>Menu</para></entry>
            <entry><para>/menu/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Read menu</para></entry>
          </row>
          <row>
            <entry><para>Orders</para></entry>
            <entry><para>/orders/</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Receive notification</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>PATCH</para></entry>
            <entry><para>Take order</para></entry>
          </row>
          <row>
            <entry><para>Payments</para></entry>
            <entry><para>/orders/{id}/payments/</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Pay</para></entry>
          </row>
          <row>
            <entry><para>Receipt</para></entry>
            <entry><para>/orders/{id}/receipt/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Take receipt</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section id="media-types">
    <title>Select Media Types To Serialize the Representations</title>
    <para>
      When extending an existing design, you should stick with the already selected media types. For new APIs, you
      have to decide what media type to use.
    </para>
    <para>
      There are different kinds of media types. Domain-specific media types are specifically designed for one
      application domain and in practice even for one particular service in that domain.
      <!-- TODO: Copy from Amundsen -->
    </para>
    <para>
      BTW, application/json is not a hypermedia type, since JSON doesn’t define links. We can, of course, use a
      convention on top of JSON, for instance that there should be a links property with a certain structure to
      describes the links, like Spring HATEOAS does. The problem with conventions is that they are out-of-band
      communication, and a client has no way of knowing for sure whether that convention is followed when it sees a
      Content-Type of application/json. It’s therefore much better to use a media type that turns the convention into
      a rule, like HAL does.
    </para>
    <para>
      TODO: Add HAL, Mason, Siren, ...
    </para>
  </section>

  <section>
    <title>Assign Link Relations To the Transitions</title>
    <para>
      A REST client follows transitions in the state diagram by discovering links in representations. This discovery
      process is made possible by link relations.
      Link relations decouple the client from the URIs that the server uses,
      giving the server the freedom to change
      its URI structure at will without breaking any clients. Link relations are
      therefore an important part of any
      REST API.
    </para>
    <para>
      We should try to use existing link relations as much as possible. They don’t cover every case, however, so
      sometimes you need to invent your own.
    </para>
  </section>

  <section>
    <title>Add Documentation As Required</title>
    <para>
      In order to help developers build clients that work against your API, you will most likely want to add some
      documentation that explains certain more subtle points.
      Examples are very helpful to illustrate those points.
      You
      may also add instructions for server developers that will implement the API, like what caching to use.
    </para>
    <section>
      <title>Show Examples</title>
    </section>
  </section>
</chapter>
