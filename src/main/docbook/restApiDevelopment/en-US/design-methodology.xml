<chapter id="design">
  <title>Design Methodology</title>
  <para>
    This chapter presents our approach to designing REST APIs. Designing a REST APIs is actually fairly straightforward 
    once you have sorted out the requirements that you must meet. Here are the steps you should follow:
  </para>
  <procedure id="state-diagram-to-resource-model">
    <title>Design a REST API</title>
    <step>
      <para>Document requirements with state diagrams.</para>
    </step>
    <step>
      <para>Discover resources and methods from transitions.</para>
    </step>
    <step>
      <para>Name resources with URIs.</para>
    </step>
    <step>
      <para>Design messages.</para>
    </step>
    <step>
      <para>Assign link relations to transitions.</para>
    </step>
    <step>
      <para>Select media types to serialize messages.</para>
    </step>
    <step>
      <para>Document semantics.</para>
    </step>
  </procedure>
  <para>
    Note that this is a variation of the design process described in <citation>Richardson07</citation>. It's adapted to
    make explicit use of state diagrams and also to incorporate application semantics.
    Let's look at each of the steps in details.
  </para>
  
  <section>
    <title>Document Requirements With State Diagrams</title>
	  <para>
		  We covered this in a lot of detail in <xref linkend="state-diagrams"/>. A state diagram consists of all the
		  possible states a client can be in and the transitions that the client can make between them. Note that a single
		  REST API can serve more than one type of client, in which case you'd probably have one state diagram for each
		  type. If you're in that situation, then just follow this procedure for each state diagram and merge the results. 
	  </para> 
	  <para>
		  A state diagram is a very concise way of capturing functional requirements, but it's also the basis for 
		  discovering the resource model.
	    The <firstterm>resource model</firstterm> is the collection of resources (see <xref linkend="uniform-interface"/>)
	    that we offer, plus the methods that they support. The resource model is about how we implement the interface we
	    came up with to meet our requirements. This means we're now shifting our focus from the client to the server. 
		  Let's see how that works.
		</para>
  </section>

  <section>
    <title>Discover Resources and Methods From Transitions</title>
    <para>
      Each transition in the state diagram will move the client from one state to the next. But the state diagram is
      nothing more than an abstract representation of the client's possibilities. To actually make anything happen, the 
      client will have to do something concrete, namely execute an HTTP method against a URI, as we saw in  
      <xref linkend="client-flow"/>.
    </para>
    <para>
      So for each transition, we have to decide on two things: which HTTP method to execute, and against which URI to
      execute it. We'll take an intermediary step here to reach that goal. We'll look at the HTTP method in detail, but 
      we'll push out the decision on URIs until the next step. Instead, we'll just use a simple placeholder name for the
      resource.
      You can certainly combine these sub-steps, but we think it's better to first focus on the interaction dynamics
      and leave the decision on how to identify the resources with URIs for later.
    </para>
    <para>
      Here's how we can build up the resource model from the state diagram:
    </para>
    <procedure>
      <title>Derive the Resource Model From the State Diagram</title>
      <step>
        <para>
          Start with the initial state.
        </para>
      </step>
      <step>
        <para>
          Create (or re-use) a resource with a representation that corresponds to this state.
        </para>
      </step>
      <step>
        <para>
          For each transition starting from the current state, make sure there is a corresponding method in some
          resource that implements the transition.
        </para>
      </step>
      <step>
        <para>
          Repeat for all transitions in each of the remaining states.
        </para>
      </step>
    </procedure>
    <para>
      Let's see how that works on the state diagram in <xref linkend="sd-customer"/>:
    </para>
    <orderedlist>
      <listitem>
        <para>
          We start with the initial state, <literal>Arrived</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          We have no resources yet, so we can't re-use any and thus have to create a new one. What shall we name it? 
          Well, the client is in the state arrived, which means she has come into our store. For us, that's home, so 
          let's call this resource <literal>Home</literal>.
        </para>
        <para>
          Most APIs have a resource similar to <literal>Home</literal>. This is the resource identified by the
          billboard URI. Executing <literal>GET</literal> on this resource returns a representation that corresponds to
          the initial state in the state diagram. We'll have more to say about home resources in <xref linkend="home"/>.
        </para>
	      <informaltable>
	        <thead>
	          <tr>
	            <th>Resource</th>
	            <th>Method</th>
	            <th>Transition</th>
	          </tr>
	        </thead>
	        <tbody>
	          <tr>
	            <td>Home</td>
	            <td>GET</td>
	            <td></td>
	          </tr>
	        </tbody>
	      </informaltable>
      </listitem>
      <listitem>
        <para>
          There is one transition from the current state, <literal>Read menu</literal>. We have to pick an HTTP method
          for it, and a resource.
        </para>
        <para>
          When selecting the HTTP method, we should carefully look at the characteristics of the interaction. Refer to 
          the sidebar "<xref linkend="http-methods"/>" in <xref linkend="maturity"/> for an explanation of the HTTP 
          methods' properties to guide you in this selection.
        </para>
        <para>
          We think that reading a menu should be a safe thing to do, so we pick the <literal>GET</literal> method. We 
          simply name the resource <literal>Menu</literal>. Note how the HTTP method followed by the resource name
          (<literal>GET </literal> Menu) sounds a lot like the transition name (<literal>Read menu</literal>). 
          This is no coincidence.
        </para>
        <para>
          We could have made the menu part of the representation returned by the home resource. That would
          have saved the client from following one link, but it also would have tied our service to the menu. We like
          to keep one level of indirection at the start, so that we always have a place to add additional functionality
          in a backwards compatible way. We'll discuss this topic in more detail in 
          <xref linkend="maintenance"/>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We now move to the next state, <literal>Deciding</literal>, which has three outgoing transitions, 
          <literal>Select from menu</literal>, <literal>Abort</literal>, and <literal>Order</literal>.
        </para>
        <para>
          The <literal>Select from menu</literal> transition doesn't change anything on the server. At this point, the 
          customer is still composing her order, which is application state rather than resource state (refer to
          <xref linkend="rest"/> for an explanation of the difference). So we don't need to execute any HTTP method at 
          all for this transition.
        </para>
        <para>
          Likewise, the <literal>Abort</literal> transition doesn't have to do anything either. The customer simply
          walks out of the store.
        </para>
        <para>
          The <literal>Order</literal> transition is where the client informs the server about the order composed from 
          the items on the menu. This operation is neither safe nor idempotent, because ordering twice will get you 
          twice as many hot beverages as ordering once. So we should use the <literal>POST</literal> method to implement 
          this transition.
        </para>
        <para>
          What resource should offer this <literal>POST</literal> method? Remember that resources are things and
          thus described by nouns. So we should always try to convert the verbs that describe the actions that we want
          to implement into nouns. In this case, the verb is "order", which also happens to be a noun. So instead of
          "ordering" we'll be "creating an order". This is an example of the Create pattern, which we'll see more of
          in <xref linkend="create"/>. In this pattern, you create an object by sending a <literal>POST</literal> 
          against the collection that will end up containing the created object. So the resource we're looking for
          is the collection of orders. Let's name it <literal>Orders</literal>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          The next state is <literal>Ordered</literal> and it has two outgoing transitions, <literal>Cancel</literal> 
          and <literal>Pay</literal>.
        </para>
        <para>
          You might think that <literal>Cancel</literal> is much like 
          <literal>Abort</literal>, and from the client's perspective it may be. But the difference is that we now
          have an order in our system that is waiting for payment. We could allow the customer to do nothing (the 
          equivalent of walking out), which means we would have to have a background process to garbage collect any
          remaining unpaid orders. The alternative is to have the customer explictly tell us that she no longer
          wishes to complete her order.
        </para>
        <para>
          We'll take the latter approach here. The <literal>DELETE</literal> method is a perfect choice to make it read 
          like a natural sentence again ("Delete order"), assuming we have a <literal>Order</literal> resource. 
          Note that we can't force our clients to be polite and let us know they no longer want the order, so we'd 
          probably need to implement the garbage collection anyway. But we could start without and see how big of a 
          problem it really is before we invest any time.
        </para>
        <para>
          Converting the verb <literal>Pay</literal> to a noun gives <literal>Payment</literal>. Instead of "paying", 
          we should think of "creating a payment". Once we do that, we see that we can employ the Create pattern again 
          with a <literal>POST</literal> method on the <literal>Payments</literal> resource.
        </para>
        <para>
          An alternative would be to use the <literal>PUT</literal> method. While that has the advantage of being
          idempotent, it has the disadvantage of allowing only one payment. For now, we only accept credit cards,
          so that isn't a problem. But think about the future. What if we were to introduce coupons at some point?
          Someone would want to pay for a $15 order with a $10 coupon and a $5 credit card payment. So we can foresee
          that we might want to allow multiple payments to the same order and therefore it makes sense to use the
          Create and Collection patterns (see <xref linkend="collection"/>).
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>DELETE</td>
              <td>Abort</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          The next state is <literal>Paid</literal> with the <literal>Take receipt</literal> outgoing transition. 
          Although you can only take a receipt once in the real world, there really isn't anything destructive about
          it from an information point of view. In other words, the transition is safe and we should use 
          <literal>GET</literal> to implement it. It makes sense to simply name the resource <literal>Receipt</literal>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>DELETE</td>
              <td>Abort</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          Next up is <literal>Waiting</literal> with the <literal>Receive notification</literal> transition. This is
          an interesting case, because the transition isn't actually caused by something the client does, but rather
          by a state change on the server: the barista is done preparing the order. 
        </para>
        <para>
          There are two ways to implement this. We can try to stay as close to the abstract model as possible, and
          have the server notify us, or the client can repeatedly ask the server for its current status. In the real
          world the latter would be quite annoying, but machines don't suffer from such petty emotions. Server push
          is an advanced pattern that we'll talk more about in <xref linkend="notifications"/>, but here we'll go with
          the simpler pull model where the client polls the server repeatedly until it sees the changed state.
        </para>
        <para>
          Polling the server means nothing more than repeatedly asking the server for its current status until that 
          status has changed. Asking for a status is absolutely safe, so we can use the <literal>GET</literal> method.
        </para>
        <para>
          What resource should we offer this method on? Well, we're waiting for the order to change state from 
          preparing to ready, so the <literal>Order</literal> resource is the perfect candidate.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>DELETE</td>
              <td>Abort</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>GET</td>
              <td>Receive notification</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We're now at the <literal>Served</literal> state, with the <literal>Take order</literal> transition.
          This is not a safe or idempotent transition, because you can only take your order once, even in a purely 
          virtual world. So we could use <literal>POST</literal> again.
          Looking at the name of the transition makes a strong case for using the <literal>Order</literal> resource.
        </para>
        <para>
          Although this is solution is fine, we can do even better. The <literal>POST</literal> method is very
          non-descriptive, in the sense that it doesn't have a well-defined meaning like other methods (e.g. 
          <literal>GET</literal> and <literal>DELETE</literal>) do. We use <literal>POST</literal> a lot for the
          Create pattern, but we're not creating anything here. We're really only updating the status of the order.
          We can make that intention clearer by using the <literal>PATCH</literal> method.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>DELETE</td>
              <td>Abort</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>GET</td>
              <td>Receive notification</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>PATCH</td>
              <td>Take order</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We're now at the accepting state and our resource model is complete.
        </para>
      </listitem>
    </orderedlist>
    <table>
      <title>Resource Model To Support RESTBucks Customer</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry><para>Resource</para></entry>
            <entry><para>Method</para></entry>
            <entry><para>Transition</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Home</para></entry>
            <entry><para>GET</para></entry>
            <entry><para></para></entry>
          </row>
          <row>
            <entry><para>Menu</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Read menu</para></entry>
          </row>
          <row>
            <entry><para>Orders</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Receive notification</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>PATCH</para></entry>
            <entry><para>Take order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>DELETE</para></entry>
            <entry><para>Abort</para></entry>
          </row>
          <row>
            <entry><para>Payments</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Pay</para></entry>
          </row>
          <row>
            <entry><para>Receipt</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Take receipt</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>
  
  <section>
    <title>Name Resources With URIs</title>
    <para>
      Every resource should be identified by a URI. From the client’s perspective, this is an implementation detail,
      but we still need to do this before we can implement the server. We should follow existing best practices for URIs 
      that were developed for the human Web. The sidebar "<xref linkend="uris"/>" discusses the most relevant ones for 
      our current purpose.
    </para>

	  <sidebar id="uris">
	    <title>Conventions around Uniform Resource Identifiers (URIs)</title>
	    <para>
	      You should always use a plural name for resources that are collections. For instance, if we were to build a REST 
	      API for a social media platform, we should use <literal>/users/</literal> rather than <literal>/user/</literal>
	      because it is immediately clear from the URI that it is a collection.
	    </para>
      <para>
        URIs should be cool <citation>CoolUris</citation>, which means they won't change. This is to avoid breaking 
        bookmarks. Although bookmarks are less important for REST APIs than for the human Web, it's still nice to be 
        able to support them. In order to keep URIs stable, we shouldn't put information in them that is likely to 
        change. In the social media example, we shouldn't put user names in the URIs, but rather internal IDs. This 
        doesn't read as nicely, but that's okay since URIs are discovered anyway. Assuming the API is implemented by a 
        cluster of servers, you'll need a way to assign internal IDs without conflict. Universially Unique Identifiers 
        (UUIDs) are perfect for this, because they don't require any communication between the servers.
      </para>
	    <para>
	      Indicate hierarchical relationships with slashes in the URIs. So if we have a collection of users at 
	      <literal>/users/</literal>, then an individual user would live at <literal>/users/{id}/</literal>. Note that 
	      this is not technically a URI, because the <literal>{</literal> and <literal>}</literal> symbols are not 
	      allowed in URIs according to RFC 3986. It's actually a concise way of indicating a whole collection of URIs, 
	      like <literal>/users/1/</literal>, <literal>/users/2/</literal>, etc. This is also known as a URI Template
	      <citation>UriTemplate</citation>.
	    </para>
	    <para>
	      Another common convention is to use only lowercase letters from the US ASCII character set. This ensures that
	      the URIs will work without any problems with any URI handling technology. For non-English speakers, this may
	      seem like a limitation, but it doesn't have to be. We advise to use English names in your URIs anyway, since 
	      that will ensure that they are understandable for a very large part of the world's population.
	    </para>
	    <para>
	      A less common, but still very useful convention is to end all URIs with a slash (<literal>/</literal>). The 
	      rationale behind this is that it makes it very easy to resolve URIs, even if they're relative. Relative URIs are
	      useful in deeply hierarchical cases to keep the transmitted messages short. As as example, resolving the 
	      relative URI <literal>1/</literal> against the base URI <literal>/users/</literal> gives the intended 
	      <literal>/users/1/</literal>, whereas resolving the same relative URI against the base URI 
	      <literal>/users</literal> results in <literal>/1/</literal>. We'll talk more about resolving URIs in 
	      <xref linkend="client"/>.
	    </para>
	  </sidebar>
	
    <para>
      Armed with this knowledge, let's take a swing at identifying our RESTBucks resources with URIs:
    </para>
    <table>
      <title>Partial resource model for RESTBucks customer</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry><para>Resource</para></entry>
            <entry><para>URI (Template)</para></entry>
            <entry><para>Method</para></entry>
            <entry><para>Transition</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Home</para></entry>
            <entry><para>/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para></para></entry>
          </row>
          <row>
            <entry><para>Menu</para></entry>
            <entry><para>/menu/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Read menu</para></entry>
          </row>
          <row>
            <entry><para>Orders</para></entry>
            <entry><para>/orders/</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Receive notification</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>PATCH</para></entry>
            <entry><para>Take order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>DELETE</para></entry>
            <entry><para>Abort</para></entry>
          </row>
          <row>
            <entry><para>Payments</para></entry>
            <entry><para>/orders/{id}/payments/</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Pay</para></entry>
          </row>
          <row>
            <entry><para>Receipt</para></entry>
            <entry><para>/orders/{id}/receipt/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Take receipt</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>
      We've put our home resource at <literal>/</literal>, which is a common choice. Note that this is a relative URI.
      For our design it doesn't matter what the absolute URI is, that's more of an implementation detail. It could be
      <literal>http://api.restbucks.com/</literal>, for instance, or <literal>http://buycoffeeonline.com/</literal>.
      While the billborad URI is an important decision from a marketing perspective, it's not all that important from
      a technical perspective.
    </para>
    <para>
      We have two top-level resources, <literal>/menu/</literal> for the menu, and <literal>/orders/</literal> for the
      orders. The latter contains sub-resources for specific orders, including their payments and receipts.
    </para>
  </section>

  <section>
    <title>Design Messages</title>
    <para>
      At this point we almost have a complete resource model. All that is left to do, is design our representations.
      In this step we'll design the structure of the messages that client and server exchange. In the next step, we'll
      serialize the messages into a series of bytes using media types.
    </para>
    <para>
      We start with indicating which of our HTTP methods require a request and which require a response. This decision 
      is usually dictated by our choice of methods. The <literal>GET</literal> method, for instance, doesn't support
      a request but does almost always expect a response.
    </para>
    <informaltable>
      <thead>
        <tr>
          <th>Resource</th>
          <th>Method</th>
          <th>Transition</th>
          <th>Request</th>
          <th>Response</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Home</td>
          <td>GET</td>
          <td></td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Menu</td>
          <td>GET</td>
          <td>Read menu</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Orders</td>
          <td>POST</td>
          <td>Order</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Order</td>
          <td>GET</td>
          <td>Receive notification</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Order</td>
          <td>PATCH</td>
          <td>Take order</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Order</td>
          <td>DELETE</td>
          <td>Abort</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Payments</td>
          <td>POST</td>
          <td>Pay</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Receipt</td>
          <td>GET</td>
          <td>Take receipt</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
      </tbody>
    </informaltable>
    <para>
      There are ten entries marked with Yes in the above table, but the number of messages is smaller because messages
      are re-used. We really only need the home document, a menu, an order, a payment, and a receipt. The home document
      is extremely simple, because it only consists of links. The other messages are easy to design, since we've done
      our homework during the analysis phase.
    </para>
    <para>
      The <literal>menu</literal> message consists of all the items that our customers can order. We could use a 
      generic item that can be sold by any shop, but we're not just any shop, we're RESTBucks. So we want to make it 
      easier on our clients to provide correct orders by giving our items a bit more structure. Each item needs to be
      identified, so we add the <literal>name</literal> property to our items. We serve our drinks in different sizes, 
      so we also add a <literal>size</literal> property. Our hot beverages also differ in how much milk they contain, 
      so we add a <literal>milk</literal> property. Finally, we're in this for the money, so we add a 
      <literal>price</literal> property. Since we have international aspirations, we should also add a
      <literal>currency</literal> property. Our menu is really nothing more than a list of items. We could go further 
      and put the items into categories. This is quite a common trick to help human users, but our software clients 
      don't mind going through a seemingly endless list of items, so we're not going to bother with the added complexity.
    </para>
    <para>
      An order contains of a number of items that the customer wants to purchase. These are the same items that are on
      the menu, of course, so we can re-use the item design. We need a couple of other properties. The barista needs to
      call the customer when the order is prepared, so we should add a <literal>customer</literal> property for this 
      purpose. We also like to include a <literal>total</literal> (with <literal>currency</literal>). One could argue 
      that this can be calculated from the items, but there may be complications like quantum discounts and whatnot that 
      we want to be prepared for. Finally, we need a <literal>status</literal> property to keep track of the various 
      state changes that we saw earlier.
    </para>
    <para>
      A payment could take many forms. We could go overboard and design a very flexible solution that will cater to
      any and all payment methods, but this book is about REST, not payments. Since RESTBucks is an online store, we'll
      simply assume a credit card payment. So we'll need the following properties: <literal>amount</literal>,
      <literal>currency</literal> <literal>cardholderName</literal>, <literal>cardNumber</literal>, 
      <literal>expiryMonth</literal>, <literal>expiryYear</literal>, and <literal>cardSecurityCode</literal>. 
      To be future-proof, we'll throw in a <literal>paymentMethod</literal> field as well, so that we can add different 
      payment methods later.
    </para>
    <para>
      The receipt should have <literal>date</literal> and <literal>time</literal> properties and show the 
      <literal>shop</literal> to be RESTBucks. It should also have a list of the purchased <literal>item</literal>s and 
      their <literal>price</literal>s, and a <literal>total</literal> price and <literal>currency</literal>. Finally, 
      it should have a <literal>paymentMethod</literal> so that customers can crosscheck the receipt with their credit 
      card statements.
    </para>
    <para>
      Here's a summary:
    </para>
    <informaltable>
      <thead>
        <tr>
          <th>Message</th>
          <th>Properties</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><literal>menu</literal></td>
          <td><literal>items</literal></td>
        </tr>
        <tr>
          <td><literal>item</literal></td>
          <td>
            <literal>name</literal>, <literal>size</literal>, <literal>milk</literal>, <literal>price</literal>, 
            <literal>currency</literal>
          </td>
        </tr>
        <tr>
          <td><literal>order</literal></td>
          <td>
            <literal>items</literal>, <literal>customer</literal>, <literal>total</literal>, 
            <literal>currency</literal>, <literal>status</literal>
          </td>
        </tr>
        <tr>
          <td><literal>payment</literal></td>
          <td>
            <literal>amount</literal>, <literal>currency</literal>, <literal>paymentMethod</literal>, 
            <literal>cardHolderName</literal>, <literal>cardNumber</literal>, <literal>expiryMonth</literal>, 
            <literal>expiryYear</literal>, <literal>cardSecurityCode</literal>
          </td>
        </tr>
        <tr>
          <td><literal>receipt</literal></td>
          <td>
            <literal>date</literal>, <literal>time</literal>, <literal>shop</literal>, <literal>items</literal>, 
            <literal>total</literal>, <literal>currency</literal>, <literal>paymentMethod</literal>
          </td>
        </tr>
      </tbody>
    </informaltable>
  </section>
  
  <section>
    <title>Assign Link Relations To Transitions</title>
    <para>
      A REST client follows transitions in the state diagram by discovering links in messages. This discovery
      process is made possible by <firstterm>link relations</firstterm>. Link relations decouple the client from the 
      URIs that the server uses, giving the server the freedom to change its URI structure at will without breaking any 
      clients. Link relations enable evolution of the service and are therefore an important part of any REST API.
    </para>
    <para>
      We should try to use existing link relations as much as possible. There is a registry of link relations 
      <citation>IanaLinks</citation> maintained by IANA, the same organization that also registers media types. 
      There won't be a registered link relation for every case, so sometimes you need to invent your own. But if you 
      can, reuse link relations, because it is just another thing that a client developer doesn't have to learn about 
      your service.
    </para>
    <para>
      Publicly registered link relations have a short English name, like <literal>self</literal> or 
      <literal>edit</literal>. The registry makes sure that they are globally unique. That is not the case for custom
      link relations, so they take the form of URIs. Note that these URIs don't have to resolve, so you don't need to
      have them point to a web page. However, that would be a good way to make them discoverable and provide a 
      convenient place to document them.
    </para>
    <para>
      Here are the link relations for our example:
    </para>
    <informaltable>
      <thead>
        <tr>
          <th>Transition</th>
          <th>Link Relation</th>
        </tr>
      </thead>
      <tbody>
				<tr>
					<td>Read menu</td>
					<td><literal>http://relations.restbucks.com/linkrel/menu</literal></td>
				</tr>
				<tr>
					<td>Order</td>
					<td><literal>http://relations.restbucks.com/linkrel/orders</literal></td>
				</tr>
				<tr>
					<td>Receive notification</td>
					<td><literal>self</literal></td>
				</tr>
				<tr>
					<td>Take order</td>
					<td><literal>edit</literal></td>
				</tr>
				<tr>
					<td>Abort</td>
					<td><literal>edit</literal></td>
				</tr>
				<tr>
					<td>Pay</td>
					<td><literal>payment</literal></td>
				</tr>
				<tr>
					<td>Take receipt</td>
					<td><literal>http://relations.restbucks.com/linkrel/receipt</literal></td>
				</tr>
      </tbody>
    </informaltable>
    <para>
      We can re-use a couple of standard link relations. 
      The <literal>self</literal> link relation refers to the object itself, so we can use it to refresh an order and 
      "get notified" when its <literal>status</literal> changes. It's good practice to provide a link of this type to 
      every object.
      The <literal>edit</literal> link relation refers to where the object can be edited. We can use this for the cases
      where we update the <literal>status</literal> property: Take order and Abort.
      The <literal>payment</literal> link relation refers to where payment is accepted, so it's perfect for the Pay
      transition. 
    </para>
    <para>
      The other transitions required custom link relations.
      To make it clear that the custom link relations are specific to the RESTBucks service, we'll prefix them with our 
      Internet domain. 
      If at all possible, link relations should be nouns that indicate the type of relationship that the target 
      resource has with the current resource.
      In our case, that is easy enough: menu, orders, and receipt.
    </para>
    <para>
       The alternative to defining custom link relations is to start a standardization process. We could have started
       an Internet Draft or similar document that defines reusable link relations. The <literal>receipt</literal> link 
       relation makes sense for pretty much every commerce API, and the <literal>menu</literal> and 
       <literal>order</literal> link relations are useful in broader food and drinks domain. If you're trying to be a 
       thought leader in your domain, then this is a good opportunity to demonstrate that ambition. 
    </para>
  </section>

  <section id="media-types">
    <title>Select Media Types To Serialize Messages</title>
    <para>
      When extending an existing design, you should stick with the already selected media type(s). For new APIs, you
      have to decide what media type(s) to use.
    </para>
    <para>
      There are different kinds of media types. <firstterm>Application-specific media types</firstterm> are designed for 
      a single application or service. For instance, <literal>application/vnd.github+json</literal> is the media type 
      used by the GitHub API <citation>GitHubApi</citation>. <firstterm>Domain-specific media types</firstterm> are 
      designed to represent problems in one particular domain. For instance, Scalable Vector Graphics (SVG, 
      <literal>image/svg+xml</literal>) <citation>SVG</citation> deals only with vector graphics. 
      <firstterm>General purpose media types</firstterm> can be used for any service in any domain. The best known 
      general purpose media type is of course HTML (<literal>text/html</literal>) <citation>HTML</citation>.
    </para>
    <para>
      Another way to categorize media types is by who defined them <citation>RichAmun13</citation>. 
      <firstterm>Fiat standards</firstterm> are informal descriptions of the way someone does something. They don't try 
      to convince other people to do things the same way. <firstterm>Personal standards</firstterm> do invite people
      to follow them, but they're still just one person's opinion. <firstterm>Corporate standards</firstterm> are
      are created by a single company or a consortium of companies to solve recurring problems. Finally, an
      <firstterm>open standard</firstterm> has gone through a process of design by committee and is blessed by some
      sort of standards body.
    </para>
    <para>
      Media types that are described by a standard are usually registered with the Internet Assigned Numbers Authority 
      (IANA) <citation>IANA</citation>. This makes them easy to discover. Registered media types are of the form
      type<literal>/</literal>sub-type, where the number of types is fixed. For REST APIs, most media types will fall
      within the <literal>application</literal> type. 
      The IANA registry is made up of several trees. The so-called vendor tree is for registering personal and corporate 
      standards, while the standards tree contains open standards. Media types in the vendor tree start the sub-type
      with <literal>vnd</literal>, as we'll see shortly.
    </para>
    <para>
      There is some correlation between these two dimensions. An application-specific media type will have little 
      chance of getting adopted as an open standard, for instance. However, SVG and HTML are both open standards, but 
      one is domain-specific while the other is general purpose.
    </para>
    <para>
      In general, it makes sense to select a general purpose media type defined as an open standard. This choice means
      you won't have to document anything; you can simply point to an existing specification. Chances are that there
      are existing tools and/or libraries available to work with the media type, so you can save yourself and your 
      clients some coding effort. You can also profit from a lot of thinking that went into the existing standard.
    </para>
    <para>
      The problem with a general purpose media type is, well, that it isn't specifically tailored to your needs. You 
      will have to find a way to express your particular domain in the media type. Remember from 
      <xref linkend="maturity"/> that semantic profiles can bridge that gap. If you're lucky enough to work in a domain
      for which such a semantic profile already exists, then you can re-use that. But even if you're not that lucky,
      you can still save yourself a lot of work by selecting a general purpose media type. You only have to describe
      your semantics, instead of the semantics plus the protocol plus the data format.  
    </para>
    <para>
      Most media types are derived from an existing base format like XML (e.g. SVG) or JSON (e.g. GitHub). The default
      these days is to use JSON-based media types, so if you don't have a strong reason to use something else, you 
      should go with JSON.
    </para>
    <para>
      Note that JSON itself, <literal>application/json</literal>, is not a hypermedia type, since JSON doesn’t define 
      links. You can, of course, use a convention on top of JSON, for instance that there should be a 
      <literal>links</literal> property with a certain structure to describes the links. The problem with this approach
      is that it's a fiat or at best personal standard, and we've already seen that open standards are better. 
      In the following sections we will take a look at some JSON-based media types that allow the inclusion of 
      hyperlinks.
    </para>
    <para>
      As of this writing, the jury is still out on which of the following media types is going to win out as the 
      <emphasis>de facto</emphasis> standard media type for REST APIs. If you pick one format now, chances are that
      you picked the wrong one, and will want to change it later. You can minimize the impact of such a change by
      being careful when implementing your service. We'll come back to that in <xref linkend="implementation"/>.
    </para>
    
    <section>
      <title>HAL</title>
    </section>
    <para>
      Since <literal>application/json</literal> has no provisions for linking, we can't use it as a hypermedia format.
      In other words, you can use JSON for REST maturity levels 0, 1, and 2, but not for levels 3 or 4 (see 
      <xref linkend="maturity"/>). To get to level 3, we need to add linking capabilities. 
    </para>
    <para>
      That's exactly what Hypermedia Application Language (HAL) provides <citation>HAL</citation>. HAL, or 
      <literal>application/hal+json</literal> is a JSON-based language that adds a <literal>_links</literal> property. 
      The underscore is an attempt to avoid naming conflicts, since JSON doesn't have the equivalent of XML namespaces. 
      Here's what a RESTBuck order could look like in HAL:
    </para>
    <programlisting>
			{ "_links": {
			    "self": { 
			      "href": "http://api.restbucks.com/order/1234/"
			    },
			    "curies": [{
			      "name": "relations",
			      "href": "http://relations.restbucks.com/"
			    }],
			    "relations:cancel": { 
			      "href": "http://api.restbucks.com/order/1234/"
			    },
			    "payment": {
			      "href": "http://api.restbucks.com/order/1234/payments/"
			    }
			    "edit": { 
			      "href": "http://api.restbucks.com/order/1234/"
			    }
			  },
			  "_embedded": {
			    "item": [{
			      "size": "tall",
			      "milk": "whole",
			      "drink": "caffe latte",
		        "price": 2.75,
		        "currency": "USD"
			    }]
			  },
			  "total": 2.75,
			  "currency": "USD",
			  "status": "unpaid"
			}
    </programlisting>
    <para>
      The value of the <literal>_links</literal> property is a JSON object where each property is a link relation
      (More on link relations below). The object itself must at least have an <literal>href</literal> property that 
      contains the URL of the linked to resource.
    </para>
    <para>
      HAL supports curies, which are ways to shorten URLs. For example, the <literal>relations</literal> curie above 
      shortens the URL for the <literal>cancel</literal> link relation. Curies are optional.
    </para>
    <para>
      There are pros and cons to using curies. They achive slightly shorter messages, which could translate to smaller
      transmission times. On the other hand, JSON is a textual format and therefore compresses very well, so it's
      doubtful that the effect of curies would be noticeable when you use compression. Curies make the JSON a bit easier 
      to read for humans, but a bit more difficult to parse for computer programs. Given that REST APIs are really meant
      for machine-to-machine communication, we advise not to use them. It puts an extra burden on your clients that we
      feel isn't worth the small benefit. 
    </para>
    <para>
      HAL only allows simple properties in the JSON object. But sometimes, that model doesn't fit your data. In the
      RESTBucks example, an order is made up of potentially more than one item. HAL uses the <literal>_embedded</literal>
      property to handle such sub-entities.
    </para>
    <para>
      Remember that a level 3 REST API must support both links and forms (see <xref linkend="maturity"/>). While HAL
      provides hyperlinking capabilities using the <literal>_links</literal> property, it doesn't have anything for
      handling forms. So with HAL you can only build level 3a APIs. Yet HAL is a big improvement over plain JSON, and 
      it is quite popular. For instance, it is used by default in Spring HATEOAS <citation>SpringHateaos</citation>.
      HAL's popularity no doubt is due to its simplicity.
    </para>
    <para>
      HAL is a registered in the open standards tree of IANA, but it hasn't reached the status of standard yet. At the
      point of writing, HAL is a Internet Draft (ID). Internet Drafts are the vehicle of the IETF standards body to
      propose new standards. Once an Internet Draft is vetted by reviewers, it may turn into a full standard, or RFC.
      HTTP is one example of an RFC.
    </para>
    
    <section>
      <title>Mason</title>
    </section>
    <para>
      The Mason <citation>Mason</citation> media type, <literal>application/vnd.mason+json</literal>, fills the gap that
      HAL leaves. Like HAL, Mason supports links (using the <literal>@links</literal> property), including curies (using 
      the <literal>@namespaces</literal> property). In addition, it supports forms using the <literal>@actions</literal> 
      property. Here's how a RESTBucks order could look like in Mason:
    </para>
    <programlisting>
			{ "@namespaces": {
			    "relations": {
			      "name": "http://relations.restbucks.com/"
			    }
			  },
			  "item": [{
			    "size": "tall",
			    "milk": "whole",
			    "drink": "caffe latte",
	        "price": 2.75,
	        "currency": "USD"
			  }],
			  "total": 2.75,
			  "currency": "USD",
			  "status": "unpaid",
			  "@links": {
			    "self": { 
			      "href": "http://api.restbucks.com/order/1234/"
			    }
			  },
			  "@actions": {
			    "relations:cancel": { 
			      "href": "http://restbucks.com/order/1234/",
			      "type": "void",
			      "method": "DELETE"
			    },
			    "payment": {
			      "href": "http://api.restbucks.com/order/1234/payments/",
			      "title": "Pay the order",
			      "type": "any",
			      "method": "POST",
			      "template": {
			        "payment": {
			          "amount": 2.75,
			          "currency": "USD",
			          "type": "creditcard",
			          "cardholderName": "",
			          "cardNumber": "",
			          "expiryMonth": "",
			          "expiryYear": ""
			        }
			      }
			    },
			    "edit": { 
			      "href": "http://api.restbucks.com/order/1234/",
			      "type": "any",
			      "method": "PATCH",
			      "template": {
			        "item": [{
			          "size": "tall",
			          "milk": "whole",
			          "drink": "caffee latte",
				        "price": 2.75,
				        "currency": "USD"
			        }],
			        "total": 2.75,
			        "currency": "USD",
			        "status": "unpaid"
			      }
			    }
			  }
			}
    </programlisting>
    <para>
      Mason allows for natural sub-objects, rather than HAL's <literal>_embedded</literal> property. But the main
      advantage of Mason over HAL is the <literal>@actions</literal> property that supports forms. Mason is thus
      suited to build REST APIs at level 3b. The <literal>method</literal> property allows specifying which HTTP
      method to use, so clients no longer have to hard-code that knowledge. This gives you the opportunity to switch
      from <literal>POST</literal> to <literal>PATCH</literal>, for instance, and not break existing clients.
    </para>
    <para>
      For HTTP methods that require input, the <literal>template</literal> property specifies what that input should
      look like. This makes it easy to translate the JSON message into an HTML form, or to dynamically build your 
      mobile UI.
    </para>
    <para>
      A peculiarity of the <literal>@actions</literal> is the <literal>type</literal> property, which can be 
      <literal>void</literal>, <literal>json</literal>, <literal>json-files</literal>, or <literal>any</literal>.
      One would have expected a media type there instead.
    </para>
    <para>
      As you can tell from the <literal>vnd.</literal> prefix in the sub-type, Mason is a personal standard. We're not
      aware of any efforts to move this to an open standard.
    </para>
    
    <section>
      <title>Siren</title>
    </section>
    <para>
      HAL and Mason use keywords starting with <literal>_</literal> or <literal>@</literal> so that they don't
      conflict with user-defined properties. Siren <citation>Siren</citation>, 
      or <literal>application/vnd.siren+json</literal>, does things a bit differently. It prescribes the structure of 
      the message, so that it's always clear what part is defined by Siren and what part is specific to the service.
      This has the benefit of clarity at the cost of a more deeply nested structure.
    </para>
    <programlisting>
			{ "class": [ "order" ],
			  "properties": [{
			    "total": 2.75,
			    "currency": "USD",
			    "status": "unpaid"
			  },
			  "entities": [{
			    "class": [ "item" ],
			    "rel": [ "http://relations.restbucks.com/item" ],
			    "properties": {
			      "size": "tall",
			      "milk": "whole",
			      "drink": "caffe latte",
		        "price": 2.75,
		        "currency": "USD"
			    }
			  }],
			  "actions": [{
			    "name": "http://relations.restbucks.com/cancel",
			    "title": "Cancel the order",
			    "method": "DELETE",
			    "href": "http://api.restbucks.com/order/1234/"
			  }, {
			    "name": "payment",
			    "title": "Pay the order",
			    "href": "http://api.restbucks.com/orders/1234/payments/",
			    "type": "application/vnd.siren+json",
			    "method": "POST",
			    "fields": [{
			      "name": "amount",
			      "type": "number",
			      "value": 2.75
			    }, {
			      "name": "currency",
			      "type": "text",
			      "value": "USD"
			    }, {
			      "name": "type",
			      "type": "text"
			      "value": "creditcard"
			    }, {
			      "name": "cardholderName",
			      "type": "text"
			    }, {
			      "name": "cardNumber",
			      "type": "text"
			    }, {
			      "name": "expiryMonth",
			      "type": "number"
			    }, {
			      "name": "expiryYear",
			      "type": "number"
			    }],
			  }, {
			    "name": "edit",
			    "href": "http://api.restbucks.com/order/1234/",
			    "method": "PATCH",
			    "type": "application/vnd.siren.json"
          "fields": [{
            "name": "status",
            "type": "text",
            "value": "unpaid"
          }]
			  }],
			  "links": [{ 
			    "rel": "self",
			    "href": "http://api.restbucks.com/order/1234/"
			  }]
			}
    </programlisting>
    <para>
      Siren uses the <literal>properties</literal> property to capture the properties of the object being transmitted.
      The <literal>entities</literal> property is similar to the <literal>_embedded</literal> property of HAL.
      Siren uses the <literal>actions</literal> property much like Mason uses <literal>@actions</literal>, but it
      adds HTML types to the fields. For clients that use HTML, this allows for a seamless translation into forms.
    </para>
    <para>
      Siren and Mason are very similar. The big difference is that Siren uses the <literal>class</literal> property
      much like HTML does for semantic descriptors. In combination with semantic profiles, this feature makes it 
      possible to use Siren in a level 4 API, which is not possible with Mason.
    </para>
    
    <section>
      <title>UBER</title>
    </section>
    <para>
      Uniform Basis for Exchanging Representations (UBER) <citation>UBER</citation> is another media type that allows 
      level 4 APIs. This format is optimized for the number of design elements used. While that keeps the specification
      fairly short, it does make the messages a bit more difficult to read.
    </para>
    <programlisting>
			{ "uber": {
			  "version": "1.0",
			  "data": [{
			    "rel": [ "self" ],
			    "url": "http://api.restbucks.com/order/1234/"
			  }, {
			    "id": "order",
			    "data": [{
			      "name": "item",
			      "data": [{
			        "name": "milk",
			        "value": "whole"
			      }, {
			        "name": "size", 
			        "value": "tall",
			      }, {
			        "name": "drink",
			        "value": "caffe latte"
			      }, {
			        "name": "price",
			        "value": 2.75
			      }, {
			        "name": "currency",
			        "value": "USD"
			      }]
			    }, {
			      "name": "total",
			      "value": 2.75
			    }, {
			      "name": "currency",
			      "value": "USD"
			    }, {
			      "name": "status",
			      "value": "unpaid"
			    }]
			  }, {
			    "rel": "http://relations.restbucks.com/cancel",
			    "url": "http://api.restbucks.com/order/1234/",
			    "action": "remove"
			  }, {
			    "rel": "payment",
			    "url": "http://api.restbucks.com/order/1234/payments/",
			    "sending": "application/vnd.uber+json",
			    "action": "append",
			    "data": [{
			      "name": "amount",
			      "value": 2.75
			    }, {
			      "name": "currency",
			      "value": "USD"
			    }, {
			      "name": "type",
            "value": "creditcard"
			    }, {
			      "name": "cardholderName",
			    }, {
			      "name": "cardNumber",
			    }, {
			      "name": "expiryMonth",
			    }, {
			      "name": "expiryYear",
			    }],
			  }, {
			    "rel": "edit",
			    "url": "http://api.restbucks.com/order/1234/",
			    "action": "replace",
			    "sending": "application/vnd.uber.json"
			  }]
			}
    </programlisting>
    <para>
      UBER differs from Mason and Siren in that it doesn't make a distinction between links (read-only operations) and 
      actions (write operations). All HTTP methods are treated the same, and they are also treated the same as the 
      properties of an object. Everything is data.
    </para>
    <para>
      There is nothing in the REST architectural style that ties it to HTTP, although that is the most commonly used
      protocol for transmitting the messages. UBER acknowledges this fact by abstracting away the HTTP methods. Instead
      of using <literal>POST</literal>, one would use <literal>append</literal>, for instance. When you use a protocol
      like CoAP <citation>CoAP</citation> instead of HTTP, that may make sense, but the vast majority of APIs don't do
      that.
    </para>
    <para>
      UBER also makes a distinction between the media types used in the request and response, using the 
      <literal>sending</literal> and <literal>accepting</literal> properties. Siren only allows one value in its
      <literal>type</literal> property.
    </para>
    
    <section>
      <title>Hydra</title>
    </section>
    <para>
      JSON-LD <citation>JsonLd</citation> is an open standard maintained by the W3C. Hydra <citation>Hydra</citation>
      is an corporate standard maintained by the Hydra W3C Community Group that builds on JSON-LD.
    </para>
    <para>
      JSON-LD is the JSON representation of the Linked Data concept. <firstterm>Linked Data</firstterm> is a method of 
      publishing structured data so that it can be interlinked and queried based on semantics. JSON-LD provides a 
      JSON-based media type that can define any semantics, and Hydra adds the Hydra Core Vocabulary that defines 
      semantics specific to REST APIs. Hydra is thus an alternative for ALPS that is more in line with the Semantic Web
      effort <citation>SemWeb</citation>.
    </para>
    <!-- TODO: Turn the below into Hydra -->
    <programlisting>
      { "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@type": 
        },
        "@id": "http://api.restbucks.com/orders/1234/"
        "item": [{
          "size": "tall",
          "milk": "whole",
          "drink": "caffe latte",
          "price": 2.75,
          "currency": "USD"
        }],
        "total": 2.75,
        "currency": "USD",
        "status": "unpaid",
        "@links": {
          "self": { 
            "href": "http://api.restbucks.com/order/1234/"
          }
        },
        "@actions": {
          "relations:cancel": { 
            "href": "http://restbucks.com/order/1234/",
            "type": "void",
            "method": "DELETE"
          },
          "payment": {
            "href": "http://api.restbucks.com/order/1234/payments/",
            "title": "Pay the order",
            "type": "any",
            "method": "POST",
            "template": {
              "payment": {
                "amount": 2.75,
                "currency": "USD",
                "type": "creditcard",
                "cardholderName": "",
                "cardNumber": "",
                "expiryMonth": "",
                "expiryYear": ""
              }
            }
          },
          "edit": { 
            "href": "http://api.restbucks.com/order/1234/",
            "type": "any",
            "method": "PATCH",
            "template": {
              "item": [{
                "size": "tall",
                "milk": "whole",
                "drink": "caffee latte",
                "price": 2.75,
                "currency": "USD"
              }],
              "total": 2.75,
              "currency": "USD",
              "status": "unpaid"
            }
          }
        }
      }
    </programlisting>
    <para>
      Hydra uses keywords, like HAL and Mason, to distinguish pre-defined JSON keys from arbitrary data using the 
      <literal>@</literal> symbol. Hydra also supports curies, which they refer to as <firstterm>compact 
      IRI</firstterm>s.
    </para>
    
    <section>
      <title>Making a Choice</title>
    </section>
    <para>
      The previous sections presented a bunch of media types and listed their pros and cons. At this point in time, 
      there is no no media type that is an open standard, supports level 4 APIs, and is widely accepted and implemented.
    </para>
    <para>
      So which one should you pick for your API? The answer depends on how comfortable you are building on a personal 
      standard versus an open standard. It also depends on how far up the maturity ladder you want to be. And it even
      depends on taste.
    </para>
    <para>
      For RESTBucks, we want a media type that supports level 4 APIs. At the moment of writing, that limits our choice
      to Siren, UBER, and Hydra. We don't like the lack of readability of UBER that stems from treating data and
      operations the same. So that leaves Siren and Hydra.
    </para>
    <para>
      Both Siren and JSON-LD have libraries for working with them in a variety of languages.
      Hydra is an corporate standard based on JSON-LD, which is an open standard, so one might argue that Hydra is 
      a bit more of an open standard than Siren.
      The use of JSON-LD in Hydra also means that we can connect to the Semantic Web infrastructure if we want to, but 
      at the same time we're not forced to.
      Hydra is tied to JSON-LD for semantic profiles, while Siren can use ALPS and probably also JSON-LD.
    </para>
    <para>
      Based on these considerations, we think it's a close tie between Siren and Hydra. Hydra seems more powerful, but
      less mature as a specification than Siren. 
      Since we can pick only one, we're going with Hydra, as we think this specification will ride on the wave of
      JSON-LD. We understand that this choice may turn out to be wrong and we may want to change our minds in the 
      future, so we will be careful to minimize the impact of such a change.
    </para>
  </section>

  <section id="semantics">
    <title>Document Semantics</title>
    <para>
      In order to help developers build clients that work against your API, you will most likely want to add some
      documentation that explains certain more subtle points. Examples are very helpful to illustrate those points,
      as we saw in <xref linkend="examples"/>.
      You may also add instructions for server developers that will implement the API, like what caching to use.
    </para>
    <para>
      There are at least two different dimensions to documenting semantics. First, you have to convey to someone else
      what something in a message means. Second, you have to make that more concrete by giving details such as the
      data type, the format, the length, the minimum and maximum allowable values, etc. 
    </para>
    <para>
      As much as we sometimes like to think we're unique, the fact is that we rarely are. Sure, RESTbucks is unique in
      that it sells coffee <emphasis>online</emphasis>. But it's also not unique, because it sells 
      <emphasis>coffee</emphasis>. It therefore makes sense to see how we are different from others, and more 
      important for the present discussion, how we are the same.
    </para>
    <para>
      There are a number of places where people have defined semantics for various things. There is a collection of
      schemas at <literal>schema.org</literal> <citation>SchemaOrg</citation>, for instance, for naming people, 
      organizations, places, works of art, multimedia, health and medical types, and business.
      Other examples where you can find interesting schemas are the Dublin Core Metadata Initiative 
      <citation>DublinCore</citation> and Microformats <citation>MicroFormats</citation>.
      You can search many of these from the Linked Open Vocabularies website <citation>LOV</citation>.
    </para>
    <para>
      Let's see how much of the data in our messages we can describe using existing vocabularies:
    </para>
    <informaltable>
	    <thead>
	      <tr>
	        <th>Data item</th>
	        <th>Defined By</th>
	        <th>Definition Maintained By</th>
	      </tr>
	    </thead>
	    <tbody>
        <tr>
          <td><literal>cardHolderName</literal></td>
          <td>https://w3id.org/creditcard/v1/name</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>cardNumber</literal></td>
          <td>https://w3id.org/creditcard/v1/number</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>cardSecurityCode</literal></td>
          <td>https://w3id.org/creditcard/v1/verificationCode</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>currency</literal></td>
          <td>http://schema.org/priceCurrency</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>customer</literal></td>
          <td>http://schema.org/customer</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>date</literal></td>
          <td>http://schema.org/orderDate</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>expiryMonth</literal></td>
          <td>https://w3id.org/creditcard/v1/expiryMonth</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>expiryYear</literal></td>
          <td>https://w3id.org/creditcard/v1/expiryYear</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>item</literal></td>
          <td>http://schema.org/orderedItem</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>menu</literal></td>
          <td>http://schema.org/menu</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>milk</literal></td>
          <td>http://vocab.restbucks.com/milk</td>
          <td>RESTBucks</td>
        </tr>
        <tr>
          <td><literal>name</literal></td>
          <td>http://schema.org/name</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>order</literal></td>
          <td>http://schema.org/Order</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>payment</literal></td>
          <td>http://reference.data.gov.uk/def/payment#payment</td>
          <td>UK Government</td>
        </tr>
        <tr>
          <td><literal>paymentMethod</literal></td>
          <td>http://schema.org/paymentAccepted</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>price</literal>, <literal>amount</literal></td>
          <td>http://schema.org/price</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>receipt</literal></td>
          <td>http://purl.org/NET/atpir-cw#TicketReceipt</td>
          <td></td>
        </tr>
        <tr>
          <td><literal>shop</literal></td>
          <td>http://schema.org/brand</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>size</literal></td>
          <td>http://schema.org/servingSize</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>status</literal></td>
          <td>http://schema.org/orderStatus</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>time</literal></td>
          <td>https://schema.org/Time</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>total</literal></td>
          <td>http://schema.org/totalPrice</td>
          <td>schema.org</td>
        </tr>
	    </tbody>
    </informaltable>
    <para>
      We only need to define one data item ourselves; all the others were already defined. Although it took us a bit 
      of time to find all of these, it was well worth it. Existing clients that already understand these vocabularies
      will have a good chance of being able to work with our service. Over time, we can expect the various vocabularies
      to cover an ever wider spectrum of services, so that you won't need to define anything yourself anymore.
    </para>
  </section>
  
  <section>
    <title>Putting It All Together</title>
    <para>
      TODO: Show all the HTTP interactions.
    </para>
  </section>
  
  <section>
    <title>Summary</title>
    <para>
      TODO:
    </para>
  </section>
</chapter>
