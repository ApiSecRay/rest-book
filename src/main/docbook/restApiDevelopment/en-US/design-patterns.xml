<chapter id="patterns">
  <title>Design Patterns</title>
  <para>
    The previous chapter showed how to design a REST API. In this process, there are a lot of decisions to be made.
    Fortunately, many of those decisions are easier made by applying certain design patterns.
  </para>
  <blockquote>
    <attribution><citation>AIS+77</citation></attribution>
    <para>
	    A <firstterm>design pattern</firstterm> describes a problem which occurs over and over again in our environment, 
	    and then describes the core of the solution to that problem, in such a way that you can use this solution a 
	    millions times over, without ever doing it the same way twice.
    </para>
  </blockquote>
  <para>
    This chapter lists some patterns that we have found useful in designing REST APIs. Each pattern description follows
    a common structure. It starts with briefly explaining the intent of the pattern, followed by a longer 
    description of the motivation for the pattern and the situations in which it is applicable. The structure depicts 
    the essence of the interaction between client and server. The implementation section then gives advice on what to
    do and what not to do to implement the pattern in your API and what variations are possible. An example clarifies 
    the basic pattern. Finally, we show how the pattern relates to other patterns.
  </para>
  
  <section id="home">
    <title>Home</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Provide a single location for clients to start the URI discovery process and for servers to add functionality.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Clients of a REST API follow the flow of <xref linkend="client-flow"/>. They always start by retrieving a 
        representation of the resource identified by the billboard URI. From there, they can discover other URIs
        using link relations. When the resource identified by the billboard URI contains nothing but high-level
        functions, it enables adding new functions without breaking existing clients. 
      </para>
      <para>
        Every REST API should have a billboard URI, and every billboard URI should identify a home resource. There is
        no drawback to this approach.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-home.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        There is a special media type for home documents <citation>Home Document</citation>. However, since a home
        document by definition contains nothing more than links, any hypermedia type will do. We therefore suggest
        to use the same media type that the API uses for other resources.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <programlisting>GET / HTTP/1.1
Host: api.restbucks.com
Accept: application/ld+json</programlisting>
      <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "http://api.restbucks.com/",
  "@type": "CafeOrCoffeeShop",
  "menu": "/menu/"
}</programlisting>
      <para>
        The response is typed to be a coffee shop, but other than that, it contains nothing but links. The 
        <literal>@id</literal> notation of JSON-LD is equivalent to a link with the <literal>self</literal> link
        relation, while the <literal>menu</literal> property can be understood from the context to be a link to the
        menu. If we were later to add non-food items, say coffee mugs, we could add a new link here for clients to
        discover.
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        The links in the home document usually point to collections (see <xref linkend="collection"/>).
      </para>
    </simplesect>
  </section>
  
  <section id="collection">
    <title>Collection</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Make a group of similar resources accessible as a resource of its own.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Collections allow finding members in a group of similar resources and adding new members to the group.
        It's very rare for an API not to have a group of similar resources, so virtually all REST APIs use collections.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-collection.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        There are specialized media types for collections, like Atom <citation>Atom</citation> and Collection+JSON 
        <citation>Cj</citation>.
        Most general purpose media types also have provisions for dealing with collections as well. We advise to select 
        a general purpose media type and use its collection features rather than burdening the client with multiple 
        media types.
      </para>
      <para>
        Collections can get very big. To save bandwidth, it may be a good idea to turn the collection into a paged one.
        <firstterm>Paged collections</firstterm> serve their members in chunks of a particular size called 
        <firstterm>pages</firstterm>. 
        Paged collections use the <literal>first</literal>, <literal>next</literal>, <literal>prev</literal>, and 
        <literal>last</literal> standard link relations to navigate between pages <citation>IANA Registry of Link 
        Relation Types</citation>. 
        The size of the pages and which page to retrieve are usually specified as query parameters.
        We'll talk more about paging in <xref linkend="paging"/>.
      </para>
      <para>
        Another way to limit bandwidth is to use filters. A <firstterm>filter</firstterm> is a search condition,
        usually provided in one or more query parameters, that limits which members of the collection are returned. 
        Filters range from simple name-value pairs to complex search languages.
      </para>
      <para>
        The OpenSearch specification is a corporate standard backed by Amazon, Microsoft, IBM, and others, that defines 
        query parameters for paging and filtering <citation>OpenSearch</citation>. Although this isn't an open
        standard and it isn't used by major search providers Google and Yahoo!, we think that using it is better than 
        inventing your own query parameters.
      </para>
      <para>
        Sometimes it is useful to include a representation of the members in the representation of the collection and
        sometimes you just want to point to the members. It's usually hard to predict what the client wants in a 
        particular situation, so it may make sense to use yet another query parameter to indicate whether to inline
        the members' representations.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <programlisting>GET /orders/ HTTP/1.1
Host: api.restbuck.com
Accept: application/ld+json</programlisting>
      <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld.json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "http://api.restbucks.com/orders/"
  "member": [ {
    "@id": "123/",
  }, {
    "@id": "234/",
  }, {
    "@id": "345/",
  } ]
}</programlisting>
      <programlisting>GET /orders/123/ HTTP/1.1
Host: api.restbuck.com
Accept: application/ld+json</programlisting>
      <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld.json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "http://api.restbucks.com/orders/123",
  <lineannotation>... Properties and links ...</lineannotation>
}</programlisting>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        Members are usually added to a collection using the Create pattern. See <xref linkend="create"/>
      </para>
    </simplesect>
  </section>
  
  <section id="create">
    <title>Create</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Create a new resource.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Some APIs are read-only, with the server offering a particular data set that is completely under its control.
        Most APIs, however, allow clients to add information. This can be in the form of primary information, like 
        books, or secondary information, like book reviews.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-create.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        Adding new resources is not a safe or idempotent operation (see the sidebar "<xref linkend="http-methods"/>"
        in <xref linkend="maturity"/>), so it should be implemented using the HTTP <literal>POST</literal> method.
        The semantics of <literal>POST</literal> are much less constrained than those of the other HTTP methods, which
        means one can use <literal>POST</literal> for virtually anything. We recommend to reserve the use of 
        <literal>POST</literal> as much as possible to the Create pattern.
      </para>
      <para>
        The response to a Create request should always have the <literal>201 Created</literal> status code and use the 
        <literal>Location</literal> header to point to the created resource. Additionally, we recommend that the
        reponse also includes the representation of the created resource. There may be information in there that the
        server added, like links, or input that the server rejeced. It makes sense to provide that feedback and save 
        the client a roundtrip.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <programlisting>POST /orders/ HTTP/1.1
Host: api.restbuck.com
Accept: application/ld+json
Content-Type: application/ld+json

{ "items": {
		"member": [ {
			"name": "caffe latte",
			"size": "tall",
			"milk": "whole"
		} ]
  },
	"customer": "Chrissy"
}</programlisting>
      <programlisting>HTTP/1.1 201 Created
Location: http://api.restbucks.com/orders/1234/
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "http://api.restbucks.com/orders/1234/",
	"@type": "Order",
	"items": {
		member: [ {
			"name": "caffe latte",
			"size": "tall",
			"milk": "whole",
			"price": 2.75,
			"currency": "USD"
		} ]
	},
	"total": 2.75,
	"currency": "USD",
	"customer": "Chrissy",
	"hydra:operation": [ {
	  <lineannotation>... Operations ...</lineannotation>
	} ]
}</programlisting>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        The Create pattern is often combined with the Collection pattern (see <xref linkend="collection"/>) to add
        members to a collection.
      </para>
      <para>
        Sometimes the creation process can take a long time. In that case, you may consider using the Asynchronous 
        pattern (see <xref linkend="async"/>) and return <literal>202 Accepted</literal> rather than <literal>201
        Created</literal>.
      </para>
    </simplesect>
  </section>
  
  <section id="async">
    <title>Asynchronous</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Allow the server to delay the response to a request.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Communication over HTTP is synchronous, meaning that the client sends a request and waits for the server to
        respond. Sometimes the server takes a long time to respond, however, and we may not want to wait that long. 
        Waiting keeps the HTTP connection open on the server side and there is usually a limited pool of connections. 
        Once this pool is depleted, new requests are blocked and throughput suffers.
      </para>
      <para>
        Another reason for not wanting to wait is to let the client move on with other useful work while the server 
        completes the request "in the background". This could also be achieved using threads on the client, but that 
        makes the client more complicated.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-async.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        The server should return the <literal>202 Accepted</literal> status to indicate that it has understood and
        accepted the request, but is not done processing it <citation>HTTP</citation>.
        The response should point to a place where the client can find out later whether the process has completed. 
        The <literal>Location</literal> header is one mechanism for communicating that location; a hyperlink in the 
        response body is another. We recommend using both so the client can process it in the most convenient way.
      </para>
      <para>
        If the server has a decent estimate of how long it will take to complete the process, it may use the
        <literal>Retry-After</literal> header to communicate that to the client <citation>HTTP</citation>.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
        <para>
          Let's assume that processing a credit card payment goes through an external payment service that may take a
          while.
        </para>
        <programlisting>POST /orders/1234/payments/ HTTP/1.1
Accept: application/ld+json
Content-Type: application/ld.json

{ "amount": 2.75,
  "currency": "USD",
  "paymentMethod": "creditcard",
  "cardholderName": "C.C. Conway",
  "cardNumber": "5525366617069778", 
  "expiryMonth": "06",
  "expiryYear": "2019",
  "cardSecurityCode": "836"
}</programlisting>
        <programlisting>HTTP/1.1 202 Accepted
Location: http://api.restbucks.com/orders/1234/payments/1/
Content-Type: application/ld+json
Retry-After: 20
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/payments/1/",
  "amount": 2.75,
  "currency": "USD",
  "paymentMethod": "creditcard",
  "cardholderName": "C.C. Conway",
  "cardNumber": "5525366617069778", 
  "expiryMonth": "06",
  "expiryYear": "2019",
  "cardSecurityCode": "836"
}</programlisting>
      <para>
        The server knows from experience that it takes about 20 seconds to process the credit card, and it doesn't
        want to keep the connection with the client open that long. So it responds with a representation of the
        submitted payment and a <literal>Retry-After</literal> header. After a while, the client tries again:
      </para>
      <programlisting>GET /orders/1234/payments/1/ HTTP/1.1
Host: api.restbucks.com
Accept: application/ld+json</programlisting>
      <programlisting>HTTP/1.1 303 See Other
Location: http://api.restbucks.com/orders/1234/receipt/      
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/receipt/"
}</programlisting>
      <para>
        In this example all went well, and the payment is no longer needed. The client is automatically redirected to 
        the receipt for the payment.
      </para>
      <para>
        Had the credit card processing failed, the response would have contained a representation of the payment,
        including some additional information about the failure. The client could then update the payment in an attempt 
        to correct the problem.
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        Sometimes the client isn't really interested in the outcome of the server process, and it will continue with
        its own work. Most of the times, however, the client will want to synchronize with the server and inspect the
        outcome. It can use the Polling (see <xref linkend="polling"/>) and Notification patterns (see 
        <xref linkend="notifications"/>) for that purpose.
      </para>
      <para>
        Asynchronous communication is sometimes part of a workflow (see <xref linkend="workflow"/>), often as the
        last step. Asynchronous communication may also be used in the Lifecycle pattern (see 
        <xref linkend="lifecycle"/>).
      </para>
    </simplesect>
  </section>
  
  <section id="polling">
    <title>Polling</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Repeatedly request a representation of a resource until it changes state.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Sometimes a client needs to wait for the server to complete a task before it can move on with its own work, for
        instance because it needs to process the output of the server task or because the server adds a link to a newly
        created resource that the client must interact with.
        One way of implementing the waiting is by having the client repeatedly check whether the server has finished.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-polling.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        Polling a resource is simply repeatedly refreshing it. The refresh operation is usually implemented using the
        <literal>self</literal> link relation, which is one reason why you should always identify the resource when
        sending a representation.
      </para>
      <para>
        If the server takes a long time to finish the task that the client is waiting for, then the client may end up
        sending many refresh requests. The server has to process all of those, which slows it down and may cause the
        task to take longer to finish. To prevent this downward spiral, the server should tell the client how long 
        to wait using the <literal>Retry-After</literal> header <citation>HTTP</citation>. If possible, the server 
        should provide a good estimate of the wait time so that the client neither waits too short nor too long.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <programlisting>GET /orders/1234/serving/ HTTP/1.1
Host: api.restbucks.com
Accept: application/ld+json</programlisting>
      <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"
Retry-After: 30

{ "@id": "/orders/1234/serving",
}</programlisting>
      <para>
        The client waits a while (preferrably the 30 seconds that the server indicates), and then tries again:
      </para>
      <programlisting>GET /orders/1234/serving/ HTTP/1.1
Host: api.restbucks.com
Accept: application/ld+json</programlisting>
      <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/serving",
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/serving/",
    "@type": "TakeAction",
    "hydra:httpMethod": "DELETE"
  } ]
}</programlisting>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        Polling is one solution to the synchronization problem between client and server. The other is to use the 
        Notification pattern (see <xref linkend="notifications"/>).
      </para>
      <para>
        Synchronization between client and server occurs in workflows (see <xref linkend="workflow"/>), in processors
        (see <xref linkend="processor"/>), and after asynchronous operations (see <xref linkend="async"/>).
      </para>
      <para>
        Polling clients may use conditional <literal>GET</literal> requests to reduce network traffic, as explained
        in <xref linkend="concurrency"/> and <xref linkend="caching"/>.
      </para>
    </simplesect>
  </section>
  
  <section id="notifications">
    <title>Notification</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Wait for the server to inform the client of an event.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Sometimes a client needs to wait for the server to complete a task before it can move on with its own work, for
        instance because it needs to process the output of the server task or because the server adds a link to a newly
        created resource that the client must interact with.
        One way of implementing the waiting is by having the server notify the client when it has finished.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-notification.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        The usual pattern of communication in REST APIs is for the client to issue a request and the server to respond
        to that. A notification reverses the client and server roles, since the "server" is now the initiator. This can 
        only work if the server knows where to reach the client, which isn't usually the case. So this pattern places a 
        higher demand on the client than normal: it must be able to accept incoming requests.
      </para>
      <para>
        The client must still initiate the interaction. It sends the server a request to receive a notification. This
        request must contain the address of the client, so that the server can send the client the notification request
        later. The server must keep this state information until it has notified the client, which violates the 
        stateless constraint (see <xref linkend="rest"/>).
      </para>
      <para>
        There are alternatives to using HTTP for implementing notifications. For instance, communication could involve
        a service bus, where the client subscribes to an event that the server later publishes. Such non-HTTP solutions
        are out of scope of this book; you can find an overview in <citation>EIP</citation>.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <para>
        Here the client provides a URI where the server can call back to in the <literal>notificationUrl</literal>
        property when it starts the long running action:
      </para>
      <programlisting>POST /orders/1234/payments/ HTTP/1.1
Accept: application/ld+json
Content-Type: application/ld.json

{ "amount": 2.75,
	"currency": "USD",
	"paymentMethod": "creditcard",
	"cardholderName": "C.C. Conway",
	"cardNumber": "5525366617069778",
	"expiryMonth": "06",
	"expiryYear": "2019",
	"cardSecurityCode": "836",
	"notificationUrl": "http://client.com/served/"
}</programlisting>
      <programlisting>HTTP/1.1 201 Created
Location: http://api.restbucks.com/orders/1234/receipt/
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context";
    type="application/ld+json"

{ "@id": "/orders/1234/receipt/",
	"dateTime": "2015-03-16T19:58:00+01:00",
	"shop": "RESTBucks",
	"items": {
		member: [ {
			"name": "caffe latte",
			"size": "tall",
			"milk": "whole",
			"price": 2.75,
			"currency": "USD"
		} ]
	},
	"total": 2.75,
	"currency": "USD",
	"paymentMethod": "creditcard",
	"serving": "/orders/1234/serving/"
}</programlisting>
      <para>
        The client can do something else or simply wait. After some time, the server is done preparing the serving and
        calls back into the client:
      </para>
      <programlisting>POST /served/ HTTP/1.1
Host: client.com
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context";
    type="application/ld+json"

{ "@id": "/orders/1234/serving",
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/serving/",
    "@type": "TakeAction",
    "hydra:httpMethod": "DELETE"
  } ]
}</programlisting>
      <programlisting>HTTP/1.1 204 No Content</programlisting>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        Notifications are one solution to the synchronization problem between client and server. The other is to use 
        the Polling pattern (see <xref linkend="polling"/>).
      </para>
      <para>
        Synchronization between client and server occurs in workflows (see <xref linkend="workflow"/>), in processors
        (see <xref linkend="processor"/>), and after asynchronous operations (see <xref linkend="async"/>).
      </para>
    </simplesect>
  </section>
  
  <section id="workflow">
    <title>Workflow</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Move through various steps in a complex process.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        There are many situations in which the server needs to guide the client through a multi-step process, like 
        buying something from an online store. You may be able to cram such a process in a single request/response, but
        that often feels unnatural from the client's perspective (see <xref linkend="analysis"/>) and may lead to 
        brittle designs. It's often better to design a flow of multiple requests that are connected via links. 
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-workflow.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        If possible, group the resources involved in all the steps under one <firstterm>grouping resource</firstterm>
        that represents the entire workflow. In the example of the online store, that resource would be the order or 
        shopping cart.
        Grouping resources this way clearly expresses the intent and also makes it easy to cancel the whole process by 
        deleting the grouping resource.
      </para>
      <para>
        Sometimes the grouping resource is a temporary resource that will be removed after the client has completed the
        workflow. At this point, the lines between server and client state start to fade a bit. To stay within the
        stateless constraint (see <xref linkend="rest"/>), make sure that the resources that the server maintains are
        interesting to other parties than just the client that created them.
      </para>
      <para>
        If the grouping resource is interesting to other parties, like an order that needs to be fulfilled by some 
        backoffice process, then you may still want to remove it after the workflow is complete.
        Alternatively, you could move it to some other location to indicate its changed nature. For instance, a 
        completed order could be moved from <literal>/orders/</literal> to <literal>/sales/2015/Q1/</literal> after it 
        had been fulfilled.
      </para>
      <para>
        Note that moving a resource means the that resource's URI is no longer cool (see the sidebar 
        "<xref linkend="uris"/>" in <xref linkend="name-resources"/>), so make sure the client wouldn't need access to 
        it anymore. If there is any chance that the client may still need to access the resource, then consider keeping 
        the URI around and responding with a 3xx status code <citation>HTTP</citation> and a 
        <literal>Location</literal> header that tells the client where the resource moved to.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <para>
        See <xref linkend="http-happy-path"/> for an example of ordering a drink with RESTBucks.
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        The grouping resource is usually added to a collection (see <xref linkend="collection"/>) using the Create 
        pattern (see <xref linkend="create"/>). The collection is often reachable from the Home resource (see
        <xref linkend="home"/>).
      </para>
      <para>
        When multiple parties are involved in the various steps, then the lifecycle pattern
        (see <xref linkend="lifecycle"/>) may apply. For logging or reporting purposes, you may want to correlate the
        requests that make up the workflow (see <xref linkend="correlation"/>).
      </para>
      <para>
        An alternative to using a grouping resource is to group all the logical requests into a single HTTP request
        (see <xref linkend="batch"/>). 
      </para>
    </simplesect>
  </section>
  
  <section id="lifecycle">
    <title>Lifecycle</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Move a resource through a sequence of stages.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Sometimes multiple parties need to cooperate on a single resource. For instance a customer, cashier, and 
        barista work on the same order in RESTBucks. Each party handles part of the process and hands off to another 
        party. The hand-offs are coordinated using the state of the resource.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-lifecycle.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        The state of the resource determines what can be done with it. In RESTful systems, this is usually indicated by 
        what links are available to operate on the resource.
      </para>
      <para>
        An alternative is to make the state explicit using a property. Each client watches the state property to see if 
        it's their turn to operate on it. Use this approach only if you really can't distinguish the various states by
        the presence or absence of links.
      </para>
      <para>
        This pattern is one place where it proves to be especially tempting for some people to put the possible actions 
        on the resource in URIs. For instance, a task in a workflow may offer an operation for a user to acquire it and
        sometimes you'll see this modeled using a URI like <literal>/tasks/1/acquire/</literal>. That is not the
        resource oriented approach that the REST architectural style prescribes. A more RESTful approach would be to
        send a <literal>PATCH</literal> request to <literal>/tasks/1/</literal> to update the 
        <literal>assignedTo</literal> property.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <para>
        A RESTBucks customer pays for a drink she ordered:
        <programlisting>POST /orders/1234/payments/ HTTP/1.1
Accept: application/ld+json
Content-Type: application/ld.json

{ "amount": 2.75,
  "currency": "USD",
  "paymentMethod": "creditcard",
  "cardholderName": "C.C. Conway",
  "cardNumber": "5525366617069778", 
  "expiryMonth": "06",
  "expiryYear": "2019",
  "cardSecurityCode": "836"
}</programlisting>
          <programlisting>HTTP/1.1 303 See Other
Location: http://api.restbucks.com/orders/1234/receipt/
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/receipt/",
}</programlisting>
        The barista picks up the paid order and prepares it:
        <programlisting>GET /orders/?status=paid HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/?status=paid",
  "@type": "hydra:Collection",
  "member": [ {
    "@id": "/orders/1234/"
  } ]
}</programlisting>
        <programlisting>GET /orders/1234/ HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/"
  "@type": "Order",
  "items": {
    member: [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole",
    } ]
  },
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/serving/",
    "@type": [ "hydra:ReplaceResourceOperation", "CookAction" ],
    "hydra:httpMethod": "PUT"
  } ]
}</programlisting>
        The barista gets a different representation of the order than the customer based on his identity. We'll talk
        more about that in <xref linkend="security"/>. The barista doesn't need any details about the cost, so those
        are not included. There is an operation to notify the server that the serving is prepared, defined by 
        <literal>http://schema.org/CookAction</literal>. The barista calls that once he's done:
        <programlisting>PUT /orders/1234/serving/ HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 204 No Content</programlisting>
        In the meantime, the customer has been polling the status of the serving. Now that the barista is done, she
        "gets notified" of that fact:
          <programlisting>GET /orders/1234/serving/ HTTP/1.1
Host: api.restbucks.com          
Accept: application/ld+json          
</programlisting>
          <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json

{ "@id": "/orders/1234/serving",
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/serving/",
    "@type": "TakeAction",
    "hydra:httpMethod": "DELETE"
  } ]
}</programlisting>
       And finally she takes her serving: 
       <programlisting>DELETE /orders/1234/serving/ HTTP/1.1
Accept: application/ld+json          
</programlisting>
       To which the server responds that the process is done:
       <programlisting>HTTP/1.1 204 No Content</programlisting>
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        Lifecycles often appear in the context of a workflow (see <xref linkend="workflow"/>). The Workflow pattern 
        focuses on the various resources used by a single client, while the lifecycle pattern focuses on how multiple 
        clients collaborate using the same resource(s).
      </para>
      <para>
        The hand-offs between different parties may be synchronous or asynchronous (see <xref linkend="async"/>). In the
        latter case, parties can watch the state of the resource using polling (see <xref linkend="polling"/>) or
        notifications (see <xref linkend="notifications"/>).
      </para>
      <para>
        Some collaborating parties may be processors (see <xref linkend="processor"/>).
      </para>
    </simplesect>
  </section>
  
  <section id="processor">
    <title>Processor</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Repeatedly process similar items.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Sometimes we need producer-consumer like systems where one (type of) client produces resources that another
        consumes. In RESTBucks, for example, the cashier processes payment of orders that the customer creates, 
        while the barista prepares turns those orders into servings. 
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-processor.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        Producer-consumer systems traditionally communicate via a queue, and that may the best solution for you. If 
        decoupling of client and server from any particular queueing technology is important in your situation, 
        however, you may also consider a more RESTful approach.
      </para>
      <para>
        One option is to make the processing synchronous. The consumer sits idle waiting until the producer offers
        an item to be processed. The producer waits for the consumer to processes the item and report back the results.
      </para>
      <para>
        Another solution is to make the processing asynchronous. This looks more like the traditional queueing approach,
        with some collection resource playing the role of queue. The producer creates a new work item resource in the
        collection, and in time the consumer processes it.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <para>
        A RESTBucks barista is a processor that waits for paid orders:
        <programlisting>GET /orders/?status=paid HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 204 No Content</programlisting>
        After polling for a while, he has more luck:
        <programlisting>GET /orders/?status=paid HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/?status=paid",
  "@type": "hydra:Collection",
  "member": [ {
    "@id": "/orders/1234/"
  } ]
}</programlisting>
        Now that he has found a paid order, the barista can go prepare the serving for it:
        <programlisting>GET /orders/1234/ HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/"
  "@type": "Order",
  "items": {
    member: [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole",
    } ]
  },
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/serving/",
    "@type": [ "hydra:ReplaceResourceOperation", "CookAction" ],
    "hydra:httpMethod": "PUT"
  } ]
}</programlisting>
        The barista gets a different representation of the order than the customer based on his identity. We'll talk
        more about that in <xref linkend="security"/>. The barista doesn't need any details about the cost, so those
        are not included. There is an operation to notify the server that the serving is prepared, defined by 
        <literal>http://schema.org/CookAction</literal>. The barista calls that once he's done:
        <programlisting>PUT /orders/1234/serving/ HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 204 No Content</programlisting>
        All done with this order, the barista looks for the next:
        <programlisting>GET /orders/?status=paid HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 204 No Content</programlisting>
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        A processor usually processes similar items that are part of the same collection (see 
        <xref linkend="collection"/>). A processor can be one of the parties collaborating in a lifecycle (see
        <xref linkend="lifecycle"/>) or workflow (see <xref linkend="workflow"/>). 
      </para>
      <para>
        A processor must acquire new items to process. Polling (see <xref linkend="polling"/>) and notifications (see 
        <xref linkend="notifications"/>) are two ways in which the processor can discover new items.
      </para>
    </simplesect>
  </section>
  
  <section id="concurrency">
    <title>Concurrency</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Handle concurrent requests from multiple clients without one client undoing work from another client.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Any RESTful system is by definition a client-server system (see <xref linkend="rest"/>). One issue that often
        comes up in such systems is that the view that any client has of the resource state maintained by the server 
        becomes outdated when other clients update those resources. A client that acts on outdated information may 
        inadvertently undo another client's work, for example overwriting data that another client added.
      </para>
      <para>
        The classic example of a concurrency problem is transferring money between bank accounts. Suppose there is one 
        account resource with a <literal>balance</literal> property and two clients that want to transfer money into 
        the account. The first client issues a request to read the balance and gets a response. It then issues another 
        request to update the balance. Before the first and second requests, another clients reads the balance. After 
        the first client issues its update request, the second client does the same and undoes the work of the first 
        client, because it used outdated information.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-concurrency.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        The HTTP specification defines a number of headers that help solve concurrency issues using conditional 
        requests <citation>HTTP</citation>. <firstterm>Conditional requests</firstterm> are HTTP requests that include 
        one or more header fields indicating a precondition to be tested before applying the method semantics to the 
        target resource. These header fields are called <firstterm>validators</firstterm>.
      </para>
      <para>
        A server can use the <literal>Last-Modified</literal> response header to indicate when information was last 
        updated. The client can then supply that value in the <literal>If-Unmodified-Since</literal> request header. 
        If the information was updated since the provided date, the server will refuse the client's request.
      </para>
      <para>
        Another validator is the <literal>If-Match</literal> request header that checks against a value provided 
        earlier in an <literal>ETag</literal> response header.
        An <literal>ETag</literal>, or entity-tag, is an opaque validator for differentiating between multiple 
        representations of the same resource. Since this value is opaque, the client doesn't need to understand it and
        the server is free to use whatever implementation it sees fit.  
        The <literal>If-Match</literal> validator takes precedence over <literal>If-Unmodified-Since</literal>.
      </para>
      <para>
        <literal>ETag</literal> is usually a stronger validator than <literal>Last-Modified</literal>, which has a 
        resolution of one second. When using <literal>Last-Modified</literal>, there is thus a risk that updates get 
        lost when multiple requests arrive within a second of each other. In general, it's therefore better to
        use <literal>ETag</literal>s.
      </para>
      <para>
        Note that conditional requests can be used with the <literal>GET</literal> method as well as with unsafe 
        methods, as we'll see in <xref linkend="caching"/>.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <para>
        In order to help customers faster, RESTBucks uses more than one barista to prepare servings. To avoid two or
        more baristas working on the same order, each barista has to claim the order's serving before they can start 
        preparing it. A serving that is claimed by one barista can no longer be claimed by another.
      </para>
      <para>
        Barista 1 looks for a paid order to prepare:
        <programlisting>GET /orders/?status=paid HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/?status=paid",
  "@type": "hydra:Collection",
  "member": [ {
    "@id": "/orders/1234/"
  } ]
}</programlisting>
        <programlisting>GET /orders/1234/ HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"
ETag: 1    

{ "@id": "/orders/1234/"
  "@type": "Order",
  "items": {
    member: [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole",
    } ]
  },
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/serving/",
    "@type": [ "hydra:ReplaceResourceOperation", "AllocateAction" ],
    "hydra:httpMethod": "PUT",
    "hydra:expects": {
      "hydra:supportedProperty": [ {
        "@type": "Person",
        "hydra:property": "preparedBy",
        "hydra:required": true
      }
    }
  } ]
}</programlisting>
        Barista 2 does the exact same thing and gets the same response. Now barista 1 tries to claim the serving:
        <programlisting>PUT /orders/1234/serving/ HTTP/1.1
If-Match: 1
Content-Type: application/ld+json        
Accept: application/ld+json

{ "preparedBy": "Barista 1"
}</programlisting>
        <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"
ETag: 2

{ "@id": "/orders/1234/serving/",
  "preparedBy": "Barista 1"
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/serving/",
    "@type": [ "hydra:ReplaceResourceOperation", "CookAction" ],
    "hydra:httpMethod": "PUT"
  } ]
}</programlisting>
        The success response means barista 1 can start preparing the serving using the <literal>CookAction</literal>. 
        In the meantime, barista 2 also tries to claim the serving:
        <programlisting>PUT /orders/1234/serving/ HTTP/1.1
If-Match: 1
Content-Type: application/ld+json        
Accept: application/ld+json

{ "preparedBy": "Barista 2"
}</programlisting>
        But this fails because the serving is already claimed by barista 1:
        <programlisting>HTTP/1.1 412 Precondition Failed
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"
ETag: 2

{ "@id": "/orders/1234/serving/",
  "preparedBy": "Barista 1
}</programlisting>
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        The different parties in the Lifecycle pattern (see <xref linkend="lifecycle"/>) may run into concurrency 
        issues. Polling (see <xref linkend="polling"/>) clients may use conditional <literal>GET</literal> requests
        to reduce network traffic.
      </para>
    </simplesect>
  </section>

  <section id="correlation">
    <title>Correlation</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Group a series of request/response interactions between client and server.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Individual request/response interactions are often part of a larger whole. The client is usually trying to 
        reach a goal that requires multiple such interactions, as shown in <xref linkend="client-flow"/>. Sometimes it
        can be useful to debug, log, or report on the larger interaction group rather than the individual interactions.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-correlation.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        Sometimes all the correlation you need is in the URI. For instance, different resources that are part of a
        workflow may be grouped under one resource that represents the whole workflow. In such cases, no explicit
        correlation is necessary.
      </para>
      <para>
        If you do need to explicitly correlate messages, then remember that the server is stateless (see 
        <xref linkend="rest"/>), so only the client can indicate the relationship between individual requests. There
        is no standard solution to this problem, so it's best to use a custom header for this purpose. Even if the 
        server doesn't understand the header, it can still show up in the logs, which may be useful if the client
        developer can get access to those. At the very least the client can log requests itself, and the correlation 
        can happen on the client's side.
      </para>
      <para>
        Another approach is for the service to publish a header for correlation purposes. The value of this header may 
        be generated by the client before it issues the first request. Alternatively, the server could generate it and 
        add it to the response to the first request, after which the client picks it up and uses it for subsequent 
        requests in the group.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <para>
        Suppose we have multiple baristas preparing servings for RESTBucks customers. If we assign each a unique ID and
        use that as a correlation ID in all their requests, we can collect metrics like how many servings per day they
        they prepare, how often they run into concurrency issues, or how long they have to wait on average for a paid
        order. Armed with this information, we could optimize the number of baristas and how long they wait before they
        polling for paid orders. We'll talk more about data-driven process optimizations in <xref linkend="logging"/>.
      </para>
      <para>
        All we have to do to make this possible is to add a simple header to each request:
        <programlisting>GET /orders/?status=paid HTTP/1.1
Accept: application/ld+json</programlisting>
        <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"
Barista-Id: 1    

{ "@id": "/orders/?status=paid",
  "@type": "hydra:Collection",
  "member": [ {
    "@id": "/orders/1234/"
  } ]
}</programlisting>
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        The requests in a transaction (see <xref linkend="transactions"/>) and the steps in a workflow 
        (see <xref linkend="workflow"/>) are examples where individual requests are part of a larger group that has
        meaning on its own.
      </para>
    </simplesect>
  </section>
  
  <section id="transactions">
    <title>Transaction</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Execute a group of interactions as an atomic unit.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Since a REST server is supposed to be stateless, each request it receives is treated independently of others.
        Sometimes, however, a client wants a small set of requests to either go through all together, or none at all. 
        This is a special form of correlation, where the server understands and attaches a special meaning to the 
        correlation.
      </para>
      <para>
        One example of a transaction is transferring money between bank accounts. We want to withdraw money from one
        account and deposit it to another as an atomic unit. If the withdrawal fails, we don't want the deposit, or else
        we'd be creating money. Conversely, if the deposit fails, we don't want the withdrawal or we'd be destroying
        money.
      </para>
      <para>
        If possible, try to do without grouping requests in a transaction. Maybe your API is too fine-grained and you 
        can make the need for transactions disappear by making the API less chatty.
        Introduce higher-level resources that can meet the client's transactional needs by putting all the 
        functionality in a single request. In the banking example, you can get rid of transactions by using posting 
        rules <citation>Fowler97</citation> or by introducing a single "transfer" resource that captures the money
        transfer.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-transaction.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        There are at least two ways to implement transactions. The easiest implementation is to follow the pattern for 
        correlations (see <xref linkend="correlation"/>) and supply some sort of header that indicates the transaction. 
        You may need extra resources to begin, commit, and roll back the transaction. If you introduce a resource for
        beginning transactions, then the server will be able to generate the transaction ID that the client must send 
        with subsequent requests. Commit and rollback are idempotent operations, so you could use the 
        <literal>PUT</literal> and <literal>DELETE</literal> HTTP methods, respectively.
      </para>
      <para>
        Note that this approach means that the server needs to keep application state, so it violates the stateless 
        constraint (see <xref linkend="rest"/>) and therefore can't be considered RESTful.
      </para>
      <para>
        You'll have to decide whether the effect of the client's requests are visible
        to other clients before the transaction is committed. In other words, you'll have to decide the isolation level.
        Relational databases usually provide full ACID (atomicity, consistency, isolation, and durability) properties, 
        but many NoSQL databases don't. Think through all the consequences of your choices very carefully, because 
        things can get a bit hairy. Document your decisions precisely, so that clients know what to expect.
      </para>
      <para>
        An alternative approach to implementing transactions is to literally group the various requests into one, 
        using some <literal>multipart</literal> media type (see <xref linkend="batch"/>). The request that the client 
        sends will be made up of multiple parts that each represent what would have been an individual request in the
        transaction. The parts are separated by some boundary.
        This approach puts a high burden on both client and server implementations to compose and decompose the multiple
        parts, but it stays within the stateless constraint.
      </para>
      <para>
        The Batch pattern can get very complicated very quickly when the requests that make up the transaction are 
        interdependent. This happens when the input of one request depends on the output of a previous request. That is 
        often the case: if the requests were completely independent, then there probably wouldn't be a need to treat 
        them as an atomic unit. So this method may or may not be a viable solution to the problem.
      </para>
      <para>
        All in all, we think it's best to avoid the Transaction pattern if you can. By looking at the requirements from 
        the client's perspective, like we saw in <xref linkend="analysis"/>, you reduce the chances of building your API
        at a granularity level that is wrong for your clients. 
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <para>
        The following example is a bit contrived, because we really don't need transactions in RESTBucks, but 
        imagine that customer Chrissy brings her friend Joe. They both want a coffee, but only if the other person also
        gets one. Chrissy goes first:
      <programlisting>POST /orders/ HTTP/1.1
Host: api.restbuck.com
Accept: application/ld+json
Content-Type: application/ld+json
Transaction-Id: fc852df2-4582-4447-8249-7fcba1fff63c

{ "items": {
    "member": [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole"
    } ]
  },
  "customer": "Chrissy"
}</programlisting>
      <programlisting>HTTP/1.1 201 Created
Location: http://api.restbucks.com/orders/1234/
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"
Transaction-Commit: /transactions/6c9d7cec-1a42-447e-be0a-61041a4b4b96/    

{ "@id": "http://api.restbucks.com/orders/1234/",
  "@type": "Order",
  "items": {
    member: [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole",
      "price": 2.75,
      "currency": "USD"
    } ]
  },
  "total": 2.75,
  "currency": "USD",
  "customer": "Chrissy",
  "hydra:operation": [ {
    <lineannotation>... Operations ...</lineannotation>
  } ]
}</programlisting>
      The client uses a UUID as the transaction ID to ensure that she doesn't accidentally pick one that someone else 
      may pick as well. The server responds with a <literal>Transaction-Commit</literal> header that tells the client 
      where to commit the transaction later. Chrissy continues her workflow up till and including paying for her order.
      Then it's Joe's turn to do the same, using the same <literal>Transaction-Id</literal> as Chrissy used:
      <programlisting>POST /orders/ HTTP/1.1
Host: api.restbuck.com
Accept: application/ld+json
Content-Type: application/ld+json
Transaction-Id: fc852df2-4582-4447-8249-7fcba1fff63c

{ "items": {
    "member": [ {
      "name": "caramel macchiato",
      "size": "grande"
    } ]
  },
  "customer": "Joe"
}</programlisting>
      <programlisting>HTTP/1.1 201 Created
Location: http://api.restbucks.com/orders/1234/
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"
Transaction-Commit: /transactions/6c9d7cec-1a42-447e-be0a-61041a4b4b96/    

{ "@id": "http://api.restbucks.com/orders/1235/",
  "@type": "Order",
  "items": {
    member: [ {
      "name": "caramel macchiato",
      "size": "grande",
      "price": 4.25,
      "currency": "USD"
    } ]
  },
  "total": 4.25,
  "currency": "USD",
  "customer": "Joe",
  "hydra:operation": [ {
    <lineannotation>... Operations ...</lineannotation>
  } ]
}</programlisting>
        When Joe has paid too, the transaction is committed using one of the operations returned after paying for the
        order (not shown):
      <programlisting>PUT /transactions/6c9d7cec-1a42-447e-be0a-61041a4b4b96/ HTTP/1.1
Host: api.restbuck.com
Accept: application/ld+json</programlisting>
      <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"
    
{ "@id": "/transactions/6c9d7cec-1a42-447e-be0a-61041a4b4b96/",
  "@type": "hydra:Collection",
  "member": [ {
    "@id": "/orders/1234/serving/",
    "customer": "Chrissy"
  }, {
    "@id": "/orders/1235/serving/",
    "customer": "Joe"
  } ]
}</programlisting>
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        The correlation pattern (see <xref linkend="correlation"/>) provides one way of grouping the requests that make
        up the transaction. The batch pattern (see <xref linkend="batch"/>) is another.
      </para>
    </simplesect>
  </section>
  
  <section id="batch">
    <title>Batch</title>
    <simplesect>
      <title>Intent</title>
      <para>
        Send multiple logical requests in a single HTTP request.
      </para>
    </simplesect>
    <simplesect>
      <title>Motivation &amp; Applicability</title>
      <para>
        Batches can be used for a variety of reasons, like transactional semantics (see <xref linkend="transactions"/>) 
        and reduction of the number of network roundtrips in constrained environments such as in mobile scenarios.
      </para>
    </simplesect>
    <simplesect>
      <title>Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/pat-batch.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <para>
      </para>
    </simplesect>
    <simplesect>
      <title>Implementation</title>
      <para>
        Group the various requests into one body, using some <literal>multipart</literal> media type 
        <citation>Multipart</citation>. The body of HTTP request that the client sends is made up of multiple 
        <firstterm>body parts</firstterm> that each represent an individual logical request and are preceded and
        followed by a <firstterm>boundary delimiter line</firstterm>.
      </para>
      <para>
        The boundary is specified by the client in the <literal>boundary</literal> parameter of the multipart media 
        type, e.g. <literal>Content-Type: multipart//mixed; boundary="gc0p4Jq0M2Yt08j34c0p"</literal>. A boundary 
        delimiter line consists of two hyphens (<literal>--</literal>), the boundary, and optionally whitespace.
        Boundaries must not be longer than 70 US ASCII characters. The message should end with a boundary line followed 
        by two more hyphens, e.g. <literal>--gc0p4Jq0M2Yt08j34c0p--</literal>. A good way to make sure the boundary
        doesn't occur anywhere in any of the body parts, is to use a UUID.
      </para>
      <para>
        Each body part is similar to a regular HTTP message, with some headers, a blank line, and an entity body. A
        body part is not exactly the same as a message, however. Headers are not required in a body part, in which case 
        the body part will start with a blank line and the <literal>text/plain</literal> media type is assumed (unless
        the media type is <literal>multipart/digest</literal>, then it's <literal>message/rfc822</literal>). Another
        difference is that only the header fields whose names start with <literal>Content-</literal> are officially 
        supported, which means that gateways are allowed to drop all other headers.
      </para>
      <para>
        You most likely will want to use the <literal>multipart/mixed</literal> media type, because then the order of 
        the body parts is significant.
      </para>
      <para>
        This approach puts a higher burden on both client and server implementations than using regular media types,
        because they need to compose and decompose the body parts. Most HTTP libraries will do this hard work for you,
        however.
      </para>
      <para>
        The Batch pattern can get very complicated very quickly when the requests that make up the transaction are 
        interdependent. This happens when the input of one request depends on the output of a previous request. That is 
        often the case: if the requests were completely independent, then there probably wouldn't be a need to treat 
        them as an atomic unit. So this method may or may not be a viable solution to the problem.
      </para>
      <para>
        Like the Transaction pattern, this is an advanced pattern that may be more trouble than it's worth. Think
        carefully about alternatives before you commit to it.
      </para>
      <para>
        TODO: Don't use <literal>application/http</literal> for the content type of the body parts, as this leaks
        information of the protocol into the messages and will break when moving to HTTP/2.
      </para>
    </simplesect>
    <simplesect>
      <title>Example</title>
      <para>
        Let's use the same contrived example as for transactions, where Chrissy and Joe both order a drink and want to
        pay for it only if the other gets their drink:
        <programlisting>POST /batches/ HTTP/1.1
Content-Type: multipart/mized; boundary="290a551af70843a4bff0982547dcf9fc"
Accept: application/ld+json
        
--290a551af70843a4bff0982547dcf9fc
Content-Type: application/http

POST /orders/ HTTP/1.1
Host: api.restbuck.com
Accept: application/ld+json
Content-Type: application/ld+json
Transaction-Id: fc852df2-4582-4447-8249-7fcba1fff63c

{ "items": {
    "member": [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole"
    } ]
  },
  "customer": "Chrissy"
}
--290a551af70843a4bff0982547dcf9fc
Content-Type: application/http

POST /orders/ HTTP/1.1
Host: api.restbuck.com
Accept: application/ld+json
Content-Type: application/ld+json
Transaction-Id: fc852df2-4582-4447-8249-7fcba1fff63c

{ "items": {
    "member": [ {
      "name": "caramel macchiato",
      "size": "grande",
    } ]
  },
  "customer": "Joe"
}
--290a551af70843a4bff0982547dcf9fc
<lineannotation>... More messages ...</lineannotation>
--290a551af70843a4bff0982547dcf9fc--        
        </programlisting>
        The example uses the <literal>application/http</literal> media type to enclose the HTTP messages inside the
        batch message, but you can use other media types as well, as long as both client and server agree on what the 
        enclosed messages mean.
      </para>
    </simplesect>
    <simplesect>
      <title>Related Patterns</title>
      <para>
        Batch requests can be used to implement transactions (see <xref linkend="transactions"/>).
      </para>
    </simplesect>
  </section>
  
  <section>
    <title>Summary</title>
    <para>
      This chapter presents some design patterns that you'll see over and over again in REST APIs. If you apply these
      patterns judiciously in the context of the methodology of <xref linkend="design"/> then you should be in good 
      shape to meet most functional requirements. In <xref linkend="radl"/>, we'll show how tooling can support this
      methodology.
    </para>
    <para>
      Some of the non-functional requirements make a big impact on an API's chances of success. We will look at 
      them next in <xref linkend="error"/>, <xref linkend="performance"/>, and <xref linkend="security"/>.
    </para>
  </section>
</chapter>
