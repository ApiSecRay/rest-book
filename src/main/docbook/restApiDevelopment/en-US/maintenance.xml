<chapter id="maintenance">
  <title>Maintenance</title>
  <para>
    So far we've analyzed a problem, designed a solution for it in the form of an API, implemented that API, tested
    the implementation, and put it into production. That doesn't mean we can now sit back and relax. More often than
    not, deploying into production is only the first step of a long journey.
  </para>
  <para>
    Along the way, we'll be asked to make changes to our system. We'll gain new insights into the problem by observing
    clients use our API. We'll get bug reports and feature requests. We'll see our competitors innovate. For all these
    reasons and more we need to adapt to thrive.
  </para>
  <para>
    This chapter discusses how to make changes to a REST API in such a way that well-behaved clients won't break.
  </para>
  
  <section>
    <title>Making Changes</title>
    <para>
      It's always safest to only make changes that are <firstterm>backwards compatible</firstterm>, meaning that every
      interaction with the old version of the API is valid with the new API. By definition, that won't break any
      clients. The following changes are always backwards compatible:
    </para>
    <variablelist>
      <varlistentry>
        <term>Adding a new optional property to a request or response</term>
        <listitem>
          <para>
            The new element won't be used by older clients, but that's okay because it is optional. New clients may
            start using it, which can lead to older clients seeing it. If they committed to a strict schema, they will
            break. If, however, they follow the general guideline to ignore unknown elements (see 
            <xref linkend="application-state"/>), they should be fine.
          </para>
          <para>
            You can add a new property anywhere you like; the order of properties shouldn't impact clients. Not all
            clients are well-behaved, however, and you may want to minimize breakage by adding properties at the end.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Adding a new link to a response</term>
        <listitem>
          <para>
            A similar story holds for adding new links. These links may point to new resources that the old clients
            know nothing about. Those clients can still discover the new resources via the new links. Depending on the
            client's capabilities and the richness of the media type (see <xref linkend="maturity"/>), old clients may 
            even be able to use the new resources! This is the power of hypermedia at work.
          </para>
          <para>
            You can add new links to any response you deem fit. Add big chunks of new functionality to the home
            resource (see <xref linkend="home"/>), unless you have a good reason to do otherwise. 
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Making a required property optional</term>
        <listitem>
          <para>
            Old clients will continue to provide the property, which is fine. New clients may not, which is also fine.
            Old clients may then see responses without the property. Well-behaved clients are able to cope with that,
            although that may mean that they have to offer a degraded service.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      This is a very short list. You can really only change an API in a backwards compatible way by adding to it and
      by relaxing constraints. Here's why other changes are not backwards compatible:
    </para>
    <variablelist>
      <varlistentry>
        <term>Adding a new mandatory property to a request</term>
        <listitem>
          <para>
            An old client will not know how to provide the new property. Since it is mandatory, the requests from
            the old client will now be rejected and the client is broken.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Changing a property name</term>
        <listitem>
          <para>
            An old client will not know to use the new name of the property. It will provide values under the old name,
            which the new server won't pick up. If the property is mandatory, the request will be rejected and the
            client is broken. If the property is optional, it will be ignored, which may be just as disastrous.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Making an optional property required</term>
        <listitem>
          <para>
            Since the property was optional before, there may be clients out there that don't provide a value for the
            property. Any such request will be rejected by the server and break the client.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Removing a property</term>
        <listitem>
          <para>
            And old client may still set the property. The server should ignore the now-unknown property. This may be
            fine for the client, or it may not be. Some clients may rely on the provided value being there later and
            may break if it isn't there.
          </para>        
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Changing the link relation for a link</term>
        <listitem>
          <para>
            An old client won't be able to find the link anymore, since it uses the link relation to look up the link.
            Some clients may be able to handle that and gracefully degrade their service, but others may break.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Removing a link</term>
        <listitem>
          <para>
            The effects of this change are similar to changing the link's relation.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      TODO: Add new high-level functionality to the Home resource.
    </para>
    <para>
      TODO: evolvability, maintainability
    </para>
  </section>
  
  <section id="consumer-contract">
    <title>Consumer contracts</title>
    <para>
      There may be different types of clients, each with their own goals they're trying to reach through the API.
      This is especially likely in a microservices architecture. In that situation it's also likely that both your 
      API and your clients are changing often.
    </para>
    <para>
      In one way, this changes nothing about how you test your API: you still need to know what parts of your API your
      clients use and you still need to make sure that their expectations are met, as we saw in <xref linkend="test"/>.
    </para>
    <para>
      In another way, however, this changes everything. As new clients are added to the mix and old clients are updated 
      or retired, it gets increasingly difficult to keep track of what part of your API is actually being used.
    </para>
    <para>
      It's imperative that you have this overview. If you don't know what your clients are using, that severely
      limits your options for evolving your API. If you don't know whether some part of your API is being used, and
      if so, how, then you can't really change it in a backwards-incompatible way. There are some things you can do
      in that situation to keep your ability to innovate, and will discuss those below, but your options will be
      fairly limited.
    </para>
    <para>
      If you do know exactly what your clients need, you're in a much better position. If you know for sure that
      nobody is using feature X, for instance, you can safely delete it. If you know that only client Y is using
      feature Z, then you may be able to coordinate an incompatible change with the people that build client Y.
    </para>
    <para>
       In a situation with many different, rapidly evolving clients, it becomes rather unwieldly to update the state 
       diagrams by hand. We should be looking at automation to help us out. Such automation is made possible by 
       <firstterm>consumer contracts</firstterm>, the contract between you and one particular client, or consumer.
    </para>
    <para>
      To support automation, the consumer contract has to be an exectuable specification, just as BDD scenarios are.
      On top of that, we also need to be able to automatically <emphasis>generate</emphasis> them.
      Automatically generating consumer contracts can only be done by observing real clients as they interact with
      your API.
    </para>
    <para>
      A good place to capture client interactions is in the Continuous Integration pipeline of the client.
      The black-box tests for the client will run against your API, either against a real server or against a stub.
      At this point we can intercept the client's calls and capture them into a consumer contract. Correlation IDs
      help to link related requests and responses together (see <xref linkend="correlation"/>), especially when you
      run multiple tests in parallel.
    </para>
    <para>
      There are a couple of open source tools to support consumer contracts.
      TODO: Describe Pacto and/or Pact with an example.
    </para>
    <para>
      If you don't control your clients, for example when your API fronts a hosted service, you most likely are not in
      a position to coordinate changes with your clients. You can still capture their interactions to see what parts of 
      the API they use (see <xref linkend="logging"/>) and you can still use those interaction patters to create 
      consumer contracts, but any changes to your API must now be limited to those that don't break your clients.
      Let's see how we can do that.
    </para>
  </section>

  <section id="breaking-changes">
    <title>Breaking Changes</title>
    <para>
      Introducing new media types is one way to evolve your REST API when you must make backwards incompatible changes.
      You can continue to serve old clients with the old media type, while new clients can take advantage of the new 
      media type.
    </para>
  </section>

  <section>
    <title>Extensibility</title>
  </section>
  
  <section>
    <title>Summary</title>
  </section>
</chapter>
