<chapter id="security">
  <title>Security</title>
  <para>
    Exposing your data or application through a REST API is a wonderful way to reach a wide audience. The downside of 
    a wide audience, however, is that itâ€™s not just the good guys who come looking. Especially publicly available APIs
    risk attracting all kinds of people we'd rather keep out. Unless your API serves nothing but free, public, and
    read-only data, you must secure it.
  </para>
  <para>
    This chapter describes what security is, discusses the tools we have available to achieve it, and explains when
    and how to apply those tools.
  </para>
  
  <section>
    <title>Security 101</title>
	  <para>
	    Security consists of three factors, collectively known as the CIA-triad:
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term>Confidentiality</term>
	      <listitem>
	        <para>
		        The extent to which information is shared only with those who are eligible to see it. If confidentiality is
		        compromised, we speak of <firstterm>Information Disclosure</firstterm>.
	        </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Integrity</term>
		    <listitem>
		      <para>
			      The extent to which information can only be added, changed, and removed by authorized agents. If integrity is
			      compromised, we speak of <firstterm>Tampering</firstterm>.
		      </para>
		    </listitem>  
	    </varlistentry>
	    <varlistentry>
	      <term>Availability</term>
				<listitem>
				  <para>
					  The extent to which information is accessible to those who need it, when they need it. If availability is 
					  compromised, we speak of <firstterm>Denial of Service</firstterm> (DoS).
				  </para>
				  <para>
				    TODO: Move somewhere else
				    As we saw in <xref linkend="caching"/>, CDNs serve a large fraction of Internet content today. They provide 
				    the content provider a degree of protection from DoS attacks by using their large distributed server 
				    infrastructure to absorb the attack traffic.
				  </para>
				</listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	    In the context of an HTTP-based API, Information Disclosure is a concern for <literal>GET</literal> methods and 
	    any other methods that return information (see <xref linkend="return-representation"/>). Tampering is applicable 
	    for <literal>PUT</literal>, <literal>POST</literal>, and <literal>DELETE</literal>. Denial of Service is a concern 
	    with all HTTP methods.
	  </para>
	  <para>
	    Security may be compromised by accident or on purpose. In the latter case, we speak of an 
	    <firstterm>attack</firstterm>. If security is compromised, we say that a <firstterm>vulnerability</firstterm>
	    is <firstterm>exploited</firstterm>, but vulnerabilities may exist even if they are not exploited (yet).
	  </para>
	  <para>
	    Vulnerabilities exist for a variety of reasons, which fall broadly into two classes. We may have overlooked 
	    something during our design, in which case we speak of a <firstterm>design flaw</firstterm>, or we may have
	    implemented a sound design in an inappropriate way, in which case we speak of a <firstterm>bug</firstterm>. 
	    Vulnerabilities are split about evenly between flaws and bugs, so you really can't build a secure system unless you 
	    take measures to prevent both categories.
	  </para>
	  <para>
	    Not all vulnerabilities are equally severe. The US National Institute of Standards and Technology (NIST) has
	    developed a scoring system named <firstterm>Common Vulnerability Scoring System</firstterm> 
	    <citation>CVSS</citation> to compare the relative severity of vulnerabilities.
	    There is an online risk rating tool that calculates the CVSS score based on a number of different aspects. 
	    These scores range from 0 (no problem at all) to 10 (critical and easy to exploit).
	    You can use CVSS scores to guide your risk management strategy.
	  </para>
	  <para>
	    Security vulnerabilities are yet another form of risk for your project, so you can use your regular risk management 
	    strategy to handle them. In general, risks can be handled in the following ways:
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term>Eliminate</term>
	      <listitem>
	        <para>
	          You change the design or implementation such that the risk goes away completely. This is the best option, but
	          unfortunately often impossible.
	        </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Mitigate</term>
	      <listitem>
	        <para>
	          You introduce a <firstterm>compensating control</firstterm> to counteract the bad effects that would occur 
	          when the risk materializes. For instance, you can use Transport Layer Security (TLS, see 
	          <xref linkend="tls"/>) to protect data in transit from being disclosed or tampered with.
	        </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Transfer</term>
	      <listitem>
	        <para>
	          You make the risk someone else's problem. For instance, you could see information disclosure of your 
	          customer's data as their problem. A customer that doesn't want to live with this risk could then encrypt 
	          their data before they uploaded it to your system. In this example, the customer mitigates the risk
	          that you transferred onto them using encryption as the compensating control.
	        </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Accept</term>
	      <listitem>
	        <para>
	          You simply accept the risk. Life isn't risk free and in many cases we can live with minor risks. Use the
	          CVSS score to clearly define what you consider a minor risk. The cut-off score depends on your specific 
	          situation and your risk tolerance.
	        </para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	    In most cases, risk elimination is impossible, and risk mitigation is the preferred option. 
	    We can use a number of compensating controls for this, which fall into a couple of broad classes:
	  </para>
	  <variablelist>
      <varlistentry>
        <term>Encryption</term>
        <listitem>
          <para>
            The act of transforming a <firstterm>plain text</firstterm> into a <firstterm>cypher text</firstterm> using
            a special mathematical function known as a <firstterm>cryptographic algorithm</firstterm>. This algorithm 
            takes a special number called a <firstterm>cryptographic key</firstterm> and some data (the plain text) as 
            input and transforms (encrypts) it into some output (the cypher text), which can be converted back 
            (decrypted) to the original input using the same algorithm and the same or another key.
          </para>
          <para>
            <firstterm>Symmetric encryption</firstterm> uses a single key to encrypt and decrypt data. Since this key 
            unlocks sensitive data, it must be protected itself. We call this <firstterm>key management</firstterm>. 
            Asymmetric encryption uses two keys. The first is called the <firstterm>public key</firstterm>, and can be 
            freely shared with anybody. The second one is the <firstterm>private key</firstterm> and must be kept 
            secret at all cost, just like an symmetric key. Asymmetric encryption is also referred to as 
            <firstterm>public-key cryptography</firstterm>. 
          </para>
          <para>
            A <firstterm>public key certificate</firstterm> (also known as a digital certificate or identity 
            certificate) is an electronic document used to prove ownership of a public key. The certificate includes 
            information about the key, information about its owner's identity, and the digital signature of an entity 
            that has verified that the certificate's contents are correct. If the signature is valid, and the person 
            examining the certificate trusts the signer, then they know they can use that key to communicate with its 
            owner.
          </para>
          <para>
            The signer of a public key certificate is usually a <firstterm>certificate authority</firstterm> (CA), a
            company which charges customers to issue certificates for them. Browsers come with a bunch of pre-installed
            public key certificates of CAs. These are also known as <firstterm>root certificates</firstterm>, because
            they can be seen as the root of a tree, where each node in the tree is a certificate that is signed by its 
            parent.
          </para>
          <para>
            Encryption can be applied at different stages. When data that flows from one actor or process to another
            is encrypted, we speak of encryption of <firstterm>data in transit</firstterm>. We discuss that in 
            <xref linkend="tls"/>. When encryption is applied to data that is stored, then we speak of encryption of 
            <firstterm>data at rest</firstterm>. This is vital to protect your customer's data, but it is not specific 
            to REST APIs and therefore out of scope for this book.
          </para>
        </listitem>
      </varlistentry>
	    <varlistentry>
	      <term>Authentication</term>
	      <listitem>
	        <para>
	          The act of verifying someone's identity using one or more of the authentication factors:
	        </para>
	        <itemizedlist>
	          <listitem>
	            <para>
	              Something that you know, like a password or secret key
	            </para>
	          </listitem>
	          <listitem>
	            <para>
	              Something that you have, like a One Time Password generating device such as RSA SecureID, or a mobile
	              phone
	            </para>
	          </listitem>
	          <listitem>
	            <para>
	              Something that you are, like a fingerprint or an iris image
	            </para>
	          </listitem>
	        </itemizedlist>          
		      <para>
		        Some of these factors are stronger than others. A password, for instance, isn't very secure. Unless forced
		        otherwise, many people pick weak passwords like <literal>password1</literal>, which is the most commonly 
		        used password at the time of writing (it replaced the previous favorite of <literal>password</literal>, so
		        that's progress of some sort). Even when people pick strong passwords, they tend to reuse them across
		        services, which means that a breach of another service poses a threat to yours.
		      </para>
		      <para>
		        Combining several types of authentication factors makes the authentication process more secure. We 
		        speak of <firstterm>two-factor authentication</firstterm> if two different factors are used. In practice 
		        this is usually something that you know and something that you have. You'll sometimes also see this 
		        referred to as <firstterm>multi-factor authentication</firstterm> or <firstterm>two-step 
		        authentication</firstterm>.
		      </para>
		      <para>
		        Authentication usually uses from form of encryption. If passwords are used, they should be encrypted using
		        a one-way algorithm. Public key cryptography can also be used for authentication, especially of computer
		        programs rather than human users.
		      </para>
		      <para>
		        We'll discuss authentication of REST APIs in <xref linkend="authentication"/>.
		      </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Authorization</term>
	      <listitem>
	        <para>
	          The act of assigning different permissions to different users. Authorization is sometimes also referred to
	          as <firstterm>access control</firstterm>.
	        </para>
	        <para>
	          An important principle in authorization is that of <firstterm>Least Privilege</firstterm>, which means that
	          you should give people just enough permissions to do their job, but no more.
	        </para>
	        <para>
	          In order to assign permissions to users, you need to know their identity. In other words, authorization
	          requires authentication.
	        </para>
		      <para>
		        We'll discuss authorization of REST APIs in <xref linkend="authorization"/>.
		      </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>Auditing</term>
	      <listitem>
	        <para>
	          The systematic and independent examination of data for a stated purpose. For instance, if you 
	          collect, store, and process medical data in the US, you must comply with the Health Insurance Portability 
	          and Accountability Act (HIPAA). The US Department of Health &amp; Human Services may perform an 
	          <firstterm>audit</firstterm> to verify you have controls in place to ensure compliance with HIPAA.
          </para>
          <para>
            The audit can only be as good as the data on which it is based, so it's crucial to be able to prove that 
            the data is correct. There are two aspects to this:
          </para>
          <itemizedlist>
            <listitem>
              <para>
                <firstterm>Origin</firstterm> refers to who created the data and how sure we are of that. For this we
                require authentication.
              </para>
              <para>
                <firstterm>Integrity</firstterm> refers to the contents of the data and how sure we are that it hasn't 
                been tampered with.
              </para>
            </listitem>
          </itemizedlist>
          <para>
            Audits in the brick and mortar world rely heavily on signed documents. <firstterm>Signatures</firstterm> 
            identify a person, so they address the origin aspect. Signing a document also implies consent with the 
            document's content, which touches on the integrity part. Since paper documents are physical objects, they 
            can be stored in a safe location to maintain that integrity.
          </para>
          <para>
            Digital documents are different, since they can easily be copied and modified. To prove their origin and 
            integrity, we use <firstterm>digital signatures</firstterm>. Digital signatures rely on cryptography, in 
            particular on public-key cryptography.
          </para>
          <para>
            Here's how public-key crypto is applied to the digital signature problem. One party (Alice) signs a 
            document by encrypting it with her private key and sends the result to the other party (Bob). Bob tries to 
            decrypt the cypher text with Alice's public key. If that produces anything meaningful, then he knows that 
            Alice must have encrypted the document (origin) and that what he received was in fact exactly the document 
            that was signed by Alice (integrity). If either of those statements were not true, the decryption could 
            not have worked.
          </para>
          <para>
            Actually, all that Bob knows for sure is that the document was signed by the private key that belongs to 
            the public key that he has. But how does he know that that public key is actually Alice's? That's where 
            public key certificates come in.
          </para>
	        <para>
	          We'll discuss auditing of REST APIs in <xref linkend="auditing"/>.
	        </para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	    As with many other non-functional requirements, security is best built in rather than bolted on after the fact 
	    <citation>McGraw06</citation>.
	    Preventing design flaws is the subject of this chapter, while we look at bugs with security implications in 
	    <xref linkend="implementation"/>. Both activities should be part of a development approach that considers security
	    at every step, what Microsoft calls a <firstterm>Security Development Lifecycle</firstterm>
	    <citation>SDL</citation>.
	  </para>
	  <para>
	    An SDL is a structured approach to building security in. It consists of many activities that we won't cover in 
	    this book, like providing developers with specific security training. While essential for building secure 
	    software, these activities are not specific to REST APIs and thus out of scope for the current discussion. 
	  </para>
	  <para>
	    What we will cover is the main tool of the design phase of the SDL: threat modeling. This activity will tell you
	    what tools from our security toolbox you'll need to employ. 
	  </para>
  </section>
    
  <section id="threat-modeling">
    <title>Threat Modeling</title>
    <para>
      <firstterm>Threat modeling</firstterm> is a design activity where the designer explicitly considers the security
      aspect of the system in four steps <citation>Shostack14</citation>. Here's how it works:
    </para>
    <procedure>
      <title>Threat Modeling</title>
      <step>
        <para>Model the system.</para>
        <para>
          In this step you think about what you're going to build.
          Since it's the data that we're trying to protect, most threat models start by looking at the various ways
          data flows through the system.
        </para>
        <para>
          The notation that's most often used for this is a diagram called a <firstterm>Data Flow Diagram</firstterm> 
          (DFD), which shows the processes, data stores, and data flows between them. We won't be using DFDs here,
          because they contain information about the API's implementation that is beyond the scope of this book, like
          what data stores are used to store resource state.
        </para>
        <para>
          In the following, we're only going to look at security
          from the API's perspective. Since security is only as strong as its weakest link, you really should look at
          securing your implementation as well. Consult specific security books as needed.
        </para>
        <para>
          The state diagrams we developed in <xref linkend="state-diagrams"/> are also useful diagrams to build your 
          threat model. Each state diagram is developed for one persona and it is important from a security perspective
          to know the various personas and what they should and shouldn't be able to do.  
        </para>
        <para>
          The most interesting parts of a state diagram for our current exercise is the transition. Each transition
          implies the flow of data from client to server and/or back. We already inventoried the data that flows across
          the transitions in <xref linkend="design-messages"/>.
        </para>
        <para>
          With the actors and messages, we have the basic building blocks for the model of the API.
        </para>
      </step>
      <step>
        <para>Find threats.</para>
        <para>
          In this step you think about what can go wrong once the system is built. This is where you try
          to think like an attacker. This is often very difficult for developers that haven't had proper training, so
          you'll probably want to bring in specific expertise.
        </para>
        <para>
          There are a couple of structured approaches to help you discover threats, like STRIDE, attack trees, and 
          attack libraries, that will give you much better results than simply brainstorming the possible threats.
        </para>
        <para>
          STRIDE is an acronym for the various classes of security threats: Spoofing, Tampering, Repudiation,
          Information disclosure, Denial of service, and Elevation of privileges. We've already discussed tampering,
          information disclosure and denial of service.
        </para>
        <para>
          Spoofing occurs when one actor impersonates another. 
          Repudiation is when an actor does something and then can successfully claim that they didn't do it. 
          Elevation of privileges occurs when one actor can operate with the privileges of another.
          In the STRIDE approach, you check each of the elements in the model against the various classes of threats
          to identify which are applicable.
        </para>
        <para>
          TODO: attack trees
        </para>
        <para>
          TODO: attack libraries
        </para>
      </step>
      <step>
        <para>Address threats.</para>
        <para>
          In this step you treat the identified threats as risks, and you apply your risk management process to
          eliminate, mitigate, transfer, or accept the security risks they pose. We'll see some common ways of doing
          that in the following sections.  
        </para>
      </step>
      <step>
        <para>Validate.</para>
        <para>
          In this step you verify that you did a decent job of analysis. One way of doing that is to compare your
          threat model against that of a similar system. Another is to walk someone who wasn't involved in the
          threat modeling effort through the model and see if they can spot errors and/or omissions.
        </para>
      </step>
   </procedure>
   <para>
     Let's apply this procedure to RESTBucks. We've already done most of the work for building the model in 
     <xref linkend="analysis"/>. Our actors are the customer, the cashier, and the barista. The state diagrams are in
     <xref linkend="sd-customer"/>,<xref linkend="sd-cashier"/>, and <xref linkend="sd-barista"/>.
   </para>
   <para>
     TODO: identify threats &amp; mitigations
   </para>
  </section>

  <section id="tls">
    <title>Transport Layer Security</title>
    <para>
      Transport Layer Security (TLS) is the successor to Secure Sockets Layer (SSL). When combined with HTTP, we speak
      of HTTPS. It is a protocol for encrypting data in transit.
    </para>
    <para>
      TODO: Elaborate
    </para>
    <para>
      As we saw in <xref linkend="caching"/>, messages sent over HTTPS cannot be cached by intermediaries like
      caching proxies. That leaves two places where we can still employ caching: at the beginning and end of the 
      encrypted channel. The beginning is the REST client, while the server is the end. Since caches at a single client
      will often suffer from a low cache hit ratio, it is advisable to employ caching proxies at the server after 
      termination of the TLS connection. To this end, it is common to terminate the TLS connection at the load balancer
      (see <xref linkend="load-balancing"/>) and use plain HTTP connections within the data center.
    </para>
    <para>
      This approach leaves us vulnerable to information disclosure within the data center. To mitigate this risk of
      insider threats, we should at the minimum employ auditing (see <xref linkend="auditing"/>), so that we can
      detect such abuse and hope that the threat of taking corrective action after the fact is enough of a deterrent
      for insiders to behave themselves.
    </para>
  </section>
  
  <section id="authentication">
    <title>Authentication</title>
    
    <section>
      <title>HTTP Authentication</title>
      <para>
        TODO:
      </para>
    </section>

    <section>
      <title>HTTP Signatures</title>
      <para>
        TODO:
      </para>
    </section>

    <section>
      <title>Tickets</title>
	    <para>
	      Remember that authentication, the act of verifying someone's identity, is the basis for both authorization and
	      auditing. This means we must have access to the user's identity for each request. In traditional web applications,
	      the user logs on once, after which a <firstterm>session</firstterm> is established. The session is identified by
	      some session identifier that is usually stored in a cookie. The server associates the session identifier with
	      the user's attributes.
	    </para>
	    <para>
	      The problem with this approach is that the session that the server stores is state that we rather wouldn't store.
	      An alternative that is much better suited for stateless servers is to use tickets. 
	    </para>
      <para>
        TODO: A <firstterm>ticket</firstterm> is ...
      </para>
    </section>
  </section>

  <section id="authorization">
    <title>Authorization</title>
	  <para>
      The traditional way to implement authorization of REST APIs is to specify restrictions at the level of URI and 
      HTTP method. For instance, this is the approach that Spring Security takes.
    </para>
    <para>
      There are two places where such access control checks comes into play. The first is obviously when receiving a 
      request. You should also check permissions on any links you want to put in the response. The links that the 
      requester is not allowed to follow should be omitted from the response, because the links are supposed to be
      options that the client can choose from for its next move.
    </para>
    <para>
      The problem with specifying access control in terms of URIs and HTTP methods is that these are implementation 
      details. 
      URIs shouldnâ€™t be known to anybody but the API designer/developer; the client will discover them through link 
      relations. Even the HTTP methods can be hidden until runtime with mature media types like JSON-LD with Hydra.
      This is great for decoupling the client and server, but now we have to specify our security constraints in terms 
      of implementation details! This means that only the developers can specify the access control policy.
    </para>
    <para>
      This flies in the face of best security practices, where the access control policy is externalized 
      from the code (so it can be reused across applications) and specified by a security officer rather than a 
      developer. So how do we satisfy both requirements?
    </para>
    <para>
      The answer lies in the state diagram underlying the REST API. Remember, we want to authorize all transitions. 
      Yes, a transition in an HTTP-based API is implemented using an HTTP method on a URI. But in REST, we shield the 
      URI using a link relation. The link relation is very closely related to the type of action you want to perform.
    </para>
    <para>
      The same link relation can be used from different states, so the link relation canâ€™t be the whole answer. We 
      also need the state, which is based on the representation returned by the REST server. This representation 
      usually contains a set of properties and a set of links. Weâ€™ve got the links covered with the link relations, 
      but we also need the properties.
    </para>
    <para>
      The link relation indicates the action to be performed, while the properties correspond to 
      resource attributes. Add to that the subject attributes obtained through the authentication process, and you 
      have all the ingredients for making an XACML request.
    </para>
    <para>
      TODO: Think this through. When implementing a controller, we no longer have access to the link relation that
      led to the method being invoked on the URI...
    </para>
    
    <section>
      <title>eXtensible Access Control Markup Language</title>
      <para>
        TODO:
      </para>
    </section>
    
    <section>
      <title>OAuth</title>
      <para>
        TODO:
      </para>
    </section>
  </section>

  <section id="auditing">
    <title>Auditing</title>
    <para>
      Auditing is the act of keeping a record of who did what when. This is our primary tool for dealing with 
      non-repudiation attacks. A client can no longer claim it didn't do something, because we have records to prove
      that it did. 
    </para>
    <para>
      Auditing requires a couple of things to be in place. We need proper authentication to ensure we know who is
      performing the actions that we're keeping records of. We also need to make sure that nobody can tamper with the
      audit trail. This is especially important as a mitigation against insider threats, as administrators may have
      access to the audit trail.
    </para>
    <para>
      We can protect our audit trail against tampering by signing it. TODO: elaborate
    </para>
    <para>
      Even with signed audit records we may still not be out of the woods. We must also protect audit records against
      malicious input that could change the meaning. For instance, if each audit record is stored as a single line in a 
      text file, then a message containing a newline may cause multiple audit records to be written. This attack is
      known as <firstterm>log forging</firstterm>. The mitigating control against this vulnerability is to do proper
      output encoding, as we'll discuss in <xref linkend="output-encoding"/>.
    </para>
    <para>
      With a tamper-proof audit trail in place we can in theory detect malicious activity by insiders. To turn theory
      into practice, we should employ alerting to notify a broad group of administrators when something fishy is going
      on (see <xref linkend="alerting"/>).
    </para>
    <para>
      TODO: Make audit trail available to client.
    </para>
    <para>
      TODO: What to audit.
    </para>
  </section>
  
  <section>
    <title>Summary</title>
    <para>
      TODO:
    </para>
  </section>
</chapter>
