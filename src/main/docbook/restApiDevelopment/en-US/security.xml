<chapter id="security">
  <title>Security</title>
  <para>
    Exposing your data or application through a REST API is a wonderful way to reach a wide audience. The downside of
    a wide audience, however, is that it’s not just the good guys who come looking. Especially publicly available APIs
    risk attracting all kinds of people we'd rather keep out. Unless your API serves nothing but free, public, and
    read-only data, you must secure it.
  </para>
  <para>
    Security consists of three factors, collectively known as the CIA-triad:
  </para>
  <variablelist>
    <varlistentry>
      <term><firstterm>Confidentiality</firstterm></term>
      <listitem>
        <para>
          The extent to which information is shared only with those who are eligible to see it. If confidentiality is
          compromised, we speak of <firstterm>Information Disclosure</firstterm>.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><firstterm>Integrity</firstterm></term>
      <listitem>
        <para>
          The extent to which information can only be added, changed, and removed by authorized agents. If integrity
          is compromised, we speak of <firstterm>Tampering</firstterm>.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term><firstterm>Availability</firstterm></term>
      <listitem>
        <para>
          The extent to which information is accessible to those who need it, when they need it. If availability is
          compromised, we speak of <firstterm>Denial of Service</firstterm> (DoS).
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
  <para>
    In the context of an HTTP-based API, Information Disclosure is a concern for <literal>GET</literal> methods and
    any other methods that return information (see <xref linkend="return-representation"/>). Tampering is applicable
    for <literal>PUT</literal>, <literal>POST</literal>, and <literal>DELETE</literal>. Denial of Service is a 
    concern with all HTTP methods.
  </para>
  <para>
    Security may be compromised by accident or on purpose. In the latter case, we speak of an 
    <firstterm>attack</firstterm>. If security is compromised, we say that a <firstterm>vulnerability</firstterm>
    is <firstterm>exploited</firstterm>, but vulnerabilities may exist even if they are not exploited (yet).
  </para>
  <para>
    There are many different types of vulnerabilities. The <firstterm>Common Weakness Enumeration</firstterm> (CWE) 
    system is a list of vulnerabilities types with identifiers that you can refer to.
  </para>
  <para>
    Vulnerabilities exist for a variety of reasons, which fall broadly into two classes. We may have overlooked
    something during our design, in which case we speak of a <firstterm>design flaw</firstterm>, or we may have
    implemented a sound design in an inappropriate way, in which case we speak of a <firstterm>bug</firstterm>.
    Vulnerabilities are split about evenly between flaws and bugs <citation>McGraw06</citation>, so you really can't
    build a secure system unless you take measures to prevent both categories of vulnerabilities.
  </para>
  <para>
    Not all vulnerabilities are equally severe. The US National Institute of Standards and Technology (NIST) has
    developed a scoring system named <firstterm>Common Vulnerability Scoring System</firstterm>
    <citation>CVSS</citation> to compare the relative severity of vulnerabilities.
    There is an online risk rating tool that calculates the CVSS score based on a number of different aspects.
    These scores range from 0 (no problem at all) to 10 (critical and easy to exploit).
  </para>
  <para>
    You can use CVSS scores to decide which risks are worth protecting against and this chapter will provide you with 
    the tools to do just that. But first we need to figure out what our risks are. For this we'll use a technique 
    called threat modeling.
  </para>

  <section id="threat-modeling">
    <title>Threat Modeling</title>
    <para>
      As with many other non-functional requirements, security is best built in rather than bolted on after the fact
      <citation>McGraw06</citation>.
      Preventing design flaws is the subject of this chapter, while we look at bugs with security implications in
      <xref linkend="implementation"/>. Both activities should be part of a development approach that considers 
      security at every step, what Microsoft calls a <firstterm>Security Development Lifecycle</firstterm> 
      <citation>SDL</citation>.
    </para>
    <para>
      An SDL is a structured approach to building security in. It consists of many activities that we won't cover in
      this book, like providing developers with specific security training. While essential for building secure
      software, these activities are not specific to REST APIs and thus out of scope for the current discussion.
    </para>
    <para>
      What we will cover is the main tool of the design phase of the SDL: threat modeling. This activity will tell you
      what tools from our security toolbox you'll need to employ to guarantee the security of your system.
    </para>
    <para>
      <firstterm>Threat modeling</firstterm> is a design activity where the designer explicitly considers the security
      aspect of the system in four steps <citation>Shostack14</citation>:
    </para>
    <procedure id="tm">
      <title>Threat Modeling</title>
      <step>
        <para>Model the system.</para>
        <para>
          In this step you think about what you're going to build. Since it's the data that we're trying to protect,
          most threat models start by looking at the various ways data flows through the system.
        </para>
        <para>
          The notation that's most often used for this is a diagram called a <firstterm>Data Flow Diagram</firstterm>
          (DFD), which shows the processes, data stores, and data flows between them. We won't be using DFDs here,
          because they contain information about the API's implementation that is beyond the scope of this book, like
          what data stores are used to store resource state.
        </para>
        <para>
          In this book, we're only going to look at security from the API's perspective, but you really should look at
          securing your implementation as well. Security is only as strong as its weakest link, after all.
          There are many good security resources available that you can draw from <citation>McGraw06</citation>, 
          <citation>SDL</citation>.
        </para>
        <para>
          The state diagrams we developed in <xref linkend="state-diagrams"/> are also useful diagrams to build your
          threat model. Each state diagram is developed for one persona and it is important from a security perspective
          to know the various personas and what they should and shouldn't be able to do.
        </para>
        <para>
          More importantly, a state diagram contains transitions, which show the flow of data from client to server
          and/or back. We inventoried the data that flows across the transitions in <xref linkend="design-messages"/>.
        </para>
        <para>
          With the actors, transitions, and messages, we have the basic building blocks for the model of the API, 
          without having to wait for implementation details like we would with a DFD.
        </para>
      </step>
      <step>
        <para>Find threats.</para>
        <para>
          In this step you think about what can go wrong once the system is built. This is where you try to think
          like an attacker. This is often very difficult for designers and developers that haven't had proper training, 
          so you may want to think about bringing in specific expertise.
        </para>
        <para>
          There are a couple of structured approaches to help you discover threats, like STRIDE, attack trees,
          and attack libraries. These approaches will generally give you much better results than simply brainstorming 
          the possible threats.
        </para>
        <para>
          <firstterm>STRIDE</firstterm> is an acronym for the various classes of security threats: Spoofing, Tampering, 
          Repudiation, Information disclosure, Denial of service, and Elevation of privileges. We've already discussed 
          tampering, information disclosure and denial of service.
        </para>
        <para>
          <firstterm>Spoofing</firstterm> occurs when one actor impersonates another. 
          <firstterm>Repudiation</firstterm> is when an actor does something and then can successfully claim that they 
          didn't do it. <firstterm>Elevation of privileges </firstterm> occurs when one actor can operate with the 
          (higher) privileges of another.
          In the STRIDE approach, you check each of the elements in the model against the various classes of threats
          to identify which are applicable.
        </para>
        <para>
          Another way to do threat modeling is by constructing attack trees. An <firstterm>attack tree</firstterm> is
          a tree structure in which the root node represents the attacker's goal, and its children are ways to achieve
          that goal. Each child node can have ever more specific children.
        </para>
        <para>
          The nodes in an attack tree can be combined either by AND or by OR. You'll likely need both, so you need some
          way to visualize the relationship. There currently is no standard way of doing that, unfortunately, so you 
          should document your approach.
        </para>
        <para>
          Attack trees can be visualized as graphic trees, as textual outlines, as mind maps, or even as data 
          structures that computer programs can analyze.
        </para>
        <para>
          Attack trees are an attractive way to visualize threats, but they have some problems as well. The principal
          issue is that it's very hard to determine when your done, since there is no structure like STRIDE to guide 
          you.
        </para>
        <para>
          Of course, nothing is stopping you from using STRIDE to build your attack tree. You could build one attack
          tree per STRIDE category, for instance, and visualize how an attacker could spoof some actor in the system, 
          tamper with some part of the system, etc. 
        </para>
        <para>
          Another way to find threats is through an attack library. An <firstterm>attack library</firstterm> is a
          pre-existing list of threats that somebody else has already made for you. They can be abstract or more 
          concrete and may or may not be applicable to your domain.
        </para>
        <para>
          An attack library is a sort of checklist and it inherits their pros and cons. On the one hand, the library 
          makes sure you won't forget to consider certain threats. On the other, it may give you a false sense of 
          security by suggesting that it's complete. It may or may not be for your situation.
        </para>
        <para>
          Attack libraries will often list remediations (see the next step) for the threats that they list, which can 
          be a good help, especially if you're new to threat modeling.
        </para>
        <para>
          Examples of broadly applicable attack libraries are the OWASP Top 10 and the SANS Top 25 
          <citation>Owasp</citation>, <citation>Sans</citation>. Mature security organizations may have developed their 
          own attack libraries that are more tailored to their situation.
        </para>
      </step>
      <step>
        <para>Address threats.</para>
        <para>
          In this step you treat the identified threats as risks, and you apply your risk management process to handle 
          them. In general, there are four different ways to handle risks:
        </para>
        <variablelist>
          <varlistentry>
            <term>Eliminate</term>
            <listitem>
              <para>
                You change the design or implementation such that the risk goes away completely. This is the best 
                option, but unfortunately often impossible.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mitigate</term>
            <listitem>
              <para>
                You introduce a <firstterm>compensating control</firstterm> to counteract the undesired effects that 
                would occur if the risk materializes. For instance, you can use Transport Layer Security (TLS, see
                <xref linkend="cryptography"/>) to protect information traveling across the Internet from being 
                disclosed or tampered with.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Transfer</term>
            <listitem>
              <para>
                You make the risk someone else's problem. For instance, you could see information disclosure of your
                customer's data as their problem. A customer that doesn't want to live with this risk could then encrypt
                their data (see <xref linkend="cryptography"/>) before they upload it to your system. In other words, 
                the customer mitigates the risk that you transferred onto them using encryption as the compensating 
                control.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Accept</term>
            <listitem>
              <para>
                You simply accept the risk. Life isn't risk free and in many cases we can live with minor risks. Many
                organizations accept the risk of insider threats, for instance, thinking that their employees wouldn't 
                do bad things. The Snowden incident and the massive Sony breach of 2014 are examples that show that such 
                a view is naive in today's world.
              </para>
              <para>
                You can use CVSS scores to unambiguously define what you consider a minor risk. The cut-off score will
                depend on your specific situation and your appetite for risk, or <firstterm>risk tolerance</firstterm>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          In most cases, risk elimination is impossible, and risk mitigation is the preferred option.
          We can use a number of compensating controls for this, most of which fall into the following classes:
        </para>
        <variablelist>
          <varlistentry>
            <term>Encryption</term>
            <listitem>
              <para>
                <firstterm>Encryption</firstterm> is the cryptographic process of encoding messages or information in 
                such a way that only authorized parties can read it.
              </para>
              <para>
                We discuss encryption in <xref linkend="cryptography"/>.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Authentication</term>
            <listitem>
              <para>
                <firstterm>Authentication</firstterm> is the act of verifying the credentials of an entity. In other 
                words, authentication is about establishing someone’s or something's identity, thus protecting against
                spoofing.
              </para>
              <para>
                We discuss authentication in <xref linkend="authentication"/>.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Authorization</term>
            <listitem>
              <para>
                <firstterm>Authorization</firstterm> is the act of granting access to a specific resource. This can be 
                an entire application, or a much smaller piece of functionality. Authorization is also referred to as
                <firstterm>access control</firstterm>. It protects against elevation of privilege.
              </para>
              <para>
                We discuss authorization in <xref linkend="authorization"/>.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Auditing</term>
            <listitem>
              <para>
                <firstterm>Auditing</firstterm> is the act of storing information about who did what when. Auditing is 
                important for proving that somebody did or didnt do something. In other words, it protects against
                non-repudiation.
              </para>
              <para>
                We discuss auditing in <xref linkend="auditing"/>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          It's important to realize that these compensating controls can themselves be attacked, leading to second
          and higher order threats. You should thus not put all your security eggs in one basket, but rather employ a 
          strategy of <firstterm>defense in depth</firstterm>.
        </para>
        <para>
          How far to take this is another trade-off that you need to decide on. On the one hand, you want to protect
          your system as best as you can. On the other hand, you don't want to spend all your resources on securing 
          your system, or else it wouldn't ever get delivered and make you money or accomplish whatever goal you have 
          for it.
        </para>
      </step>
      <step>
        <para>Validate.</para>
        <para>
          In this step you verify that you did a decent job of threat analysis. This is arguably the most difficult 
          step. How can you ever be sure that you captured and mitigated all relevant threats?
        </para>
        <para>
          One way of doing that is to compare your threat model against that of a similar system. Another is to walk 
          someone who wasn't involved in the threat modeling effort through the model and see if they can spot errors 
          and/or omissions. If you're using STRIDE, then another check is to see that you have at least one threat per 
          category.
        </para>
        <para>
        </para>
      </step>
    </procedure>
  </section>

  <section id="cryptography">
    <title>Cryptography</title>
    <para>
      <firstterm>Cryptography</firstterm> is the practice and study of techniques for secure communication in the 
      presence of third parties (called adversaries). One of these techniques is encryption.
    </para>
    <para>
      <firstterm>Encryption</firstterm> is the act of transforming a <firstterm>plain text</firstterm> into a 
      <firstterm>cypher text </firstterm> using a special mathematical function known as a <firstterm>cryptographic
      algorithm</firstterm>. This algorithm takes a special number called a <firstterm>cryptographic key</firstterm>
      and some data (the plain text) as input and transforms (encrypts) it into some output (the cypher text), which
      can be converted back (decrypted) to the original input using the same algorithm and the same or a different key.
    </para>
    <para>
      <firstterm>Symmetric encryption</firstterm> uses a single key to encrypt and decrypt data. Since this key
      unlocks sensitive data, it must be protected itself using a process called <firstterm>key management</firstterm>.
      Since symmetric keys must be kept secret, they are also referred to as <firstterm>secret keys</firstterm>.
    </para>
    <para>
      <firstterm>Asymmetric encryption</firstterm> uses two keys. The first is called the <firstterm>public 
      key</firstterm>, and can be freely shared with anybody. The second one is the <firstterm>private key</firstterm> 
      and must be kept secret, just like an symmetric key. Asymmetric encryption is also referred to as
      <firstterm>public-key cryptography</firstterm>.
    </para>
    <para>
      A <firstterm>public key certificate</firstterm> (also known as a digital certificate) is an electronic document 
      used to prove ownership of a public key. The certificate includes information about the key, information about 
      its owner's identity, and the digital signature (see below) of an entity that has verified that the certificate's 
      contents are correct. If the signature is valid, and the person examining the certificate trusts the signer, then 
      they know they can use the key to communicate with its owner.
    </para>
    <para>
      The signer of a public key certificate is usually a <firstterm>certificate authority</firstterm> (CA), a
      company that charges customers to issue certificates for them. Browsers come with a bunch of pre-installed
      public key certificates of CAs that they trust. These are also known as <firstterm>root certificates</firstterm>, 
      because they can be seen as the root of a tree, where each node in the tree is a certificate that is signed by 
      its parent.
    </para>
    <para>
      Encryption can be applied at different stages.
      When encryption is applied to data that is stored, we speak of encryption of <firstterm>data at rest</firstterm>
      (DARE). This is vital to protect your customer's data, but it is not specific to REST APIs and therefore out of
      scope for this book.
    </para>
    <para>
      When encryption is applied to data that is transmitted to another actor/process, then we speak of encryption of 
      <firstterm>data in transit</firstterm>. The main protocol in this space is <firstterm>Transport Layer 
      Security</firstterm> (TLS), the successor of Secure Sockets Layer (SSL). Combined with HTTP it is known as HTTPS.
    </para>
    <para>
      TLS uses public key certificates for authentication, so that a client knows for sure that it is talking to the
      right server. This is a mitigation against spoofing the server. It's unusual in REST APIs to also authenticate the
      client, since that would require the server to have the certificates for all the clients, creating exactly the
      tight coupling between them that we're trying to avoid by applying the REST architectural style.
    </para>
    <para>
      The TLS protocol starts with a handshake, during which client and server negotiate the encryption algorithm and
      a new symmetric key, which is used to encrypt all traffic from that point forward. See <xref linkend="tls"/> .
      This has two advantages. First, symmetric encryption is much faster than asymmetric. Second, an attacker that has 
      possession of the private key of the server can't read the data if they didn't also intercept the handshake.
    </para>
    <para>
      There are different versions of TLS and its predecessor SSL. All versions of SSL and version 1.0 of TLS are now
      considered insecure, because there are published ways to break these protocols. You should preferrably use 
      version 1.2 (RFC 5246), but version 1.1 (RFC 4346) may be okay too.
    </para>
    <figure id="tls">
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/tls.png" scale="40" align="center"/>
        </imageobject>
      </mediaobject>
      <title>The TLS protocol</title>
    </figure>
    <para>
      As we saw in <xref linkend="caching"/>, messages sent over HTTPS cannot be cached by intermediaries like
      caching proxies. That leaves two places where we can still employ caching: at the beginning and end of the
      encrypted channel. The beginning is the REST client, while the server is the end. Since caches at a single client
      will often suffer from a low cache hit ratio, it is advisable to employ caching proxies at the server after
      termination of the TLS connection. To this end, it is common practice to terminate the TLS connection at the load
      balancer (see <xref linkend="load-balancing"/>) and use plain HTTP connections within the data center.
    </para>
    <para>
      This approach leaves us vulnerable to information disclosure and tampering within the data center. To mitigate 
      the risk of tampering by malicious insiders, we should at the minimum employ auditing (see 
      <xref linkend="auditing"/>), so that we can detect such abuse and hope that the threat of taking corrective 
      action after the fact is enough to deter abuse. This does not protect against information disclosure, however.
      This is one of those situations where you have to choose between performance and security.
    </para>
    <para>
      In the not too distant past, security was thought adequate if TLS (or SSL) was enabled. This is no longer the 
      case. Attacks like HeartBleed, POODLE, and BEAST have shown that, although the TLS protocol itself is secure, many
      implementations of it are not. It's therefore prudent to consider defense in depth and not rely on TLS alone. 
    </para>
    <para>
      <firstterm>Digital signatures</firstterm> are another application of cryptography. A <firstterm>hash 
      function</firstterm> is any function that maps arbitrary length data to data of a fixed length. The output is
      known as a <firstterm>hash</firstterm> or <firstterm>digest</firstterm>.
      A <firstterm>cryptographic hash function</firstterm> is a hash function which is considered practically 
      impossible to invert. In other words, given the output, it's virtually impossible to get back to the input.
    </para>
    <para>
      A well-known example of a cryptographic hash function is MD5, but it is no longer considered secure. A better
      candidate is <firstterm>Secure Hash Algorithm</firstterm>, or SHA. There are two versions of this, SHA-1 and 
      SHA-2. The former is no longer considered secure. SHA-2 is actually a family of six functions, which includes the 
      popular SHA-256 algorithm.
    </para>
    <para>
      To digitally sign a message, you run a cryptographic hash function over the document and then encrypt the
      result with a private key. The result is known as a <firstterm>hash-based message authentication 
      code</firstterm> (HMAC), because it can be used to authenticate the message.
    </para>
    <para>
      To validate the signature, the receiver decrypts the HMAC with the public key, and compares the result with the 
      hash of the message. If the two match, then it's clear that the message was not tampered with, because a 
      different message would have yielded a different hash.
    </para>
    <para>
      Furthermore, the receiver knows for sure that the message was sent by the holder of the private key.
      If the receiver also has a public key certificate that is signed by a party they trust, then the receiver can
      be certain that the message came from the person or organization listed in the certificate.
    </para>
    <para>
      The signing and validation processes are shown in <xref linkend="sign"/>.
      We'll see applications of digital signatures in <xref linkend="http-signatures"/> and <xref linkend="auditing"/>.
    </para>
    <figure id="sign">
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/sign.png" scale="40" align="center"/>
        </imageobject>
      </mediaobject>
      <title>Signing a message and validating the signature</title>
    </figure>
  </section>


  <section id="authentication">
    <title>Authentication</title>
    <para>
      During authentication we verify someone's or something's identity using one or more of the 
      <firstterm>authentication factors</firstterm>:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Something that you know, like a password, PIN, or secret key
        </para>
      </listitem>
      <listitem>
        <para>
          Something that you have, like a mobile phone, a debit or credit card, or a One Time Password generating
          device such as RSA SecureID
        </para>
      </listitem>
      <listitem>
        <para>
          Something that you are, like a fingerprint or an iris image
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Some of these factors are stronger than others. A password, for instance, isn't very secure. Unless forced
      otherwise, many people pick weak passwords like <literal>password1</literal>, which is the most commonly
      used password at the time of writing (it replaced the previous favorite of <literal>password</literal>, so
      that's progress of some sort). Even when people pick strong passwords, they tend to reuse them across
      services, which means that the security of your service can be impacted by the (lack of) security of someone
      else's service!
    </para>
    <para>
      Combining several types of authentication factors makes the authentication process more secure. We speak of
      <firstterm>two-factor authentication</firstterm> if two different factors are used. In practice this is usually 
      something that you know (e.g. a password) and something that you have (e.g. a mobile phone). You'll also see
      this referred to as <firstterm>two-step authentication</firstterm> or more generally as <firstterm>multi-factor
      authentication</firstterm>.
    </para>
    <para>
      Authentication usually relies on some form of cryptography. Machines can be authenticated using public key 
      certificates, as we've seen. Humans are usually authenticated using passwords, which aren't stored in the clear
      but as a digest.
      <footnote>
        <para>
          As a salted digest, to be precise. A salt is random data that is used as an additional input to a hash
          function, so that hashing the same password twice results in two different digests.
        </para>
      </footnote>
    </para>
    <para>
      There are many different authentication methods. We're going to take a detailed look at three broad classes that
      are especially relevant to REST APIs: password-based, signature-based, and token-based authentication.
    </para>

    <section>
      <title>Password-Based Authentication</title>
      <para>
        The simplest forms of authentication for REST APIs are probably Basic and Digest Authentication. Both are 
        so-called <firstterm>schemes</firstterm> of the HTTP Authentication framework defined by RFC 7235
        <citation>HTTP</citation>. The basic flow in this framework is shown in <xref linkend="http-auth"/>.
      </para>
      <figure id="http-auth">
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/http-auth.png" scale="68" align="center"/>
          </imageobject>
        </mediaobject>
        <title>HTTP Authentication</title>
      </figure>
      <para>
        The process starts when the client requests a protected resource. The server will not grant access until the
        client is authenticated and thus returns the <literal>401 Unauthorized</literal> status. This is a bit of
        a misnomer and would have been better called <literal>401 Unauthenticated</literal>.
      </para>
      <para>
        The <literal>401</literal> response has one downside: browsers will hijack it and try to do something with it.
        If you're using an authentication scheme that the browser understands, like Basic authentication, then there is
        no problem. But if you happen to pick something that the browser doesn't understand, then the browser will do
        something undesirable like display a blank page. For this reason, some REST APIs return a <literal>303</literal>
        or <literal>307</literal> status code to redirect the client to a login page, rather than the theoretically more
        appropriate <literal>401</literal>.
      </para>
      <para>
        Along with the <literal>401</literal> response, the server presents one or more 
        <firstterm>challenges</firstterm> in <literal>WWW-Authenticate</literal> headers. A challenge consist of a
        scheme followed by zero or more authentication parameters separated by commas (<literal>,</literal>). 
        Each parameter is a name/value pair separated by an equal sign (<literal>=</literal>).
      </para>
      <para>
        If the server supports multiple schemes, it can return multiple <literal>WWW-Authenticate</literal> headers,
        or it can return just one such header with multiple values separated by commas. We advise to use a single 
        header per scheme, because that's easier for clients to parse and also easier to debug.
      </para>
      <para>
        Authentication parameters are specific to a scheme. The exception is <literal>realm</literal>, which is
        supported by most schemes. Its value indicates the scope of protection. Use this if your server is divided
        into multiple independent security contexts.
      </para>
      <para>
        The next step is for the client to select a challenge and formulate a response to it. For this it uses the
        <literal>Authorization</literal> header. (Another misnomer.)
      </para>
      <para>
        RFC 7235 defines an extension registry for authentication schemes. Its predecessor, RFC 2617, defined two
        schemes: Basic and Digest. These authentication schemes will now each get their own RFC, which at the time of
        writing are still in draft. 
      </para>
      <para>
        <firstterm>Basic authentication</firstterm> transmits credentials as user ID/password pairs, encoded as Base64. 
        You'll need to protect this sensitive information using at least TLS. The user ID is separated from the 
        password by a colon (<literal>:</literal>), so the user ID cannot contain a colon. Basic authentication 
        requires the <literal>realm</literal> parameter.
      </para>
      <para>
        We do not advise the use of Basic authentication for production systems because it isn't secure enough. But 
        since its so simple, and all browsers support it, it can be very useful during development.
      </para>
      <para>
        <firstterm>Digest authentication</firstterm> is more secure than Basic, but also more complex. The 
        <literal>WWW-Authenticate</literal> header contains several parameters used for cryptographic operations that 
        enhance security over Basic authentication.
      </para>
      <para>
        The <literal>nonce</literal> parameter contains a unique value that the server generated and that the client
        must echo back along with a count of how often it has used the nonce. This helps to prevent <firstterm>replay 
        attacks</firstterm>, where an attacker intercepts a request from the client and later sends it to the server
        itself.
      </para>
      <para>
        The <literal>algorithm</literal> parameter contains the name of a cryptographic hash function that the client 
        must use to calculate a digest of the request. The default algorithm is MD5, which shouldn't be used anymore. 
        Pick something more secure, like SHA-256.
      </para>
      <para>
        The client authenticates itself with the server by sending the <literal>Authorization</literal> header with a 
        couple of parameters, including a signature of the nonce, the nonce count, the username, the password, the 
        HTTP method, and the URI <citation>Digest authentication</citation>.
        The server validates the signature using the procedure described in <xref linkend="cryptography"/>. See
        <xref linkend="digest-auth"/>.
      </para>
      <figure id="digest-auth">
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/digest-auth.png" scale="55" align="center"/>
          </imageobject>
        </mediaobject>
        <title>Digest Authentication</title>
      </figure>
      <para>
        Digest authentication is more secure than Basic authentication, but it is more complex and it requires the 
        server to maintain state about the client (the nonce and how often it has been used). This is not good for 
        scalability, as we saw in <xref linkend="performance"/>.
      </para>
      <para>
        Another downside of both Basic and Digest authentication is that they rely on passwords, which means that the 
        server must store them securely. This is not an easy task, as many breaches have demonstrated. Fortunately,
        there are better ways.
      </para>
    </section>

    <section id="http-signatures">
      <title>Signature-Based Authentication</title>
      <para>
        As we saw in <xref linkend="cryptography"/>, signing a message proves both the origin and the integrity of the
        message. Since proof of origin is just a different way of saying proof of identity of the sender of the message,
        we can use digital signatures as a means of authentication.
      </para>
      <para>
        This is what many API providers do, like Amazon Web Services and EMC Atmos. The problem is that each of
        those providers uses their own unique implementation of the same idea.   
        The Signing HTTP Messages draft specification standardizes this approach <citation>HTTP Signatures</citation>.
      </para>
      <para>
        The draft defines a new HTTP Authentication scheme called <literal>Signature</literal> that supports multiple 
        parameters. The <literal>keyId</literal> parameter is required. It indicates the sender, someone or somebody 
        that is associated with a key that the server has stored. The <literal>keyId</literal> is used to look up that 
        key.
      </para>
      <para>
        Another required parameter is <literal>algorithm</literal>. It specifies the digital signature algorithm used
        to sign the message. The draft specification calls for the introduction of a new registry, maintained by IANA, 
        of approved algorithms such as RSA-SHA256. This registry doesn't exist at the time of writing, because the
        specification is still in draft.
      </para>
      <para>
        The optional <literal>headers</literal> parameter specifies which HTTP headers are to be signed (when used in
        <literal>WWW-Authenticate</literal>) or were signed (when used in <literal>Authorization</literal>). The 
        default value is <literal>Date</literal>, which protects against replay attacks. The value of 
        <literal>headers</literal> is a list of quoted header names, separated by a single space.
      </para>
      <para>
        A server may require all clients to sign certain headers, or it may leave out the <literal>headers</literal>
        field. A client must always at least sign the required headers, but may sign more. If the server doesn't
        require any headers, then the specification demands that the client at least sign the <literal>Date</literal>
        header.
      </para>
      <para>
        It's good practice to also include the request target in the signature. This is the HTTP method followed by a 
        space followed by the request path <citation>HTTP</citation>. Use <literal>(request-target)</literal> as the 
        name of the "header" for the request target in the <literal>headers</literal> parameter.
      </para>
      <para>
        The <literal>signature</literal> parameter in <literal>Authorization</literal> contains the base64 encoded 
        signature, which is determined as follows. The client uses the <literal>headers</literal> parameter to form a 
        canonicalized <firstterm>signing string</firstterm>. This signing string is then signed with the key associated 
        with <literal>keyId</literal> and the algorithm corresponding to <literal>algorithm</literal>. The 
        <literal>signature</literal> parameter is then set to the base64 encoding of the signature.
      </para>
      <para>
        The headers in the signing string are normalized to make sure client and server calculate the digest over the
        same string. The lowercased header name is followed by a colon, a space, and the header's value. Multiple 
        header name/value pairs in the signing string are separated by newlines.
      </para>
      <para>
        The encryption part of the signing process may be performed using either a symmetric key or the private key of
        a public/private key pair. We advise to use asymmetric keys, so that in the event the server's database of keys
        gets compromised, you haven't given away any information that attackers can use. The key you store is the public
        key rather than a secret key, after all. (Of course, you must still protect the private keys of the clients, but
        those are not all stored in a single location.)
      </para>
      <para>
        A digital signature not only proves the identity of the sender of a message, but also the integrity of the
        message itself. So even if your TLS connection is compromised, you can still be confident that the message 
        wasn't tampered with. Of course, signing doesn't protect against information disclosure.
      </para>
      <para>
        The major benefits of signature-based authentication are that is doesn't require passwords and that it is
        stateless. In place of the password you have cryptographic keys to protect, but at least people are much less
        likely to reuse them and it's as easy to pick a strong key as it is to pick a weak one.
      </para>
      <para>
        Signature-based authentication suffers from one problem that password-based authentication doesn't, however: it
        is less granular. One normally doesn't issue a new key and key ID for each user that drives the client, so that
        means that signature-based authentication is more suited to machine-machine interaction where the client
        operates with the same permissions irrespective of the user it operates on behalf of. Unfortunately, there are
        many situations where that is not acceptable.
      </para>
    </section>

    <section id="oauth">
      <title>Token-Based Authentication</title>
      <para>
        In traditional web applications, the user logs on once, after which a <firstterm>session</firstterm> is 
        established. The session is identified by some session identifier that is usually stored in a cookie and/or
        query parameter. The server associates the session identifier with the user's attributes.
      </para>
      <para>
        The problem with this approach is that the session that the server stores is state that we rather wouldn't 
        store. An alternative that is much better suited for stateless servers is to use tokens.
      </para>
      <para>
        A <firstterm>token</firstterm>, (also known as <firstterm>ticket</firstterm>) is a piece of data that a server
        generates for a client so that the client can deliver it back to the server as a means of authentication.
        A token cannot easily be guessed or forged because it is cryptographically random. The main difference with a
        session identifier is that a token can store additional information, so that the server doesn't have to. Since 
        the token is sent back and forth between client, you shouldn't store too much information in it.
      </para>
      <para>
        The server generates a token after the client or user has authenticated itself. This separation allows the
        authentication itself to happen outside the server, as long as the server trusts the system that performs the
        authentication. This means we can place the authenticating system near the user, typically in the user's
        company's network, and prevent the user's credentials from traveling over the public Internet.
      </para>
      <para>
        OAuth2 is a framework for authorization protocols built on that idea <citation>OAuth2</citation>.
        It's a <emphasis>framework</emphasis> rather than a single protocol and several protocols have been built on
        top of it. Note that this is a framework for <emphasis>authorization</emphasis> rather than for
        <emphasis>authentication</emphasis>; authentication itself is out of scope of OAuth2. However, since you can't
        do authorization without authentication, using OAuth2 tokens will imply that the user was authenticated. The
        OpenID Connect protocol builds on the OAuth2 framework to handle authentication explicitly, as we will see
        shortly. 
      </para>
      <para>
        OAuth2 defines different types of flows that require different capabilities in the participants. Here are the
        actors that participate in an OAuth2 flow:
      </para>
      <variablelist>
        <varlistentry>
          <term>Resource Owner</term>
          <listitem>
            <para>
              An entity capable of granting access to a protected resource. When the resource owner is a person, it is 
              referred to as an end-user.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>User Agent</term>
          <listitem>
            <para>
              The piece of software that acts on behalf of the Resource Owner. This could be a web browser or a mobile 
              app, for instance.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Client</term>
          <listitem>
            <para>
              An application making requests to protected resources on behalf of the Resource Owner and using their 
              authorization.
            </para>
            <para>
              Note that it depends on perspective what is a client and what a server: an OAuth Client is often a 
              server from the perspective of the User Agent.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Resource Server</term>
          <listitem>
            <para>
              The server hosting the protected resources, capable of accepting and responding to protected resource 
              requests using access tokens.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Authorization Server</term>
          <listitem>
            <para>
              The server issuing access tokens to the client after successfully authenticating the Resource Owner and 
              obtaining authorization. Note that the Authorization Server may leave the actual authentication to an
              external <firstterm>Identity Provider</firstterm> (IdP).
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        Here's how these actors collaborate:
      </para>
      <figure id="oauth-flow">
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/oauth2-flow.png" scale="50" align="center"/>
          </imageobject>
        </mediaobject>
        <title>The OAuth2 Authorization Code Flow</title>
      </figure>
      <para>
        This is a complicated flow, sometimes referred to as the OAuth2 dance, but that complexity buys us a lot too.
      </para>
      <para>
        The Resource Owner authenticates with the Authorization Server, so the Client never gets to see their
        credentials. This means the Client doesn't have to store those credentials, which is quite tricky to get right.
        It also means that the Resource Owner doesn't have to trust a lot of Clients with their credentials, but a 
        (hopefully much) smaller number of Authorization Servers. Some people refer to this phenomenon as 
        <firstterm>social login</firstterm>. One example is a website that allows logging in using Google's or GitHub's
        Authorization Servers.
      </para>
      <para>
        Another advantage is that the Authorization Server asks the Resource Owner whether it should grant the Client
        permission to access the protected resources. The Client can ask for different sets of coarse-grained
        permissions using so-called <firstterm>scopes</firstterm>. A user may grant write access to one Client, for
        example, but only read to another. Or they may grant read access to their email address, but not to their phone
        number.
      </para>
      <para>
        Note that in practice the Client will not work at all if the Resource Owner doesn't grant all requested
        scopes. That leaves the Resource Owner with two bad options to choose from: either don't make use of the
        services the Client provides, or grant all the requested permissions. This is often not much of a choice, but
        at least it's <emphasis>some</emphasis> choice. We see a similar pattern with mobile applications.
      </para>
      <para>
        OAuth2 defines different types of flows. For mobile apps, for instance, the whole redirect dance is very 
        inconvenient. The Resource Owner Password Credentials flow is a simplified flow that is more appropriate for
        this situation. 
      </para>
      <para>
        The end result of all OAuth2 flows is an access token. The Client puts this access token in the
        <literal>Authorization</literal> header to gain access to protected resources. Most implementations follow the
        <firstterm>Bearer Token</firstterm> authentication scheme <citation>RFC 6750</citation>.
      </para>
      <para>
        Just as websites make you log in again after a certain period of time, it's also wise to limit the lifetime of
        a token to reduce the impact of it being compromised (defense in depth). 
        You can easily do that by including information about when the token expires inside the token. 
        For maximum security, you would want to make this period as small as possible, but for human clients it's
        annoying if they have to log in every, say, 15 minutes.
      </para>
      <para>
        To solve this problem, an OAuth2 server issues an additional <firstterm>refresh token</firstterm> that can be
        exchanged for a new token. The token used to access the protected resource is referred to as the
        <firstterm>access token</firstterm> to distinguish it from the refresh token. The refresh token suffers the
        same security risk as the access token, so this arrangement only makes sense if you can protect the refresh
        token better than the access token. For instance, you may send the access token in a cookie to the User Agent,
        but keep the refresh token at the Client as state.
      </para>
      <para>
        If you want to be very secure, you would want to allow the client to tell the server that it will not use the
        token anymore. This is the equivalent of a human user logging out of a web site. This is a bit problematic
        when using a token-based system, since any issued token gains anyone access. There are at least two solutions to
        this problem, but neither is part of the OAuth2 standard.
      </para>
      <para>
        The first way to implement "log out" functionality is to have the server maintain a blacklist of invalid tokens.
        This brings back some of the state that we we're trying to avoid. Whether that is worth the added security
        really depends on your specific situation.
      </para>
      <para>
        Another solution for logging out is to issue yet another token. Let's call this the session token, since it
        indicates the user's session. The session token is stored in a cookie. When the user logs out, the session token
        cookie is removed. Any client that doesn't see the session token will initiate the authentication sequence, even
        if there is a valid access token. This approach depends on all the clients playing nice, so it really only works
        when you control all the clients.
      </para>
      <para>
        One of the protocols built on top of OAuth2 is OpenID Connect <citation>OpenID</citation>. This protocol adds
        authentication to the basic OAuth2 authorization flow through so-called <firstterm>claims</firstterm>, which 
        contain additional information about the authenticated user, like their email address.
      </para>
      <para>
        OpenID Connect can return claims in one of two ways. The Authorization Server can issue an additional token
        called an <firstterm>ID token</firstterm> when it releases the access token. The ID token takes the form of a
        <firstterm>JSON Web Token</firstterm>, which is a compact, URL-safe means of representing claims encoded in a
        JSON object <citation>JWT</citation>.
        Alternatively, the Client can use the access token with the Authorization Server's <literal>UserInfo</literal>
        endpoint to retrieve the ID token.
      </para>
      <para>
        The OpenID Connect specification standardizes a small number of claims, all of which are in the personal user 
        information category. You can add custom claims as well, but not every OpenID compliant Authorization Server
        is required to implement them, so you would be coupling yourself to a particular implementation. That's less of
        a concern for authentication, since you already need to establish a trust relationship: you wouldn't trust just
        anyone to authenticate your users, because that would defeat the whole point of authentication. 
      </para>
      <para>
        As said, OAuth2 defines a number of different authentication flows. Some of these are more secure than others.
        Some are more suitable for clients driven by humans, while others work nicely with autonomous clients.
        Because of this versatility and its wide-spread adoption, we feel that OAuth2 should be the default choice for
        APIs. If you need detailed information about the authenticated user, use OpenID Connect in additional to OAuth2.
        Only pick something else if you really know what you're doing and have good reasons for doing it.
      </para>
    </section>
  </section>

  <section id="authorization">
    <title>Authorization</title>
    <para>
      You can assign permissions directly to users using <firstterm>Access Control Lists</firstterm> (ACLs). An
      ACL specifies all the actions a given user is allowed to perform on a given resource. Of course, for any
      permission assignment to make sense,you need to know the identity of the user. In other words, authorization 
      requires authentication.
    </para>
    <para>
      ACLs work fine for a small number of users. As the number of users grows, you may want to group them into buckets
      of users with the same access control characteristics. You do this by assigning <firstterm>roles</firstterm>
      to them and then assigning permissions to the roles. This approach is known as <firstterm>Role-Based Access 
      Control</firstterm> (RBAC). Roles are usually not so hard to determine. The personas we identified in
      <xref linkend="bdd"/> can be a good start.
    </para>
    <para>
      Our goal with RBAC is to group users based on the level of access that we want to give them. We should segment
      our users into groups in such a way that no one person can do something disastrous on their own. This is known as
      <firstterm>Separation of Duties</firstterm> or <firstterm>Segregation of Duties</firstterm>. It is an important 
      tool in the fight against fraud and accidental errors.
    </para>
    <para>
      In a coffee shop, for example, the cashier enters the order from the customer using a Point-of-Sale (POS)
      device. The POS calculates the total and displays it to the customer. By separating this function from that of
      taking the customer's money, the opportunity for the cashier to ask too much money for a coffee and keep the
      difference is eliminated.
    </para>
    <para>
      RBAC often works quite well, but there are situations in which it breaks down. For example, in the healthcare 
      space there is the concept of a primary care physician (PCP). My PCP can see all of my medical data, so that they
      have a holistic view of my health. Other physicians that treat me may only see parts of my medical history. For
      instance, a urologist probably wouldn't need to know about mental health issues.
    </para>
    <para>
      The problem is that my PCP may not be the PCP for my neighbor, so PCP is not really a role.
      To force this into an RBAC system would require the introduction of many, many roles, a phenomenon known as 
      <firstterm>role explosion</firstterm>. In some systems, the number of roles even exceeds the number of users in 
      the system! This isn't how roles were supposed to work, they were supposed to be groupings of users
      that are easier to manage because there are fewer of them.
    </para>
    <para>
      If you find yourself in a situation where RBAC breaks down, you can make your life easier by transitioning to
      <firstterm>Attribute-Based Access Control</firstterm> (ABAC). In this system, the access control decision is tied 
      not just to the role and protected resource, but to any number of <firstterm>attributes</firstterm>.
      For example, the role would be one attribute, and the patient another. ABAC allows you to make your access
      control policies very fine-grained by combining as many attributes as you need in exactly the way you need them.
    </para>
    <para>
      You can also make your access control policies <firstterm>context-aware</firstterm> by capturing the
      context in attributes. For instance, when I'm bleeding to death on the street after being hit by a car, I would
      want any doctor to see all of my medical data so he can save my life. We could capture that with an emergency
      attribute ("break the glass") and have policies around that that include the obligation to log the access.
    </para>
    <para>
      Other examples of context include the time of day in a policy that only allows access during business hours, the
      device used to access the service, or the strength of authentication (e.g. was two-factor authentication used).
      Maybe we want to give only read access to a sensitive document when you're abroad, or no access at all if your IP
      address indicates you're abroad, while your agenda shows you should be in the country.
    </para>
    <para>
      Whether you use ACLs, RBAC, or ABAC, you should always make sure to give people just enough permissions to
      do their job, but no more. This important principle is known as <firstterm>Least Privilege</firstterm>.
      When used judiciously along with Separation of Duties, you can create very secure systems.
    </para>
    <para>
      The <firstterm>eXtensible Access Control Markup Language</firstterm> specification offers an access control
      architecture, policy language, and request/response protocol <citation>XACML</citation>. XACML can be used
      to implement any access control model, whether it be ACL, RBAC, or ABAC.
    </para>
    <para>
      Whatever your access control model, you should use the identity of the caller to determine how to respond to a
      request. Note that this identity could either be the client program, or the user on behalf of which the client
      performs the request. Either way, you need a way to assign permissions to identities. In the following, we'll use 
      the term <emphasis>user</emphasis>.
    </para>
    <para>
      The server's first job is to see if the user is allowed to perform the request. Is the object identified by 
      the URI even visible? If not you should return <literal>404 Not Found</literal> rather than
      <literal>403 Forbidden</literal>, or else the user will know that the object exists. Consider URIs like
      <literal>/layoffs/2015/remon.sinnema/</literal> to see why that could be an issue.
      Once you've determined that the object is visible, and the action permitted, then the server performs
      the request as usual.
    </para>
    <para>
      The response message requires some attention as well.
      Sometimes a response may consist of different parts that require different permissions. Be careful
      with the granularity of the authorization, so that you don't inadvertantly disclose information
      that you shouldn't.
    </para>
    <para>
      The response contains more than data, however. There are also links and forms to consider. Links
      are easy, since they are just information. You treat them the same as the data and either include
      them or not, based on the user's permissions.
    </para>
    <para>
      If the media type you selected for serializing your messages has a way of serializing forms, then 
      you can treat forms just as links and data. If not, as is the case with HAL, then things become a 
      little trickier.
    </para>
    <para>
      HAL doesn't have any mechanism for serializing forms. Consequently, they must be serialized as
      links. The client must either hard-code what methods are applicable for the given link relation,
      or it must be able to interpret alternative forms of this information, like link hints
      <citation>Link Hints</citation>.
    </para>
    <para>
      Hard-coded methods pose a problem, however. Some method may be applicable for a given link
      relation for some user, but not others. You can't hard-code that information in a client,
      since that would be an <firstterm>authorization bypass</firstterm> vulnerability (CWE-639). The server
      must be responsible for enforcing security.
    </para>
    <para>
      Plain HAL, i.e. without link hints, leaves you little option but to encode the forms into link relations.
      For instance, instead of using the standard <literal>edit</literal> link relation for both updates and deletes,
      you could use <literal>edit</literal> only for updates and introduce an extension link relation
      for deletes.
    </para>
    <para>
      This practice may be okay for your situation, but for systems that require fine-grained permissions,
      it breaks down due to an explosion of link relations. You're much better of with a media type
      that can natively serialize forms.
    </para>
  </section>

  <section id="auditing">
    <title>Auditing</title>
    <para>
      Auditing is the systematic and independent examination of data for a stated purpose. For instance, if you collect, 
      store, and process medical data in the US, you must comply with the Health Insurance Portability and 
      Accountability Act <citation>HIPAA</citation>. The US Department of Health &amp; Human Services may perform an <firstterm>audit</firstterm>
      to verify you have controls in place to ensure compliance with HIPAA.
    </para>
    <para>
      The audit can only be as good as the data on which it is based, so it's crucial to be able to prove that
      the data is correct. There are two aspects to this:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <firstterm>Origin</firstterm> refers to who created the data and how sure we are of that. This requires
          proper authentication.
        </para>
      </listitem>
      <listitem>
        <para>
          <firstterm>Integrity</firstterm> refers to the contents of the data and how sure we are that it hasn't
          been tampered with. This requires proper authorization.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Audits in the brick and mortar world rely heavily on signed documents. <firstterm>Signatures</firstterm>
      identify a person, so they address the origin aspect. Signing a document also implies consent with the
      document's content, which touches on the integrity part. Since paper documents are physical objects, they
      can be stored in a safe location to maintain that integrity.
    </para>
    <para>
      Digital documents are different, since they can easily be copied and modified. To prove their origin and
      integrity, we use digital signatures (see <xref linkend="cryptography"/>).
      By digitally signing an audit record we ensure both its origin and integrity, so we can prove that the audited
      event actually happened as recorded.
    </para>
    <para>
      Auditing is the act of keeping a record of who did what when. This is our primary tool for dealing with
      non-repudiation attacks. A client can no longer claim they didn't do something, because we have audit records to
      prove that they did.
    </para>
    <para>
      Auditing requires a couple of things to be in place. We need proper authentication to ensure we know who is
      performing the actions that we're keeping records of. We also need to make sure that nobody can tamper with the
      audit trail. This is especially important as a mitigation against insider threats, as administrators may have
      access to the audit trail.
    </para>
    <para>
      Even with signed audit records we may still not be out of the woods. We must also protect audit records against
      malicious input that could change the meaning. For instance, if each audit record is stored as a single line in a
      text file, then a message containing a newline may make it look like multiple audit records were written.
      This attack is known as <firstterm>log forging</firstterm>. The mitigating control against this vulnerability is
      to do proper output encoding, as we'll discuss in <xref linkend="output-encoding"/>.
    </para>
    <para>
      With a tamper-proof audit trail in place we can in theory detect malicious activity by insiders. To turn theory
      into practice, we should employ alerting to notify a broad group of administrators when something fishy is going
      on (see <xref linkend="alerting"/>). If you only notify one person, then you put that person in a position of
      power, which could be abused.
    </para>
    <para>
      In some cases, it may make sense to make the audit trail available to clients. That allows them to monitor the
      activities of people on their end and alert on suspicious behavior. If your API serves more than one customer,
      then it is imperative that you only show audit records for the customer requesting the audit trail.
    </para>
    <para>
      What events to audit depends on your API, but there are some general guidelines. Any activity with security 
      implications should be audited. Examples are assigning roles to a user and failed login attempts. Think about
      what you would do with the information, for example, what monitoring you could put in place. Don't collect 
      information that nobody will ever look at, as that has a negative impact on performance and storage costs.
    </para>
    <para>
      Speaking of storage, audit records can easily add up. You will probably want to keep them around for some 
      limited time and then dispose of them. You may be subject to laws and regulations that govern how long you need
      to retain information, so do your homework. Conversely, some laws and regulations may also set an upper bound on
      how long you retain information, effectively forcing you to dispose of it after a certain period.
    </para>
  </section>

  <section id="dos">
    <title>Protecting Against Denial of Service (DoS) Attacks</title>
    <para>
      DoS attacks are a major annoyance, because they are difficult to protect against. The good news is that it takes
      some muscle to perform such an attack and there are no direct rewards. This means only highly motivated people 
      are likely to perform them. Your API may not be deemed important enough to warrant such attention. But as your 
      service becomes more popular, you will find that you will be forced to protect yourself.
    </para>
    <para>
      One solution is to do <firstterm>throttling</firstterm>, also known as <firstterm>rate limiting</firstterm>.
      With this approach you put a limit on the amount of traffic per time unit that you accept from a single source.
      Twitter does this, for example. When the limit is exceeded, you return an error instead of processing the 
      request. You will probably want to use the <literal>403 Forbidden</literal> status.
    </para>
    <para>
      For this scheme to work, you have to be able to correlate requests to the same source. For Twitter's API, that is
      quite easy, as each API request is tied to a registered client through a client API key.
    </para>
    <para>
      For public websites, there is often nothing better than using IP addresses. There are serious problems with this
      approach. First, IP addresses can be spoofed. Second, and more importantly, any serious DoS attack will be a
      <emphasis>distributed</emphasis> DoS attack, where the attacker employs an army of computers against your system,
      often ones that are compromised with malware: a <firstterm>botnet</firstterm>. Each member machine of the botnet
      has its own IP address.
    </para>
    <para>
      So while rate limiting can take some of the pressure off of your servers, it is very much a partial solution 
      against DoS attacks. The only real protection is to literally suck it up, to absorb all the traffic.
    </para>
    <para>
      As we saw in <xref linkend="caching"/>, CDNs serve a large fraction of Internet content today. As such, they are 
      uniquely equipped to absorb large volumes of traffic, and you can use them as mitigation against DoS attacks.
      There are also specialized cloud security services that offer protection against DoS attacks (and more).
    </para>
    <para>
      You don't have to pay for that protection all the time, however. You could simply run your own servers, and only
      switch to route traffic through a cloud security service when you detect an attack. Make sure you're
      capable of automatically detecting an attack and of automatically acting on the detection.
    </para> 
  </section>

  <section>
    <title>Securing RESTBucks</title>
    <para>
      We covered a lot of ground in this chapter. Let's put all this theory into practice by applying it to RESTBucks,
      following procedure "<xref linkend="tm"/>":
    </para>
    <orderedlist>
      <listitem>
        <para>Model the system.</para>
        <para>
          We've already done most of this work in <xref linkend="analysis"/>. Our actors/personas/roles are the
          customer, the cashier, and the barista. Their respective state diagrams are in <xref linkend="sd-customer"/>,
          <xref linkend="sd-cashier"/>, and <xref linkend="sd-barista"/>.
        </para>
      </listitem>
      <listitem>
        <para>Find threats.</para>
        <para>
          At this point we're just listing things that could go wrong, without thinking about the likelyhood
          or what we can do to prevent it from happening. We'll let STRIDE guide us:
        </para>
        <variablelist>
          <varlistentry>
            <term>Spoofing</term>
            <listitem>
              <orderedlist numeration="arabic">
                <listitem>
                  <para>
                    The server could be spoofed, with a malicious server taking payments in RESTBuck's name but not
                    giving out drinks.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    The customer could be spoofed, so that one customer can pretend to be another and pick up their
                    drinks.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    The customer's payment could be spoofed, so that the customer doesn't really give us money for
                    their drinks.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    The drinks could be spoofed, so that the customer doesn't get what she paid for.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    The cashier could be spoofed, giving someone access to the money who shouldn't have this access.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    The barista could be spoofed, giving someone access to drinks who shouldn't have this access.
                  </para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Tampering</term>
            <listitem>
              <orderedlist numeration="arabic" continuation="continues">
                <listitem>
                  <para>
                    An already paid for order or prepared serving could be modified to change the customer, so that the
                    new customer can pick up the drinks.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    An already paid for order could be modified to include additional food or drinks.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A partial payment could be modified to cover the entire amount.
                  </para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Repudiation</term>
            <listitem>
              <orderedlist numeration="arabic" continuation="continues">
                <listitem>
                  <para>
                    A customer could deny having made a payment.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A customer could deny having taken a serving.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A cashier could deny having accepted a payment.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A barista could withhold a serving and then claim to have delivered it to the customer.
                  </para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Information Disclosure</term>
            <listitem>
              <orderedlist numeration="arabic" continuation="continues">
                <listitem>
                  <para>
                    A customer could see another customer's order.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A customer could see another customer's payment.
                  </para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Denial of Service</term>
            <listitem>
              <orderedlist numeration="arabic" continuation="continues">
                <listitem>
                  <para>
                    Customers may order faster than the cashier can handle them, which may result in some orders not
                    being accepted.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    The cashier may add orders to the barista's queue faster than the barista can process them, which
                    may result in some servings not being prepared.
                  </para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Elevation of Privilege</term>
            <listitem>
              <orderedlist numeration="arabic" continuation="continues">
                <listitem>
                  <para>
                    A customer may pick up another customer's serving.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A customer may accept another customer's payment.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A customer may place an order on the barista's queue.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A customer may pop an order off the barista's queue.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A cashier may pop an order off the barista's queue.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A barista may accept a customer's payment.
                  </para>
                </listitem>
                <listitem>
                  <para>
                    A barista may place an order on his queue.
                  </para>
                </listitem>
              </orderedlist>
            </listitem>
          </varlistentry>
        </variablelist>
      </listitem>
      <listitem>
        <para>Address threats</para>
        <para>
          We now need to decide what to do with the above threats. Remember that we can either eliminate, mitigate, 
          transfer, or accept the security risk that each threat poses, in order of preference. Let's go over the 
          threats one by one.
        </para>
        <orderedlist numeration="arabic">
          <listitem>
            <para>
              We'll use TLS, which means the server will be identified by a public key certificate and the client can
              be reasonably sure the server isn't spoofed.
            </para>
          </listitem>
          <listitem>
            <para>
              We don't want to limit our customers to a handfull that we know, so TLS with mutual authentication isn't
              a good idea to mitigate spoofing the customer. We could authenticate them with a password, but that means
              they would have to sign up for our service and sign in every time they want to order something. While
              that's a perfectly fine solution for many online shops, we don't like it for RESTBucks. We think
              that's too much of a hassle for them and, more importantly, too much of a hassle for us to securely
              maintain their passwords.
            </para>
            <para>
              That leaves at least two options that make more sense: social login and a low-tech custom scheme. The
              first would require our customers to sign in with a service like Facebook. There probably isn't
              one that would be acceptible to all customers, so we would have to support a couple of them. Facebook,
              Google, Twitter, and LinkedIn would probably suffice.
            </para>
            <para>
              The other option is a custom scheme like issuing a cookie with a unique customer ID. Actually, it would
              be more of a transaction ID, since a recurring customer would get a new one each time. We could easily
              generate a cryptographically random number and place it in a cookie. The HTTP machinery
              will automatically handle transferring it back and forth. The advantage of this solution is that it
              doesn't require the customer to log in, so it has a lower barrier of entry. The disadvantage is that
              we can't recognize a customer between orders.
            </para>
            <para>
              Both options are valid. Social login is more secure and more future-proof: if at some point we wanted to
              introduce a loyalty program, we'd have to be able to recognize customers between orders. But it's also
              more work to implement and it creates a higher barrier of entry for customers. For this first version of
              our service, we'll go for time to market and thus for the transaction ID solution.
            </para>
          </listitem>
          <listitem>
            <para>
              For this first version of our service, we're only going to accept payment by credit card. We'll use all
              the security features of credit cards (number, expiration, and security code) and rely on an external
              credit card processor to protect against spoofing the payment.
            </para>
          </listitem>
          <listitem>
            <para>
              We can transfer the risk of spoofing the serving to the customer. We assume a customer who doesn't get the
              right serving will complain, and too many complaints for a given barista means that we'll fire him. That 
              should be enough of a deterrent to keep the barista in check.
            </para> 
          </listitem>
          <listitem>
            <para>
              There will only be a small number of known cashiers that we employ, so we have more options to prevent
              spoofing than for customers. First, we can use TLS with mutual authentication to make sure the cashier
              can only do their work from a client with a known public key certificate. That limits access to only
              those people that operate from machines that we control, because we tie the certificate to an IP address.
            </para>
            <para>
              That still means that anybody who walks into our office can act as a cashier. It also means we can't
              distinguish between cashiers. These risks need mitigating as well. So we'll use OAuth2 and have cashiers
              log in to our corporate IdP.
            </para>
          </listitem>
          <listitem>
            <para>
              We prevent spoofing of baristas in exactly the same way as for cashiers.
            </para>
            <para>
              Additionally, our IdP will assign cashiers and baristas to different groups, and we'll release those
              groups as values for a custom OpenID Connect claim called <literal>role</literal>. That will allow us to
              distinguish baristas from cashiers for authorization purposes, without having to specify permissions for
              each individual.
            </para>
          </listitem>
          <listitem>
            <para>
              For orders that have been paid, we won't return a link to update the order. That will not stop malicious
              clients who have cached that link (or guess it), however. To prevent tampering with the customer field of
              a paid order, we'll have to check the payment status before accepting a modification request. If the
              order is already paid for, we'll return <literal>403 Forbidden</literal>. This is another error condition
              that we need to add to <xref linkend="restbucks-errors"/>.
            </para>
          </listitem>
          <listitem>
            <para>
              We use the same mechanism as above to prevent tampering with the items in a paid for order.
            </para>
          </listitem>
          <listitem>
            <para>
              Tampering with partial payments is out of scope for now, since we won't support partial payments in the 
              first version of RESTBucks. We'll keep this one in mind for the future, though.
            </para>
          </listitem>
          <listitem>
            <para>
              To protect against repudiation of payment, we give the customer a receipt and store the information in 
              that receipt in an audit record.              
            </para>
          </listitem>
          <listitem>
            <para>
              To protect against repudiation of being served, we create an audit record when the customer takes her
              serving. 
            </para>
          </listitem>
          <listitem>
            <para>
              The receipt that we give to the customer proves that the cashier received her payment. 
            </para>
          </listitem>
          <listitem>
            <para>
              The audit record for order delivery proves that a barista has delivered the serving to the customer.
              The absence of such a record proves that the barista has <emphasis>not</emphasis> delivered the serving. 
            </para>
          </listitem>
          <listitem>
            <para>
              We use the transaction ID issued for an order to prevent disclosure of other customer's orders. Note that 
              since we issue a new transaction ID for every order, a customer can't see her previous orders.
            </para>
          </listitem>
          <listitem>
            <para>
              We use the transaction ID to prevent disclosue of other customer's payments as well.
            </para>
          </listitem>
          <listitem>
            <para>
              We limit the number of orders that we accept based on how many orders are currently being processed, to
              make sure the expected wait time falls within the tolerances we've set. That means that we'll return
              <literal>503 Service Unavailable</literal> with a <literal>Retry-After</literal> header for orders that
              we reject. This measure keeps the service as a whole running, at the expense of a denial of service for
              the (hopefully few) affected customers. We accept that residual risk; customers are welcome to try again
              later.
            </para>
          </listitem>
          <listitem>
            <para>
              We also set a maximum on the number of orders in the barista's queue. If that maximum is met, we stop
              accepting customers. This gives the baristas a chance to catch up.
            </para>
          </listitem>
          <listitem>
            <para>
              We protect against elevation of privilege for customers using the transaction ID. This prevents them from
              picking up another customer's serving.
            </para>
          </listitem>
          <listitem>
            <para>
              Our system will only let cashiers accept payments. This requires the client to be authenticated using
              our certificate. It also requires the presence of the OpenID Connect <literal>role</literal> claim with
              value <literal>cashier</literal>. Customers can't access our machines, and if they could, they wouldn't
              know the credentials of our cashiers.
            </para>
          </listitem>
          <listitem>
            <para>
              The same measures also protect against a customer placing orders on the barista's queue.          
            </para>
          </listitem>
          <listitem>
            <para>
              And the same measures also protect against a customer popping orders off the barista's queue.          
            </para>
          </listitem>
          <listitem>
            <para>
              And against a cashier popping orders off the barista's queue.
            </para>
          </listitem>
          <listitem>
            <para>
              And against a barista accepting a customer's payment.
            </para>
          </listitem>
          <listitem>
            <para>
              And against a barista placing orders on his queue.
            </para>
          </listitem>
        </orderedlist>
        <para>
          The security features are summarized in <xref linkend="security-features"/>.
        </para>
        <para>
          For defense in depth, we should take a look at threats against these security measures. (This is a game of
          diminishing returns, so at some point we should simply be happy with what we have and declare ourselves done.)
        </para>
        <para>
          TLS is pretty well established; we just need to make sure we use a recent version and strong enough keys.
          OAuth2 is also well established <citation>OAuth2 Security</citation>. We have to be careful with the
          implementation, but we should be safe with something off the shelves, like <citation>Spring Security 
          OAuth</citation>.
          Credit card verification is also a well understood business. We'll outsource that part, because we don't want
          the hassle of PCI-DSS.
        </para>
        <para>
          For the transaction ID we have to make sure we pick something that can't be easily guessed. Any cryptographically
          secure random number generator will do and there are established crypto libraries out there that we can use.
          Since we're storing the transaction ID in a cookie, we need to protect that cookie appropriately, with the
          <literal>Secure</literal> and <literal>HttpOnly</literal> options.
        </para>
        <para>
          We use audit records for non-repudiation. Some situations have to do with cashiers and baristas, and those
          are our employees, with potential access to the systems that we store the audit trail onto. So we'd do well
          to protect our audit trail against these insider threats. For now, we think it suffices to put those systems
          in a separate network segment and install firewall rules that forbid access to them from machines that
          cashiers and baristas can access.
        </para>
      </listitem>
      <listitem>
        <para>Validate</para>
        <para>
          We have at least one threat per STRIDE threat category, so that's a minimum guarantee. We also compared our
          threat model with Microsoft's Retail Threat Model <citation>Msft14</citation> and consulted with a security
          expert.
        </para>
      </listitem>
    </orderedlist>
    <table id="security-features">
      <title>RESTBucks Security Features</title>
      <thead>
        <tr>
          <th>Category</th>
          <th>Feature</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Cryptography</td>
          <td>TLS</td>
        </tr>
        <tr>
          <td>Authentication</td>
          <td>TLS with mutual authentication for cashiers and baristas</td>
        </tr>
        <tr>
          <td></td>
          <td>OAuth2 &amp; OpenID Connect for cashiers and baristas</td>
        </tr>
        <tr>
          <td></td>
          <td>Transaction ID</td>
        </tr>
        <tr>
          <td></td>
          <td>Credit card verification</td>
        </tr>
        <tr>
          <td>Authorization</td>
          <td>Transaction ID</td>
        </tr>
        <tr>
          <td></td>
          <td>Order/payment status</td>
        </tr>
        <tr>
          <td></td>
          <td><literal>role</literal> custom OpenID Connect claim</td>
        </tr>
        <tr>
          <td>Auditing</td>
          <td>Receipt</td>
        </tr>
        <tr>
          <td></td>
          <td>Delivery</td>
        </tr>
        <tr>
          <td>Denial of Service</td>
          <td>Queue size limitation</td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <title>Summary</title>
    <para>
      This chapter deals with an often-overlooked but increasingly important aspect of APIs: their security. An API is
      the entry point to a system and we should lock it down as much as we do the doors and windows of our house. This
      is especially important for APIs that unlock systems over the public Internet.
    </para>
    <para>
      We've now seen how to design APIs that meet the functionality and most important non-functional requirements of
      a system. Before we move our focus to implementing APIs, we want to take a look at some tools that can make the
      life of an API designer easier.
    </para>
  </section>
</chapter>
