<chapter id="security">
  <title>Security</title>
  <para>
    Exposing your data or application through a REST API is a wonderful way to reach a wide audience. The downside of
    a wide audience, however, is that it’s not just the good guys who come looking. Especially publicly available APIs
    risk attracting all kinds of people we'd rather keep out. Unless your API serves nothing but free, public, and
    read-only data, you must secure it.
  </para>
  <para>
    Security consists of three factors, collectively known as the CIA-triad:
  </para>
  <variablelist>
    <varlistentry>
      <term>Confidentiality</term>
      <listitem>
        <para>
          The extent to which information is shared only with those who are eligible to see it. If confidentiality is
          compromised, we speak of <firstterm>Information Disclosure</firstterm>.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Integrity</term>
      <listitem>
        <para>
          The extent to which information can only be added, changed, and removed by authorized agents. If integrity
          is compromised, we speak of <firstterm>Tampering</firstterm>.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Availability</term>
      <listitem>
        <para>
          The extent to which information is accessible to those who need it, when they need it. If availability is
          compromised, we speak of <firstterm>Denial of Service</firstterm> (DoS).
        </para>
      </listitem>
    </varlistentry>
  </variablelist>
  <para>
    In the context of an HTTP-based API, Information Disclosure is a concern for <literal>GET</literal> methods and
    any other methods that return information (see <xref linkend="return-representation"/>). Tampering is applicable
    for <literal>PUT</literal>, <literal>POST</literal>, and <literal>DELETE</literal>. Denial of Service is a 
    concern with all HTTP methods.
  </para>
  <para>
    Security may be compromised by accident or on purpose. In the latter case, we speak of an 
    <firstterm>attack</firstterm>. If security is compromised, we say that a <firstterm>vulnerability</firstterm>
    is <firstterm>exploited</firstterm>, but vulnerabilities may exist even if they are not exploited (yet).
  </para>
  <para>
    Vulnerabilities exist for a variety of reasons, which fall broadly into two classes. We may have overlooked
    something during our design, in which case we speak of a <firstterm>design flaw</firstterm>, or we may have
    implemented a sound design in an inappropriate way, in which case we speak of a <firstterm>bug</firstterm>.
    Vulnerabilities are split about evenly between flaws and bugs <citation>McGraw06</citation>, so you really can't
    build a secure system unless you take measures to prevent both categories of vulnerabilities.
  </para>
  <para>
    Not all vulnerabilities are equally severe. The US National Institute of Standards and Technology (NIST) has
    developed a scoring system named <firstterm>Common Vulnerability Scoring System</firstterm>
    <citation>CVSS</citation> to compare the relative severity of vulnerabilities.
    There is an online risk rating tool that calculates the CVSS score based on a number of different aspects.
    These scores range from 0 (no problem at all) to 10 (critical and easy to exploit).
  </para>
  <para>
    You can use CVSS scores to decide which risks are worth taking on and this chapter will provide you with the tools
    to do just that. But first we need to figure out what our risks are. For this we'll use a technique called threat 
    modeling.
  </para>

  <section id="threat-modeling">
    <title>Threat Modeling</title>
    <para>
      As with many other non-functional requirements, security is best built in rather than bolted on after the fact
      <citation>McGraw06</citation>.
      Preventing design flaws is the subject of this chapter, while we look at bugs with security implications in
      <xref linkend="implementation"/>. Both activities should be part of a development approach that considers 
      security at every step, what Microsoft calls a <firstterm>Security Development Lifecycle</firstterm> 
      <citation>SDL</citation>.
    </para>
    <para>
      An SDL is a structured approach to building security in. It consists of many activities that we won't cover in
      this book, like providing developers with specific security training. While essential for building secure
      software, these activities are not specific to REST APIs and thus out of scope for the current discussion.
    </para>
    <para>
      What we will cover is the main tool of the design phase of the SDL: threat modeling. This activity will tell you
      what tools from our security toolbox you'll need to employ to guarantee the security of your system.
    </para>
    <para>
      <firstterm>Threat modeling</firstterm> is a design activity where the designer explicitly considers the security
      aspect of the system in four steps <citation>Shostack14</citation>. Here's how it works:
    </para>
    <procedure>
      <title>Threat Modeling</title>
      <step>
        <para>Model the system.</para>
        <para>
          In this step you think about what you're going to build. Since it's the data that we're trying to protect,
          most threat models start by looking at the various ways data flows through the system.
        </para>
        <para>
          The notation that's most often used for this is a diagram called a <firstterm>Data Flow Diagram</firstterm>
          (DFD), which shows the processes, data stores, and data flows between them. We won't be using DFDs here,
          because they contain information about the API's implementation that is beyond the scope of this book, like
          what data stores are used to store resource state.
        </para>
        <para>
          In this book, we're only going to look at security from the API's perspective, but you really should look at
          securing your implementation as well. Security is only as strong as its weakest link, after all.
          There are many good security resources available <citation>McGraw06</citation>, <citation>SDL</citation>.
        </para>
        <para>
          The state diagrams we developed in <xref linkend="state-diagrams"/> are useful diagrams to build your
          threat model. Each state diagram is developed for one persona and it is important from a security perspective
          to know the various personas and what they should and shouldn't be able to do.
        </para>
        <para>
          More importantly, a state diagram contains transitions, which show the flow of data from client to server
          and/or back. We inventoried the data that flows across the transitions in <xref linkend="design-messages"/>.
        </para>
        <para>
          With the actors, transitions, and messages, we have the basic building blocks for the model of the API.
        </para>
      </step>
      <step>
        <para>Find threats.</para>
        <para>
          In this step you think about what can go wrong once the system is built. This is where you try to think
          like an attacker. This is often very difficult for developers that haven't had proper training, so you may 
          want to bring in specific expertise.
        </para>
        <para>
          There are also a couple of structured approaches to help you discover threats, like STRIDE, attack trees,
          and attack libraries, that will give you much better results than simply brainstorming the possible threats.
        </para>
        <para>
          STRIDE is an acronym for the various classes of security threats: Spoofing, Tampering, Repudiation,
          Information disclosure, Denial of service, and Elevation of privileges. We've already discussed tampering,
          information disclosure and denial of service.
        </para>
        <para>
          <firstterm>Spoofing</firstterm> occurs when one actor impersonates another. 
          <firstterm>Repudiation</firstterm> is when an actor does something and then can successfully claim that they 
          didn't do it. <firstterm>Elevation of privileges </firstterm> occurs when one actor can operate with the 
          (higher) privileges of another.
          In the STRIDE approach, you check each of the elements in the model against the various classes of threats
          to identify which are applicable.
        </para>
        <para>
          TODO: attack trees
        </para>
        <para>
          TODO: attack libraries
        </para>
      </step>
      <step>
        <para>Address threats.</para>
        <para>
          In this step you treat the identified threats as risks, and you apply your risk management process to
          eliminate, mitigate, transfer, or accept the security risks they pose.
          In general, risks can be handled in the following ways:
        </para>
        <variablelist>
          <varlistentry>
            <term>Eliminate</term>
            <listitem>
              <para>
                You change the design or implementation such that the risk goes away completely. This is the best 
                option, but unfortunately often impossible.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mitigate</term>
            <listitem>
              <para>
                You introduce a <firstterm>compensating control</firstterm> to counteract the undesired effects that 
                would occur if the risk materializes. For instance, you can use Transport Layer Security (TLS, see
                <xref linkend="cryptography"/>) to protect information traveling across the Internet from being 
                disclosed or tampered with.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Transfer</term>
            <listitem>
              <para>
                You make the risk someone else's problem. For instance, you could see information disclosure of your
                customer's data as their problem. A customer that doesn't want to live with this risk could then encrypt
                their data before they upload it to your system. In other words, the customer mitigates the risk
                that you transferred onto them using encryption as the compensating control.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Accept</term>
            <listitem>
              <para>
                You simply accept the risk. Life isn't risk free and in many cases we can live with minor risks. Many
                organizations accept the risk of insider threats, for instance, thinking that their employees wouldn't 
                do bad things. The massive Sony breach of 2014 is testament to the fact that this is a very naive world 
                view.
              </para>
              <para>
                You can use CVSS scores to unambiguously define what you consider a minor risk. The cut-off score will
                depend on your specific situation and your appetite for risk, your <firstterm>risk 
                tolerance</firstterm>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          In most cases, risk elimination is impossible, and risk mitigation is the preferred option.
          We can use a number of compensating controls for this, most of which fall into the following classes:
        </para>
        <variablelist>
          <varlistentry>
            <term>Encryption</term>
            <listitem>
              <para>
                <firstterm>Encryption</firstterm> is the cryptographic process of encoding messages or information in 
                such a way that only authorized parties can read it. We discuss encryption in 
                <xref linkend="cryptography"/>.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Authentication</term>
            <listitem>
              <para>
                <firstterm>Authentication</firstterm> is the act of verifying the credentials of an entity. In other words, 
                authentication is about establishing someone’s identity. We discuss authentication in 
                <xref linkend="authentication"/>.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Authorization</term>
            <listitem>
              <para>
                <firstterm>Authorization</firstterm> is the act of granting access to a specific resource. This can be an 
                entire application, or a much smaller piece of functionality. Authorization is also referred to as 
                <firstterm>access control</firstterm>. We discuss authorization in <xref linkend="authorization"/>.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Auditing</term>
            <listitem>
              <para>
                <firstterm>Auditing</firstterm> is the act of storing information about who did what when. Auditing is 
                important for proving that somebody did or didnt do something.
                We discuss auditing in <xref linkend="auditing"/>.
              </para>
            </listitem>
          </varlistentry>
        </variablelist>
      </step>
      <step>
        <para>Validate.</para>
        <para>
          In this step you verify that you did a decent job of analysis. One way of doing that is to compare your
          threat model against that of a similar system. Another is to walk someone who wasn't involved in the
          threat modeling effort through the model and see if they can spot errors and/or omissions.
        </para>
      </step>
    </procedure>
  </section>

  <section id="cryptography">
    <title>Cryptography</title>
    <para>
      <firstterm>Cryptography</firstterm> is the practice and study of techniques for secure communication in the 
      presence of third parties (called adversaries). One of these techniques is encryption.
    </para>
    <para>
      <firstterm>Encryption</firstterm> is the act of transforming a <firstterm>plain text</firstterm> into a 
      <firstterm>cypher text </firstterm> using a special mathematical function known as a <firstterm>cryptographic
      algorithm</firstterm>. This algorithm takes a special number called a <firstterm>cryptographic key</firstterm>
      and some data (the plain text) as input and transforms (encrypts) it into some output (the cypher text), which
      can be converted back (decrypted) to the original input using the same algorithm and the same or a different key.
    </para>
    <para>
      <firstterm>Symmetric encryption</firstterm> uses a single key to encrypt and decrypt data. Since this key
      unlocks sensitive data, it must be protected itself using a process called <firstterm>key management </firstterm>.
      Since symmetric keys must be kept secret, they are also referred to as <firstterm>secret keys</firstterm>.
    </para>
    <para>
      <firstterm>Asymmetric encryption</firstterm> uses two keys. The first is called the <firstterm>public 
      key</firstterm>, and can be freely shared with anybody. The second one is the <firstterm>private key</firstterm> 
      and must be kept secret, just like an symmetric key. Asymmetric encryption is also referred to as
      <firstterm>public-key cryptography</firstterm>.
    </para>
    <para>
      A <firstterm>public key certificate</firstterm> (also known as a digital certificate) is an electronic document 
      used to prove ownership of a public key. The certificate includes information about the key, information about 
      its owner's identity, and the digital signature (see below) of an entity that has verified that the certificate's 
      contents are correct. If the signature is valid, and the person examining the certificate trusts the signer, then 
      they know they can use the key to communicate with its owner.
    </para>
    <para>
      The signer of a public key certificate is usually a <firstterm>certificate authority</firstterm> (CA), a
      company that charges customers to issue certificates for them. Browsers come with a bunch of pre-installed
      public key certificates of CAs that they trust. These are also known as <firstterm>root certificates</firstterm>, 
      because they can be seen as the root of a tree, where each node in the tree is a certificate that is signed by 
      its parent.
    </para>
    <para>
      Encryption can be applied at different stages.
      When encryption is applied to data that is stored, then we speak of encryption of <firstterm>data at 
      rest</firstterm>. This is vital to protect your customer's data, but it is not specific to REST APIs and
      therefore out of scope for this book.
    </para>
    <para>
      When encryption is applied to data that is transmitted to another actor/process, then we speak of encryption of 
      <firstterm>data in transit</firstterm>. The main protocol in this space is <firstterm>Transport Layer 
      Security</firstterm> (TLS), the successor of Secure Sockets Layer (SSL). When combined with HTTP, we speak of 
      HTTPS.
    </para>
    <para>
      TLS uses public key certificates for authentication, so that a client knows for sure that it is talking to the
      right server. This is a mitigation against the the server being spoofed. It's unusal in REST APIs to also
      authentication the client, as that would require the server to have the certificates for all the clients, 
      creating a tight coupling them.
    </para>
    <para>
      The TLS protocol starts with a handshake, during which client and server negotiate the encryption algorithm and
      a new symmetric key, which is used to encrypt all traffic from that point forward. This has two advantages. First,
      symmetric encryption is much faster than asymmetric. Second, an attacker that has possession of the private key
      of the server can't read the data if they didn't also intercept the handshake. 
    </para>
    <para>
      There are different versions of TLS and its predecessor SSL. All versions of SSL and version 1.0 of TLS are now
      considered insecure, because there are published ways to break these protocols. You should preferrably use 
      version 1.2 (RFC 5246) or else 1.1 (RFC 4346).
    </para>
    <para>
      As we saw in <xref linkend="caching"/>, messages sent over HTTPS cannot be cached by intermediaries like
      caching proxies. That leaves two places where we can still employ caching: at the beginning and end of the
      encrypted channel. The beginning is the REST client, while the server is the end. Since caches at a single client
      will often suffer from a low cache hit ratio, it is advisable to employ caching proxies at the server after
      termination of the TLS connection. To this end, it is common to terminate the TLS connection at the load balancer
      (see <xref linkend="load-balancing"/>) and use plain HTTP connections within the data center.
    </para>
    <para>
      This approach leaves us vulnerable to information disclosure within the data center. To mitigate this risk of
      insider threats, we should at the minimum employ auditing (see <xref linkend="auditing"/>), so that we can
      detect such abuse and hope that the threat of taking corrective action after the fact is enough to deter abuse.
    </para>
    <para>
      <firstterm>Digital signatures</firstterm> are another application of cryptography. A <firstterm>hash 
      function</firstterm> is any function that maps arbitrary length data to data of a fixed length (called a 
      <firstterm>hash</firstterm> or <firstterm>digest</firstterm>).
    </para>
    <para>
      A <firstterm>cryptographic hash function</firstterm> is a hash function which is considered practically 
      impossible to invert. In other words, given the output, it's virtually impossible to get back to the input.
    </para>
    <para>
      One example of a cryptographic hash function is <firstterm>Secure Hash Algorithm</firstterm>, or SHA. There are 
      two versions of this, SHA-1 and SHA-2. The former is no longer considered secure. SHA-2 is actually a family of 
      six functions, which includes the popular SHA-256 algorithm.
    </para>
    <para>
      To digitally sign a message, you run a cryptographic hash function over the document and then encrypt the
      result with a private key. The result is known as a <firstterm>hash-based message authentication 
      code</firstterm> (HMAC), because it can be used to authenticate the message.
    </para>
    <para>
      To validate the signature, the receiver decrypts the HMAC with the public key, and compares the result with the 
      hash of the message. If the two match, then it's clear that the message was not tampered with, because a 
      different message would have yielded a different hash.
    </para>
    <para>
      Furthermore, the receiver knows for sure that the message was sent by the holder of the private key.
      If the receiver also has a public key certificate that is signed by a party they trust, then the receiver can
      be certain that the message came from the person or organization listed in the certificate.
    </para>
    <para>
      The signing and validation processes are shown in <xref linkend="sign"/>.
      We'll see applications of digital signatures in <xref linkend="http-signatures"/> and <xref linkend="auditing"/>.
    </para>
    <figure id="sign">
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/sign.png" scale="40" align="center"/>
        </imageobject>
      </mediaobject>
      <title>Signing a message and validating the signature</title>
    </figure>
  </section>


  <section id="authentication">
    <title>Authentication</title>
    <para>
      During authentication we verify an identity using one or more of the <firstterm>authentication 
      factors</firstterm>:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Something that you know, like a password or secret key
        </para>
      </listitem>
      <listitem>
        <para>
          Something that you have, like mobile phone, a debit or credit card, or a One Time Password generating
          device such as RSA SecureID
        </para>
      </listitem>
      <listitem>
        <para>
          Something that you are, like a fingerprint or an iris image
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Some of these factors are stronger than others. A password, for instance, isn't very secure. Unless forced
      otherwise, many people pick weak passwords like <literal>password1</literal>, which is the most commonly
      used password at the time of writing (it replaced the previous favorite of <literal>password</literal>, so
      that's progress of some sort). Even when people pick strong passwords, they tend to reuse them across
      services, which means that a breach of another service poses a threat to yours.
    </para>
    <para>
      Combining several types of authentication factors makes the authentication process more secure. We speak of
      <firstterm>two-factor authentication</firstterm> if two different factors are used. In practice this is usually 
      something that you know and something that you have. You'll sometimes also see this referred to as
      <firstterm>multi-factor authentication</firstterm> or <firstterm>two-step authentication</firstterm>.
    </para>
    <para>
      Authentication usually uses some form of cryptography. If passwords are used, you shouldn't store them in
      the clear, but rather the result of a <firstterm>cryptographic hash function</firstterm>. This is a one-way
      function, meaning you can turn the password into a digest, but you can't turn the digest back into the
      password. You don't want to implement this yourself, because chances are you'll get it wrong. Use something
      proven that's already out there.
    </para>
    <para>
      Public key cryptography can also be used for authentication, especially of computer programs rather than
      human users. Public key certificates are very usesul to prove the identity of machines or programs, which
      obviously can't enter passwords in login forms.
    </para>

    <section>
      <title>Basic &amp; Digest Authentication</title>
      <para>
        TODO:
      </para>
    </section>

    <section>
      <title>Open ID Connect</title>
      <para>
        TODO:
      </para>
    </section>

    <section id="http-signatures">
      <title>HTTP Signatures</title>
      <para>
        TODO:
      </para>
    </section>

    <section>
      <title>Tickets</title>
      <para>
        Remember that authentication, the act of verifying someone's identity, is the basis for both authorization and
        auditing. This means we must have access to the user's identity for each request. In traditional web 
        applications, the user logs on once, after which a <firstterm>session</firstterm> is established. The session 
        is identified by some session identifier that is usually stored in a cookie. The server associates the session 
        identifier with the user's attributes.
      </para>
      <para>
        The problem with this approach is that the session that the server stores is state that we rather wouldn't 
        store. An alternative that is much better suited for stateless servers is to use tickets.
      </para>
      <para>
        TODO: A <firstterm>ticket</firstterm> is ...
      </para>
    </section>
  </section>

  <section id="authorization">
    <title>Authorization</title>
    <para>
      You can assign permissions directly to users using <firstterm>Access Control Lists</firstterm> (ACLs). An
      ACL specifies all the actions a given user is allowed to perform on a given resource. Of course, for any
      permission assignment to make sense,you need to know the identity of the user. In other words, authorization 
      requires authentication.
    </para>
    <para>
      ACLs work fine for a small number of users. As the number of users grows, you may want to group them into buckets
      of users with the same access control characteristics. You do this by assigning <firstterm>roles</firstterm>
      to them and then assigning permissions to the roles. This approach is known as <firstterm>Role-Based Access 
      Control</firstterm> (RBAC).
    </para>
    <para>
      Roles are usually not so hard to determine. The personas we identified in <xref linkend="bdd"/> are often a good
      start. Our goal is to group users based on the level of access that we want to give them. We should segment
      our users into groups in such a way that no one person can do something disastrous on their own. This is known as
      <firstterm>Separation of Duties</firstterm> or <firstterm>Segregation of Duties</firstterm>. It is an important 
      tool in the fight against fraud and errors.
    </para>
    <para>
      In a coffee shop, for example, the cashier enters the order from the customer using a Point-of-Sale (POS)
      device. The POS calculates the total and displays it to the customer. By separating this function from that of
      taking the customer's money, the opportunity for the cashier to ask too much money for a coffee and keep the
      difference is eliminated.
    </para>
    <para>
      RBAC often works quite well, but there are situations in which it breaks down. Imagine that users can be members 
      of multiple projects, and play different roles depending on the project. RBAC can only model this by creating
      different roles for different projects, e.g. <literal>LEAD_A</literal> and <literal>LEAD_B</literal> for projects 
      A and B, respectively. This becomes unwieldly when the number of projects and the number of roles per project 
      increases, a phenomenon known as <firstterm>role explosion</firstterm>.
    </para>
    <para>
      If you find yourself in a situation where RBAC breaks down, you can make your life easier by transitioning to
      <firstterm>Attribute-Based Access Control</firstterm> (ABAC). In this system, the access control decision is tied 
      not just to the role and protected resource, but to any number of <firstterm>attributes</firstterm>.
      For example, the role would be one attribute, and the project another. ABAC allows you to make your access
      control policies very fine-grained by including as many attributes as you need.
    </para>
    <para>
      You can also make your access control policies <firstterm>context-aware</firstterm> by capturing the
      context in attributes. For instance, the time of day could be an attribute and there could be a policy to
      allow access only during business hours. Other examples of context are the device used to access the
      service or the strength of authentication (e.g. was two-factor authentication used).
    </para>
    <para>
      Whether you use ACLs, RBAC, or ABAC, you should always make sure to give people just enough permissions to
      do their job, but no more. This important principle is known as <firstterm>Least Privilege</firstterm>.
      When used judiciously along with separation of duties, you can create very secure systems.
    </para>
    <para>
      In this chapter we only look at security from the design perspective. We will return to the implementation aspect
      of authorization in <xref linkend="impl-authz"/>.
    </para>

    <section>
      <title>OAuth</title>
      <para>
        TODO:
      </para>
    </section>
  </section>

  <section id="auditing">
    <title>Auditing</title>
    <para>
      The systematic and independent examination of data for a stated purpose. For instance, if you collect, store, and 
      process medical data in the US, you must comply with the Health Insurance Portability and Accountability Act 
      (HIPAA). The US Department of Health &amp; Human Services may perform an <firstterm>audit</firstterm>
      to verify you have controls in place to ensure compliance with HIPAA.
    </para>
    <para>
      The audit can only be as good as the data on which it is based, so it's crucial to be able to prove that
      the data is correct. There are two aspects to this:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <firstterm>Origin</firstterm> refers to who created the data and how sure we are of that. This requires
          proper authentication.
        </para>
        <para>
          <firstterm>Integrity</firstterm> refers to the contents of the data and how sure we are that it hasn't
          been tampered with. This requires proper authorization.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Audits in the brick and mortar world rely heavily on signed documents. <firstterm>Signatures</firstterm>
      identify a person, so they address the origin aspect. Signing a document also implies consent with the
      document's content, which touches on the integrity part. Since paper documents are physical objects, they
      can be stored in a safe location to maintain that integrity.
    </para>
    <para>
      Digital documents are different, since they can easily be copied and modified. To prove their origin and
      integrity, we use digital signatures (see <xref linkend="cryptograhpy"/>).
      By digitally signing an audit record we ensure it origin and integrity, so we can prove that the audited
      event actually happened as recorded.
    </para>
    <para>
      Auditing is the act of keeping a record of who did what when. This is our primary tool for dealing with
      non-repudiation attacks. A client can no longer claim it didn't do something, because we have records to prove
      that it did.
    </para>
    <para>
      Auditing requires a couple of things to be in place. We need proper authentication to ensure we know who is
      performing the actions that we're keeping records of. We also need to make sure that nobody can tamper with the
      audit trail. This is especially important as a mitigation against insider threats, as administrators may have
      access to the audit trail.
    </para>
    <para>
      We can protect our audit trail against tampering by signing it. TODO: elaborate
    </para>
    <para>
      Even with signed audit records we may still not be out of the woods. We must also protect audit records against
      malicious input that could change the meaning. For instance, if each audit record is stored as a single line in a
      text file, then a message containing a newline may cause multiple audit records to be written. This attack is
      known as <firstterm>log forging</firstterm>. The mitigating control against this vulnerability is to do proper
      output encoding, as we'll discuss in <xref linkend="output-encoding"/>.
    </para>
    <para>
      With a tamper-proof audit trail in place we can in theory detect malicious activity by insiders. To turn theory
      into practice, we should employ alerting to notify a broad group of administrators when something fishy is going
      on (see <xref linkend="alerting"/>).
    </para>
    <para>
      TODO: Make audit trail available to client.
    </para>
    <para>
      TODO: What to audit.
    </para>
  </section>

  <section id="dos">
    <title>Protecting Against Denial of Service Attacks</title>
    <para>
      As we saw in <xref linkend="caching"/>, CDNs serve a large fraction of Internet content today. They provide
      the content provider a degree of protection from DoS attacks by using their large distributed server
      infrastructure to absorb the attack traffic.
    </para>
    <para>
      TODO: Throttling, temporarily route traffic through cloud security service
    </para>
  </section>

  <section>
    <title>Securing RESTBucks</title>
    <para>
      Let's applybuild a threat model for RESTBucks. We've already done most of the work for building the model in
      <xref linkend="analysis"/>. Our actors are the customer, the cashier, and the barista. The state diagrams are in
      <xref linkend="sd-customer"/>, <xref linkend="sd-cashier"/>, and <xref linkend="sd-barista"/>.
    </para>
    <para>
      TODO: identify threats &amp; mitigations
    </para>
  </section>
  
  <section>
    <title>Summary</title>
    <para>
      TODO:
    </para>
  </section>
</chapter>
