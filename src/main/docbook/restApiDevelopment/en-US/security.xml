<chapter id="security">
  <title>Security</title>
  <para>
    Exposing your data or application through a REST API is a wonderful way to reach a wide audience. The downside of 
    a wide audience, however, is that it’s not just the good guys who come looking. Especially publicly available APIs
    risk attracting all kinds of people we'd rather keep out. Unless your API serves nothing but free, public, and
    read-only data, you must secure it.
  </para>
  <para>
    Security consists of three factors, collectively known as the CIA-triad:
  </para>
  <variablelist>
    <varlistentry>
      <term>Confidentiality</term>
      <listitem>
        <para>
	        The extent to which information is shared only with those who are eligible to see it. If confidentiality is
	        compromised, we speak of <firstterm>Information Disclosure</firstterm>.
        </para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Integrity</term>
	    <listitem>
	      <para>
		      The extent to which information can only be added, changed, and removed by authorized agents. If integrity is
		      compromised, we speak of <firstterm>Tampering</firstterm>.
	      </para>
	    </listitem>  
    </varlistentry>
    <varlistentry>
      <term>Availability</term>
			<listitem>
			  <para>
				  The extent to which information is accessible to those who need it, when they need it. If availability is 
				  compromised, we speak of <firstterm>Denial of Service</firstterm> (DoS).
			  </para>
			  <para>
			    As we saw in <xref linkend="caching"/>, CDNs serve a large fraction of Internet content today. They provide 
			    the content provider a degree of protection from DoS attacks by using their large distributed server 
			    infrastructure to absorb the attack traffic.
			  </para>
			</listitem>
    </varlistentry>
  </variablelist>
  <para>
    In the context of an HTTP-based API, Information Disclosure is applicable for <literal>GET</literal> methods and 
    any other methods that return information. Tampering is applicable for <literal>PUT</literal>, 
    <literal>POST</literal>, and <literal>DELETE</literal>. Denial of Service is a concern with all HTTP methods.
  </para>
  <para>
    Security may be compromised by accident or on purpose. In the latter case, we speak of an 
    <firstterm>attack</firstterm>. If security is compromised, we say that a <firstterm>vulnerability</firstterm>
    is <firstterm>exploited</firstterm>, but vulnerabilities may exist even if they are not exploited (yet).
  </para>
  <para>
    Vulnerabilities exist for a variety of reasons, which fall broadly into two classes. We may have overlooked 
    something during our design, in which case we speak of a <firstterm>design flaw</firstterm>, or we may have
    implemented a sound design in an inappropriate way, in which case we speak of a <firstterm>bug</firstterm>. 
    Vulnerabilities are split about evenly between flaws and bugs, so you really can't build a secure system unless you 
    deal with both.
  </para>
  <para>
    Not all vulnerabilities are equally severe. The US National Institute of Standards and Technology (NIST) has
    developed a scoring system named <firstterm>Common Vulnerability Scoring System</firstterm> 
    <citation>TODO</citation> to compare relative severity.
    There is an online risk rating tool that calculates the CVSS score based on a number of different aspects. 
    These scores range from 0 (no problem at all) to 10 (extremely severe and very easy to exploit).
    You can use CVSS scores to prioritize your efforts.
  </para>
  
  <section id="threat-modeling">
    <title>Threat Modeling</title>
	  <para>
	    As with many other non-functional requirements, security is best built in rather than bolted on after the fact 
	    <citation>McGraw06</citation>.
	    Preventing design flaws is the subject of this chapter, while we look at bugs with security implications in 
	    <xref linkend="implementation"/>. Both activities should be part of a development approach that considers security
	    at every step, what Microsoft calls a <firstterm>Security Development Lifecycle</firstterm>
	    <citation>SDL</citation>.
	  </para>
	  <para>
	    An SDL is a structured approach to building security in. It consists of many activities that we won't cover in 
	    this book, like providing developers with specific security training. While essential for building secure 
	    software, these activities are not specific to REST APIs. We will, however, look at the main tool in the design 
	    phase of the SDL: threat modeling.
	  </para>
    <para>
      <firstterm>Threat modeling</firstterm> is a design activity where the designer explicitly considers the security
      aspect of the system in four steps <citation>Shostack14</citation>:
    </para>
    <orderedlist>
      <listitem>
        <para>
          Model the system. In this step you think about what you're going to build.
          Since it's the data that we're trying to protect, most threat models start by looking at the various ways
          data flows through the system. The notation that's usually used for this is a diagram called a 
          <firstterm>Data Flow Diagram</firstterm> (DFD), which shows the processes, data stores, and data flows between
          them.
        </para>
        <para>
          State diagrams (see <xref linkend="state-diagrams"/>) contain some of the same information as DFDs, so they 
          can help you get started.  
          TODO: Elaborate.
        </para>
      </listitem>
      <listitem>
        <para>
          Find threats. In this step you think about what can go wrong once the system is built. This is where you try
          to think like an attacker. This is often very difficult for developers that haven't had proper training, so
          you'll probably want to bring in specific expertise.
        </para>
        <para>
          You can use the STRIDE model or attack trees to discover threats. 
          TODO: Elaborate.
        </para>
      </listitem>
      <listitem>
        <para>
          Address threats. In this step you think about potential corrective measures. In the best case scenario, you
          can modify or add to your design in such a way that the threat goes away completely. In other cases, you'll
          have to settle for <firstterm>mitigating</firstterm> threats. 
        </para>
      </listitem>
      <listitem>
        <para>Validate. In this step you verify that you did a decent job of analysis.</para>
      </listitem>
    </orderedlist>


  <!-- TODO -->
  <para>
      The traditional way to do that, is to specify restrictions at the level of URI and HTTP method. For instance, 
      this is the approach that Spring Security takes. The problem with this approach, however, is that both the 
      method and the URI are implementation choices. URIs shouldn’t be known to anybody but the API 
      designer/developer; the client will discover them through link relations. Even the HTTP methods can be hidden 
      until runtime with mature media types like Mason or Siren. This is great for decoupling the client and server, 
      but now we have to specify our security constraints in terms of implementation details! This means only the 
      developers can specify the access control policy.
    </para>
    <para>
      That, of course, flies in the face of best security practices, where the access control policy is externalized 
      from the code (so it can be reused across applications) and specified by a security officer rather than a 
      developer. So how do we satisfy both requirements?
    </para>
    <para>
      The answer lies in the state diagram underlying the REST API. Remember, we want to authorize all transitions. 
      Yes, a transition in an HTTP-based API is implemented using an HTTP method on a URI. But in REST, we shield the 
      URI using a link relation. The link relation is very closely related to the type of action you want to perform.
    </para>
    <para>
      The same link relation can be used from different states, so the link relation can’t be the whole answer. We 
      also need the state, which is based on the representation returned by the REST server. This representation 
      usually contains a set of properties and a set of links. We’ve got the links covered with the link relations, 
      but we also need the properties.
    </para>
    <para>
      In XACML terms, the link relation indicates the action to be performed, while the properties correspond to 
      resource attributes. Add to that the subject attributes obtained through the authentication process, and you 
      have all the ingredients for making an XACML request!
    </para>
    <para>
      There are two places where such access control checks comes into play. The first is obviously when receiving a 
      request. You should also check permissions on any links you want to put in the response. The links that the 
      requester is not allowed to follow, should be omitted from the response, so that the client can faithfully 
      present the next choices to the user.
    </para>
  </section>

  <section id="tls">
    <title>Transport Layer Security</title>
    <para>
    </para>
  </section>
  
  <section id="authentication">
    <title>Authentication</title>
    <para>HTTP signatures, tickets</para>
  </section>

  <section id="authorization">
    <title>Authorization</title>
    <para>RBAC, OAuth, UMA, XACML</para>
  </section>

  <section>
    <title>Auditing</title>
  </section>
  
  <section>
    <title>Summary</title>
  </section>
</chapter>
