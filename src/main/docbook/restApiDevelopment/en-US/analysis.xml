<chapter>
  <title>Analysis</title>
  
  <para>
    In this chapter we will look at the requirements for RESTBucks and how they affect the REST API. We'll look at 
    both functional and non-functional requirements and how to meet them in a way that is pleasant for the consumers of 
    the API.
  </para>
  
  <section>
    <title>Functional Requirements</title>
    <para>
      When people talk about requirements, they often mean <emphasis>functional</emphasis> requirements, or how
      the application is supposed to behave. To understand that, one must first understand the application's
      <firstterm>domain</firstterm>, the subject area to which the user applies the program
      <citation>Evans04</citation>. 
    </para>
    <para>
      We want to capture the domain in a way that is optimized for REST APIs. Since an API exist to be consumed by 
      a client, we should document the domain from the client's point of view.
    </para>
    
    <section>
      <title>Capturing Requirements With State Diagrams</title>
      <para>        
        A REST client starts at some well-known URI, what we called the billboard URI in 
        <xref linkend="uniform-interface"/>. It then follows links (using link relations) until its goal is met.
        In other words, the client starts at some initial state, and then transitions to other states by following 
        links (i.e. executing HTTP methods against URIs) that are discovered from the previously returned 
        representation, as shown in <xref linkend="client"/>.
      </para>
      <para>
        A natural way to capture this information is in the form of a <firstterm>state diagram</firstterm>. 
        State diagrams are used to give an abstract description of the behavior of a system. This behavior is analyzed 
        and represented in a series of events that may occur in one or more states.
      </para> 
      <para>
        Mathematically, a state diagram is a <firstterm>directed graph</firstterm> with the following elements:
      </para>
      <variablelist>
        <varlistentry>
          <term>Vertices</term>
          <listitem>
            <para>
              A finite set of states, normally represented by circles and labeled with unique designator symbols or words 
              written inside them.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Input</term>
          <listitem>
            <para>
              A finite collection of inputs to the system.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Edges</term>
          <listitem>
            <para>
              Transitions between states, triggered by some input. An edge is usually drawn as an arrow directed from 
              the current state to the next state, with the input next to the edge.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Start state</term>
          <listitem>
            <para>
              The start state is sometimes represented by an arrow without origin pointing to the state, but sometimes 
              the start state is shown as as regular state as well.
            </para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Accepting state</term>
          <listitem>
            <para>
              An accepting, final, or end state, is a special state at which the program is allowed to stop processing.
              It is usually drawn as a double circle, but sometimes as a colored circle.
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <figure xml:id="client">
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/client.png" width="10cm" align="center"/>
          </imageobject>
        </mediaobject>
        <title>Basic flow of a REST client</title>
      </figure>
      <para>
        The notion of a state diagram maps nicely onto the flow of a REST client:
      </para>
      <informaltable>
        <thead>
          <tr>
            <th>State diagram element</th>
            <th>REST equivalent</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Vertix</td>
            <td>Application state</td>
          </tr>
          <tr>
            <td>Input</td>
            <td>A link relation or form input</td>
          </tr>
          <tr>
            <td>Edge</td>
            <td>
              A link in a server response that the client can follow. The URI of such a link is discovered 
              by looking for a specific link relation
            </td>
          </tr>
          <tr>
            <td>Start state</td>
            <td>
              The representation returned by the server as the response to a <literal>GET</literal> on the system's 
              billboard URI
            </td>
          </tr>
          <tr>
            <td>Accepting state</td>
            <td>Any state in which the client has achieved a goal</td>
          </tr>
        </tbody>
      </informaltable>
    </section>

    <section>
      <title>State Diagrams for RESTBucks</title>        
      <para>
        Let's apply this little bit of theory to our RESTBucks example.
      </para>
      <para>
        When a customer arrives, she reads the menu, selects a beverage, and orders it. The cashier presents her with 
        the total amount due, and she pays him. The cashier then adds the order to the barista's queue. In time, the 
        barista will pop the order of the queue and prepare it. Once done, he will inform the customer, who takes the 
        order.
      </para>
      <para>
        That's the whole process. Now we have to split that up per actor, since the different actors are each in their
        own states and thus have their own state diagrams. Here's one for the customer:
      </para>
      <figure xml:id="sd-customer-happy-path">
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/sd-customer-happy-path.png" width="15cm"/>
          </imageobject>
        </mediaobject>
        <title>Partial state diagram for RESTBucks customer</title>
      </figure>
      <para>
        The process starts when the customer walks into the store. We'll call this initial state 
        <literal>Arrived</literal>. She then reads the menu to move to the <literal>Deciding</literal> state. There
        she can select items from the menu that she wants to order. This keeps her in the <literal>Deciding</literal> 
        state as long as she hasn't committed to any particular order. At some point, though,
        she'll order with the cashier and move to the <literal>Ordered</literal> state. The cashier will tell her the
        amount due and she'll pay and move to the <literal>Paid</literal> state. She'll take the receipt that the 
        cashier gives here and moves to the <literal>Waiting state</literal>. While she waits, the cashier places the order
        on the barista's queue and at some point the barista pops that order of and prepares it. The customer
        receives a notification from the barista and moves to the <literal>Served</literal> state, where the order is
        ready for her. She then takes the order and leaves the store as a happy customer.
      </para>
      <para>
        Of course, this is just the part of the workflow where everything goes according to plan, the so-called 
        <firstterm>happy path</firstterm> or <firstterm>main success</firstterm> scenario. But a customer can 
        also cancel an order that she hasn't paid for yet or change it:
      </para>
      <figure xml:id="sd-customer">
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/sd-customer.png" width="15cm"/>
          </imageobject>
        </mediaobject>
        <title>Complete state diagram for RESTBucks customer</title>
      </figure>
      <para>
        As you can see, the process is mostly linear for the customer, focused on achieving a single goal: to get her
        coffee. The situation looks a bit different for the cashier and the barista, however. They work in loops, 
        serving one customer after another. Here's the state diagram for the cashier:
      </para>
      <figure xml:id="sd-cashier">
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/sd-cashier.png" width="11cm"/>
          </imageobject>
        </mediaobject>
        <title>State diagram for RESTBucks cashier</title>
      </figure>
      <para>
        The cashier starts his day when the store openes with waiting for the first customer. As some point a customer 
        walks in and the casher accepts her order, moving him to the <literal>Inputing order state</literal> where he
        pushes the correct buttons on the cash register. He then tells the customer the amount due, which puts him in
        the <literal>Awaiting payment</literal> state. When the money comes in, he moves to the <literal>Payment 
        received</literal> state. He gives the customer her receipt. Finally he places the order on the barista's queue
        and turns to the next customer. At the end of his shift, the terminates the process by going home.
      </para>
      <para>
        The state diagram for the barista is a similar loop:
      </para>
      <figure xml:id="sd-barista">
        <mediaobject>
          <imageobject>
            <imagedata fileref="images/sd-barista.png" width="6cm"/>
          </imageobject>
        </mediaobject>
        <title>State diagram for RESTBucks cashier</title>
      </figure>
    </section>
    
    <section>
      <title>Capturing Requirements With Examples</title>
      <para>
        Traditionally, requirements have been captured in text form in requirement documents in a natural language like
        English. One problem with this approach is that natural language is ambiguous, as different people read 
        different things into the same words based on their background and experience.
        One solution to this problem is to make the requirements more concrete by using examples. This is approach is
        very common in the REST community.
      </para>
      <para>
        The Agile software development movement has also embraced examples as concise and precise ways of capturing 
        requirements. This is often referred to as Specification By Example <citation>Adzic09</citation>. It is 
        actually a much more rigorous approach than what we usually see with REST APIs. Let's look at this in a bit
        more detail, and then tie it back to state diagrams.
      </para>
    
	    <section id="bdd">
	      <title>Behavior-Driven Development (BDD)</title>
	      <para>
	        You can capture the information that is embedded in a state diagram in a different form called 
	        <firstterm>Gherkin syntax</firstterm>. Here's what the happy path state diagram for the customer would look 
	        like in Gherkin:
	        <programlisting>
	          Given a customer Chrissy
	          When she reads the menu
	          And she selects a tall whole milk caffe latte
	          And she orders
	          Then she is due $2.75 
	          When she pays
	          Then she is handed a receipt
	          When she takes the receipt
	          Then she must wait for the barista
	          When the barista calls her name
	          Then her order is ready
	          When she takes her order
	          Then she is happy
	        </programlisting>
	      </para>
	      <para>
	        Each line starts with a keyword:
	      </para>
	      <variablelist>
	        <varlistentry>
	          <term><userinput>Given</userinput></term>
	          <listitem>
	             <para>Indicates the current state of the system</para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><userinput>When</userinput></term>
	          <listitem>
	            <para>Indicates the input that transitions the system to a new state</para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><userinput>Then</userinput></term>
	          <listitem>
	            <para>Indicates something that must be true in the new state</para>
	          </listitem>
	        </varlistentry>
	        <varlistentry>
	          <term><userinput>And</userinput></term>
	          <listitem>
	            <para>
	              Is a shorthand for the keyword of the preceding line. It makes the text more natural to read by removing 
	              duplication
	            </para>
	          </listitem>
	        </varlistentry>
	      </variablelist>
	      <para>
	        Since this syntax relies heavily on the keywords <literal>Given</literal>, <literal>When</literal>, and
	        <literal>Then</literal>, it is sometimes also referred to as Given/When/Then.
	      </para>
	      <para>
	        The real power of Given/When/Then is the <userinput>Then</userinput> keyword. It allows us to describe what 
	        state the system <emphasis>should</emphasis> be in. In other words, Gherkin syntax gives us a 
	        <emphasis>testing language</emphasis>. This testing language is the basis for the Agile practice of 
	        Behavior-Driven Development.
	      </para>
	      <para>
	        <firstterm>Behavior-Driven Development</firstterm> (BDD) is one variant of Agile acceptance testing. Much more 
	        than testing, it is a collaborative process where the Product Owner, developers, and testers cooperate to 
	        deliver software that brings value to the business.
	      </para>
	      <para>
	        This process is made possible by the <emphasis>executable</emphasis> requirements that BDD gives use. You 
	        write scenarios in Gherkin format, and they are run by a computer to test whether the system behaves as 
	        desired. This is made possible by a scenario parser that translates the Gherkin syntax into
          method calls in your programming language. For instance, <citation>JBehave</citation> is a BDD framework for 
          Java that contains such a parser. The methods that the parser calls are the glue code between the scenarios 
          and your application. This glue code is where you would call your application's REST API.
        </para>
	      <para>
	        Requirements can be made executable because the scenarios focus on external behavior and use examples with 
	        concrete values. Compare that to the state diagram in <xref linkend="sd-customer-happy-path"/>, which shows 
	        internal states like <literal>Deciding</literal> and uses more abstract terms like <literal>Select from 
	        menu</literal>.
	        We can't know from looking at a state diagram what's on the menu or what is selected in the customer's order.
	        In a BDD scenario, however, everything is spelled out explicitly. The customer orders a latte, for example,
	        rather than a hot tea. These concrete values can be checked by a computer program.
	      </para>
	      <para>
	        Note that the concrete nature of the examples includes providing a name for the customer. This isn't actually
	        necessary for this particular scenario to work, but sometimes it is. Sometimes we want the name to appear in 
	        some record or on some report, so we verify that with a <literal>Then</literal> line.
	      </para>
	      <para>
	        But even if we don't really need the name of the customer, it is still a good idea to include it. It gives
	        us a clear focus on who we are doing this for. Usability experts use the term <firstterm>personas</firstterm> 
	        for fictional characters created to represent the different user types that might use the product in a similar 
	        way. Using the same personas in your BDD scenarios promotes shared understanding.
	      </para>
	      <para>
	        The interesting part about Gherkin syntax is that there are very few constraints. There are only four keywords, 
	        and each line must start with exactly one of them. The rest of the line is completely free format.
	        We don't have to use a computer language, but can simply write in a natural language
	        like English. This means that everybody can read and write scenarios, opening the door for collaboration. This 
	        is a distinctive difference with most forms of automated tests, which can only be read and written by 
	        developers and/or testers. At the same time, the concrete examples prevent us from falling into the ambiguity 
	        trap.
	      </para>
	      <para>
	        BDD scenarios are a great vehicle for promoting the use of the domain language by developers and testers
	        and everybody else who is not a domain expert. When everybody speaks the same language, the chances of 
	        misunderstandings decrease drastically, and thereby the chances of subtle bugs.
	        We refer to that one language as the <firstterm>ubiquitous language</firstterm> <citation>Evans04</citation>.
	      </para>
	      <para>
	        BDD scenarios are great for developers, since they provide quick and unequivocal feedback about whether the 
	        story is done. Not only the main success scenario, but also alternate and exception scenarios can be provided, 
	        as can abuse cases. <firstterm>Abuse cases</firstterm> <citation>McGraw06</citation> describe how the system 
	        should behave when it interacts with someone who wants to use it in inappropriate ways. For instance, someone 
	        might want to get their evil hands on a hot beverage without paying for it.
        </para>
        <para>
	        Adding alternate, exception, and abuse case scenarios requires that the Product Owner collaborates with 
	        testers, developers, and security specialists. The payoff is that it becomes easier to manage all requirements,
	        even security requirements, and build both quality and security in from the start.
	      </para>
      </section>
	      
      <section>
        <title>Deriving State Diagrams From BDD Scenarios</title>
        <para>
          Once we have BDD scenarios in Gherkin syntax, we can translate and merge those into a single state diagram
          that describes the entire system for a particular persona. This gives us a global sense of how we want our 
          system to behave for that type of user, and we may notice some inconsistencies that are difficult to spot 
          when working with the individual scenarios.
        </para>
        <para>
          Remember that this doesn't have to be a Big Design Up Front (BDUF) approach. We can just as easily take one
          scenario and work it all the way through to shippable or even deployed code before we tackle the next scenario.
          The point is that at some point we must integrate all the various requirements that we have into a single 
          system. BDD scenarios can't give you that global overview, but a state diagram can. We don't have to use a
          state diagram either; we could even wait until we write code. But there are advantages to integrating early,
          when it's relatively cheap to change things. Drawing a state diagram is less costly than writing code.
        </para>
        <para>
          To translate Gherkin scenarios into a state diagram, we simply add a state for the <literal>Given</literal>(s). 
          We then add a transition for each <literal>When</literal>, and a target state for each collection of 
          adjacent <literal>Then</literal>s.
        </para>
        <para>
          Note that this doesn't always produce the best end result. You will often want to tweak the state diagram to 
          better support the non-functional requirements, or to give a better developer experience.
          For instance, you may want to make the protocol less chatty by merging transitions to reduce the number of
          network calls, so that you'll get better performance. We'll talk more about non-functional requirements in 
          <xref linkend="non-functional-requirements"/> and about performance in <xref linkend="performance"/>.
        </para>
        <para>
          Let's try out our procedure on the happy path scenario for the customer.
        </para>
        <orderedlist>
          <listitem>
            <para>
              We start by creating a state for <literal>Given a customer Chrissy</literal>.
            </para>
            <note>
              <title>TODO</title>
              <para>should we show the incomplete state diagram as it is built up?</para>
            </note>
          </listitem>
          <listitem>
            <para>
              Next we add a transition for <literal>When she reads the menu</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              The next line is another <literal>When</literal>. We can combine this with the previous transition, or we
              can add a state to the previous transition and then add a transition from this state. We make the choice
              based on whether we can envision there ever being a <literal>Then</literal> in between the
              <literal>When</literal>s. In this case, we could have inserted <literal>Then she is presented with a list of
              beverages, including caffe latte</literal>, so we add a state and a transition.
            </para>
          </listitem>
          <listitem>
            <para>
              The same logic applies to <literal>And she orders</literal>, so we add a state and a transition.
            </para>
          </listitem>
          <listitem>
            <para>
              The line <literal>Then she is due $2.75</literal> invites us to create a state.
            </para>
          </listitem>
          <listitem>
            <para>
              We add another transition for <literal>When she pays</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              And another state for <literal>Then she must wait for the barista</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              Then another transition for <literal>When the barista calls her</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              And finally another state for <literal>Then she takes her order</literal>.
            </para>
          </listitem>
        </orderedlist>
        <para>
          At this point we have successfully recovered the state diagram in <xref linkend="sd-customer-happy-path"/>.
        </para>
        <para>
           Note that the procedure above doesn't tell you how to name the states. This is because the states in the 
           state diagram reflect the customer's <emphasis>internal</emphasis> state, while the BDD scenario only 
           describes the <emphasis>external</emphasis> behavior. The transition names, however, can be derived from the 
           scenario, since they correspond to externally visible behavior.
        </para>
      </section>
	  </section>
  </section>
  
  <section id="non-functional-requirements">
    <title>Non-Functional Requirements</title>
  </section>
  
  <section>
    <title>Developer eXperience</title>
  </section>
  
</chapter>
