<chapter id="client">
  <title>REST Clients</title>
  <!-- TODO: Talk about storing application state -->
  <!-- TODO: Client must be able to handle any status code -->
  <para>
    A <firstterm>REST client</firstterm> uses a REST API to achieve its goals by following the general flow depicted in
    <xref linkend="client-flow"/>. This model is a generalization of the Web, where the client is a browser driven by a
    human. On the web, the human user enters the billboard URI in the brower's address bar and chooses which links to
    follow.
  </para>
  <para>
     The same model can work for REST clients. The billboard URI is hardcoded or, better yet, read from some
    configuration source. But otherwise the process is very much the same. The client renders the server's response and
    allows the user to pick a link from it. This kind of client is also known as a <firstterm>Faithful Hypermedia
    Client</firstterm> <citation>FHC</citation>.
  </para>
  <para>
    The generalized model also allows for the use case of an <firstterm>Autonomous Client</firstterm>, which makes
    decisions without being directly guided by a human. In other words, the program chooses links based on criteria 
    that were coded in.
    As long as we're not talking about true Artificial Intelligence, the human guidance is still there, of course, but
    it's now indirect, in the form of a client developer programming in goals and how to achieve them by following links.
  </para>
  <para>
    Unlike browsers, most REST clients today are specifically built to consume a single API. The main reason for that
    is it's currently extremely difficult to write a client that can handle multiple APIs and do useful work with them.
    There exist some browser-like clients that can consume any level 3 API (see <xref linkend="maturity"/>), but they
    usually don't offer the kind of user experience that is expected today <citation>Siren Browser</citation>.
  </para>
  <para>
    REST clients might become more generic in the future, if more REST APIs move to level 4. It's conceivable that a
    single client could work with multiple APIs in the same domain if it's programmed to understand the semantics of
    that domain.
  </para>
  <para>
    We think the state of the art will firmly remain with dedicated REST clients for the near future. This chapter
    explains how to develop such clients.
  </para>

  <section id="implement-client">
    <title>Implementing Clients</title>
    <para>
      With all the documentation at hand to help out, the next step in building a REST client is to implement the
      general flow of <xref linkend="client-flow"/> for the API at hand. This requires using an SDK or a general
      purpose HTTP client library for your programming language. There are also libraries that support generic REST
      clients at an abstraction level above HTTP.
    </para>
    <para>
      The first step is to retrieve the home resource by issuing a <literal>GET</literal> on the billboard URI. This
       URI is one of those things that may change over time, so it should be stored in the client's configuration
       rather than hardcoded.
    </para>
    <para>
      It's likely that the service is accessible over HTTPS rather than plain HTTP. It may even support both, in which
      case you should pick the safer HTTPS option. Make sure you validate the server's certificate properly (see
      <xref linkend="cryptography"/>) and report any problems you may find with it (see <xref linkend="support"/>).
      Your HTTP library should have documentation on how to handle TLS connections.
    </para>
    <para>
      It's also likely that your client needs to authenticate with the server. As we saw in 
      <xref linkend="authentication"/>, there is an extensible HTTP standard and additional specifications that define
      extensions like Basic and Digest authentication and OAuth2.
    </para>
    <para>
      Many HTTP client libraries will handle Basic and Digest authentication for you, while OAuth2 is usually
      implemented by specific libraries or frameworks <citation>Spring Security OAuth</citation>. Use such libraries or 
      frameworks and only create your own implementation if you absolutely have to. In that case, the Decorator pattern
      is applicable to wrap an authenticating client around a standard client <citation>GammaEtAl94</citation>.
    </para>
    <para>
      If your client requires credentials for authenticating (other then a human user's credentials), then you must
      store that securely. Don't store any credentials in source code, because that makes the credentials hard to
      change. It may also a security risk; there have been documented cases where hackers used credentials they found in
      source code on GitHub to breach systems. 
    </para>
    <para>
      TODO: be more helpful about how to store credentials securely
    </para>
    <para>
      Once the client has connected to the server's billboard URI, it gets a response. This will usually be a home
      resource (see <xref linkend="home"/>) containing nothing but links.
    </para>
    <para>
      While developing your client, it is often useful to compare the responses the client gets from the server with
      those received by another client. This tells you whether you're using the HTTP library or SDK correctly. You can 
      use any kind of client that can handle the types of requests that you have to make.
    </para>
    <para>
      Browsers are unfortunately not very suitable for this purpose, since they support only the <literal>GET</literal>
      and <literal>POST</literal> methods, balk at most authentication schemes, and don't allow you to set headers.
      There are several browser plugins available, however, that let you do all of those things, e.g.
      <citation>Postman</citation>.
    </para>
    <para>
      Once the client has received a response from the server, it must extract data, links, and forms from it.
      This requires the client to parse the media type. For lots of media types there are libraries available that
      unmarshall the response into a programming language object. If there is no such library for the API's media type,
      you can probably get by with a library for a more generic media type. For instance, if you can't find a library
      that handles JSON-LD, you can use one that supports plain JSON. You can use the same library for marshalling
      programming language objects into requests.
    </para>
    <para>
      To make evolution of services easier, clients should follow the <firstterm>must-ignore</firstterm> pattern when
      processing data and links. This means that anything that the client encounters that it doesn't understand should
      be treated as if it weren't there.
    </para>
    <para>
      The opposite of <emphasis>must-ignore</emphasis> is <firstterm>must-understand</firstterm>, where the client
      must raise and error and stop processing when it encounters something it doesn't understand. There is definitely
      a place for <emphasis>must-understand</emphasis>, but in RESTful systems we try to minimize it as much as
      possible because it is a form of tight coupling between client and server.
    </para>
    <para>
      Faithful Hypermedia Clients will render the response and let the user pick a link. The links in the home
      resource are usually rendered as a menu of choices that the user can select from. In the generic case, however,
      a link may also be rendered as a button. For a media type that doesn't support forms, like HAL, a link may
      also be rendered as a form. How the FHC will render a link depends on its understanding of it, as programmed in
      by the client developer. 
    </para>
    <para>
      Autonomous Clients pick a link to follow themselves based on some criteria that were coded in by the client
      developer. They may or may not render responses along the way, but when they do, its usually not in the form of
      HTML, since they require no human interaction to reach their goals.
    </para>
    <para>
      Following a link means issuing a new HTTP request. This means selecting a new HTTP method, a new URI, and
      optionally URI query string parameters and a method body. For a level 3b API, all this information will be in the
      response, and the client can be fairly dumb. For a lower-level API, this information must be programmed in based
      on the link relation and the current URI.
    </para>
    <para>
      For truly RESTful APIs, i.e. level 3a and above, the new URI will be in the response. Actually, the response will 
      contain a <firstterm>URI reference</firstterm> rather than a URI <citation>RFC 3986</citation>. When servers make
      reference to a URI in a response, they do not always use the full or <firstterm>absolute URI</firstterm>. To save
      space and take advantage of hierarchical locality, many servers return an abbreviation of a URI known as a
      <firstterm>relative URI</firstterm>.
    </para>
    <para>
      A relative URI doesn't contain the <firstterm>scheme</firstterm> of a URI. For instance, the scheme of the URI
      <literal>http://www.example.com/foo/</literal> is <literal>http</literal>. An example of a relative URI is
      <literal>/bar/</literal>. A relative reference takes advantage of the hierarchical syntax of URIs to express a URI
      reference relative to the name space of another hierarchical URI.
    </para>
    <para>
      A relative URI can only be turned into an absolute URI by <firstterm>resolving</firstterm> it against another
      absolute URI known as the <firstterm>base URI</firstterm>. The resolution algorithm has some tricky edge cases
      that are hard to get right. Luckily, most programming languages have libraries that implement this algorithm.
      In Java, for instance, resolving URIs works like this: 
    </para>
    <programlisting>import java.net.URI;

URI baseUri = URI.create("http://www.example.com/foo/bar/");
URI resolvedUri = baseUri.resolve("baz/");
assert URI.create("http://www.example.com/foo/bar/baz/")
    .equals(resolvedUri);</programlisting>
    <para>
      The client should use those existing facilities rather than attempting its own implementation, because
      there is a considerable chance that you will get it wrong. Compare the above code with the following, for
      instance:
    </para>
    <programlisting>URI baseUri = URI.create("http://www.example.com/foo/bar");
URI resolvedUri = baseUri.resolve("baz/");
assert URI.create("http://www.example.com/foo/baz/")
    .equals(resolvedUri);</programlisting>
    <para>
      As an aside, this subtle difference is why we recommended always ending URIs in slashes in side bar
      "<xref linkend="uris"/>" in <xref linkend="name-resources"/>.
    </para>
    <para>
      As the client continues getting responses from the server and following link relations, it will usually have to
      build up some internal state to help it along it path to achieving its goal. This is especially true for
      Autonomous Clients.
    </para>
    <para>
      This internal state is known as application state to distinguish it from resource state maintained by the server,
      as we saw in <xref linkend="rest"/>. Application state is built up from the hypermedia responses the client
      receives from the server, a phenomenon known as Hypermedia As The Engine Of Application State (HATEAOS).
    </para>
    <para>
      There are various ways to store application state, like in RAM, in a database, etc. Which method is appropriate
      depends on the situation, but quite often the client can simply maintain data structures in RAM. If you don't
      have any specific requirements about picking up where you left off in a previous session, you should default to
      simply storing state in memory.
    </para>
    <para>
      During the course of a session, the client may have to visit the same resource repeatedly, like the home resource.
      In those situations it may pay to use client-side caching, as discussed in <xref linkend="caching"/>. Many HTTP 
      client libraries implement caching, so if the server follows the standard HTTP caching mechanisms, then you may
      get all this for free. For example, here's how to set up caching with Apache HttpClient:
    </para>
    <programlisting>CacheConfig cacheConfig = CacheConfig.custom()
    .setMaxCacheEntries(1000)
    .setMaxObjectSize(8192)
    .build();
RequestConfig requestConfig = RequestConfig.custom()
    .setConnectTimeout(30000)
    .setSocketTimeout(30000)
    .build();
CloseableHttpClient client = CachingHttpClients.custom()
    .setCacheConfig(cacheConfig)
    .setDefaultRequestConfig(requestConfig)
    .build();</programlisting>
    <para>
      The caching client is a drop-in replacement of a regular HTTP client, thanks to the Decorator pattern. If your
      client doesn't provide caching and you're forced to implement it yourself, then you should definitely use this
      approach as well.
    </para>
    <para>
      Most HTTP libraries will be able to recover from certain errors automatically. For instance, if a network error
      occurs for an idempotent HTTP method (see the sidebar "<xref linkend="http-methods"/>" in
      <xref linkend="maturity"/>), the library may safely retry the request. But most errors you will need to handle
      yourself.
    </para>
    <para>
      The API documentation will tell you what errors to expect, and you should be prepared to handle them. Hopefully
      the documentation will give hints on how to recover from those errors as well. Make sure the client can handle 
      any error, not just the documented ones. You never know when the server is updated, and when (not if) that 
      happens, you don't want to have to rush out a new version of the client to replace the old broken one.
    </para>
    <para>
      The best way to handle errors is to have a central location where they are processed, just as we recommended for
      the server. If your HTTP library has a facility for plugging in a generic error handler for all requests, then
      that's a good place. If not, catch any errors and route them into a central handler yourself. The Decorator
      pattern may be helpful here yet again.
    </para>
    <para>
      A client should always log any errors it encounters. The logs can be used to discover design flaws and
      implementation bugs in the client and aid in correcting them. You may go a step further and log all requests, so
      that they can also useful in debugging performance and scalability issues.
    </para>
    <para>
      A special case is <literal>400 Bad Request</literal>. For an Autonomous Client, this is a logic error and should
      definitely be logged. For Faithful Hypermedia Clients, however, the error is likely caused by a human entering
      invalid data into a form. In that case, logging the error may not be all that helpful.
    </para>
    <para>
      For more information on building REST clients, see <citation>Amundsen15</citation>.
    </para>
  </section>

  <section>
    <title>Resiliency</title>
    <para>
      An important non-functional requirement is resiliency, the ability to continue to function in the face of
      errors. In a loosely coupled system such as one based on the REST architectural pattern, the client should assume 
      as little as much about the server as it can get away with. It shouldn't even assume that the server is always 
      going to be available.
    </para>
    <para>
      The client's options are of course limited when the server isn't available, but one thing it definitely must 
      <emphasis>not</emphasis> do is crash. Imagine your browser crashing everytime you tried to access a non-existing
      URL! A client should be able to degrade functionality gracefully when the server doesn't respond at all, or when 
      it responds in erroneous or unexpected ways.
    </para>
    <para>
      One pattern that helps to solve this problem is the <firstterm>circuit breaker</firstterm>
      <citation>Nygard07</citation>. The basic idea behind the circuit breaker is to wrap an external call in a 
      circuit breaker object, which monitors for failures. Once the failures reach a certain threshold, the circuit 
      breaker closes, and all further calls to the circuit breaker return with an error, without the external call being 
      made at all. You will want to log and monitor it when a circuit breaker closes (see <xref linkend="logging"/>).
    </para>
    <para>
      A closed circuit breaker won't make external calls at first, but after a while it should try one again. If that
      works, the breaker may return itself to the open state. If it still fails, the breaker remains closed.
    </para>
    <para>
      The circuit breaker pattern reduces the load on the troubled server. If the server's troubles were caused by an
      inability to scale to the current load, than reducing the load may be enough to let it recover. If there's
      something more perminent going wrong, then at least reducing calls to it will help the log files from overflowing.
    </para>
    <para>
      The circuit breaker pattern also helps the client. There is no point in repeatedly waiting for a non-responsive
      server. It's much better to fail fast. This is especially important in a microservices architecture, where the
      client may be the server to another client. In such a situation, any delays introduced because of one 
      malfunctioning server may ripple through to many dependent services, taking out the entire cluster of services.
      Circuit breakers limit the total amount of damage.
    </para>
    <para>
      When the circuit breaker is closed the client should provide <firstterm>graceful degragation</firstterm> of its 
      service using a <firstterm>fallback method</firstterm>. There are a couple of options, that may or may not make
      sense for a given situation:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Return an error. This makes sense for a client that acts on behalf of a human user, but not so much for an
          autonomous client. The client lets the user figure out how to proceed. This is often an unsatifactory
          approach for the user, because there is no recovery option offered and the user may not understand the
          underlying problem. User eXperience experts sometimes call this approach <firstterm>passing the
          buck</firstterm> and warn against it.
        </para>
      </listitem>
      <listitem>
        <para>
          If the operation was to look up or calculate an answer, the client might opt to return a default answer.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      TODO: command pattern, Hystrix
    </para>
  </section>  

  <section>
    <title>Summary</title>
    <para>
      This chapter describes the documentation needed to build a REST client, whether that be a Faithful Hypermedia
      Client or an Autonomous Client. We also looked at some general guidelines for implementing REST clients.
    </para>
  </section>
</chapter>
