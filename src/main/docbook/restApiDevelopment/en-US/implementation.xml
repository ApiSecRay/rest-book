<chapter id="implementation">
  <title>Implementation</title>
  
  <section>
    <title>Model-View-Controller (MVC)</title>
  </section>

  <section id="dry">
    <title>Keeping it DRY</title>
    <para>
      TODO: Define URL structure, media type, namespace, error handling, etc. in a single place.
    </para>
    <para>
      Remember from <xref linkend="granularity"/> that the HTTP messages that client and server exchange in a RESTful 
      system are data transfer objects (DTOs).
      You should have exactly one place in your code where you convert your internal DTO to a message that is sent over 
      the wire.
      In JAX-RS, for example, that one place should be an Entity Provider. In Spring, the same mechanism is called a 
      Message Converter. Note that both frameworks have support for several often-used serialization formats.
    </para>
    <para>
      Following this advice not only makes it easier to change media types (e.g. from plain JSON or HAL to a more 
      mature media type like JSON-LD with Hydra). It also makes it easy to support multiple media types. This in turn 
      enables you to switch media types without breaking clients, as we'll see in <xref linkend="breaking-changes"/>.
    </para>
    <para>
      A DTO should not have any behavior; it’s purpose in life is to transfer data between remote systems. This is a
      major difference from a domain object.
      There are two basic approaches for dealing with the data in a DTO. 
    </para>
    <para>
      The first is to make them immutable objects, where all the input is provided in the constructor and the data can 
      only be read. This doesn’t work well for large objects, however, and it doesn’t play nice with serialization 
      frameworks.
    </para>
    <para>
      The better approach is to make all the properties writable. Since a DTO must not have logic, this is one of the 
      few occasions where you can safely make the fields public and omit the getters and setters.
			Of course, that means some other part of the code is responsible for filling the DTO with combinations of 
			properties that together make sense. Conversely, you should validate DTOs that come in from the client. We'll
			show you how in <xref linkend="input-validation"/>.
    </para>
  </section>
  
  <section id="reactive">
    <title>Reactive programming</title>
    <para>
      <firstterm>Reactive programming</firstterm> is an emerging discipline which combines concurrency and 
      event-based and asynchronous systems. It is at the core of many high-performance concurrent systems.
    </para>
  </section>

  <section>
    <title>Generating Code From RADL</title>
  </section>

  <section>
    <title>Extracting RADL From Code</title>
  </section>

  <section id="secure-impl">
    <title>Security</title>
    <section id="impl-authz">
      <title>Authorization</title>
	    <para>
	      The traditional way to implement authorization of REST APIs is to specify restrictions at the level of URI and 
	      HTTP method. For instance, this is the approach that Spring Security takes.
	    </para>
	    <para>
	      There are two places where such access control checks comes into play. The first is obviously when receiving a 
	      request. You should also check permissions on any links you want to put in the response. The links that the 
	      requester is not allowed to follow should be omitted from the response, because the links are supposed to be
	      options that the client can choose from for its next move.
	    </para>
	    <para>
	      The problem with specifying access control in terms of URIs and HTTP methods is that these are implementation 
	      details. 
	      URIs shouldn’t be known to anybody but the API designer/developer; the client will discover them through link 
	      relations. Even the HTTP methods can be hidden until runtime with mature media types like JSON-LD with Hydra.
	      This is great for decoupling the client and server, but now we have to specify our security constraints in terms 
	      of implementation details! This means that only the developers can specify the access control policy.
	    </para>
	    <para>
	      This flies in the face of best security practices, where the access control policy is externalized 
	      from the code (so it can be reused across applications) and specified by a security officer rather than a 
	      developer. So how do we satisfy both requirements?
	    </para>
	    <para>
	      The answer lies in the state diagram underlying the REST API. Remember, we want to authorize all transitions. 
	      Yes, a transition in an HTTP-based API is implemented using an HTTP method on a URI. But in REST, we shield the 
	      URI using a link relation. The link relation is very closely related to the type of action you want to perform.
	    </para>
	    <para>
	      The same link relation can be used from different states, so the link relation can’t be the whole answer. We 
	      also need the state, which is based on the representation returned by the REST server. This representation 
	      usually contains a set of properties and a set of links. We’ve got the links covered with the link relations, 
	      but we also need the properties.
	    </para>
	    <para>
	      The link relation indicates the action to be performed, while the properties correspond to 
	      resource attributes. Add to that the subject attributes obtained through the authentication process, and you 
	      have all the ingredients for making an XACML request.
	    </para>
	    <para>
	      TODO: Think this through. When implementing a controller, we no longer have access to the link relation that
	      led to the method being invoked on the URI...
	    </para>

	    <section>
	      <title>eXtensible Access Control Markup Language</title>
	      <para>
	        TODO:
	      </para>
	    </section>
    </section>
    
    <section id="input-validation">
      <title>Input Validation</title>
    </section>
    
    <section id="output-encoding">
      <title>Output Encoding</title>
    </section>
  </section>
  
  <section id="external">
    <title>Calling external services</title>
    <para>
      TODO: Calling external services. Circuit breakers, etc.
    </para>
  </section>

  <section id="sdk">
    <title>Providing Client Libraries</title>
  </section>

  <section>
    <title>Summary</title>
  </section>
</chapter>
