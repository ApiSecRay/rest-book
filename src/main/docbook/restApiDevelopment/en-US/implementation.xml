<chapter id="implementation">
  <title>Implementation</title>
  <para>
    We now have a design for an API that meets the requirements, causes the least amount of surprise by reusing
    well-known design patterns, is helpful when things go wrong, gives good performance and scalability, and is secure.
    But until we've implemented that design, we don't actually have anything at all. 
    This chapter discusses some important topics to consider while building a REST server.
  </para>
  
  <section id="server-arch">
    <title>Anatomy of a REST Server</title>
    <para>
      There are a number of areas that each REST API implementation must address. Since it's important to separate
      things that change for different reasons <citation>SOLID</citation>, these areas should be implemented by
      different components, as shown in <xref linkend="rest-server"/>.
    </para>
    <figure id="rest-server">
      <title>The components of a REST server</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/rest-server.png" scale="58" align="center"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
      Here's what each of the components is responsible for:
    </para>
    <variablelist>
      <varlistentry>
        <term>HTTP Server</term>
        <listitem>
          <para>
            The HTTP messages that the client sends must be handled somewhere in the server. A socket must be opened on
            the standard ports 80 (for HTTP) and/or 433 (for HTTPS) or on some custom port. Code must listen on these
            ports and speak the HTTP protocol.
          </para>
          <para>
            There isn't any good reason to build this yourself. You should deploy your code to an HTTP server like
            Tomcat or Apache that handles this for you. Alternatively, you can embed an HTTP server like Jetty in your 
            code.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>HTTP Framework</term>
        <listitem>
          <para>
            The HTTP server will speak the HTTP protocol, but it will not implement your resources. You need to extend
            it so that it will call into your code whenever it sees one of the URIs that identify your resources. An
            HTTP framework provides the glue between the HTTP server and the code that implements the resources.
          </para>
          <para>
            This is another component that you should not write yourself. There are plenty of excellent frameworks out
            there that do this for you, like Jersey or Spring WebMVC. Those frameworks make it easy to link URIs to
            your code, for example using simple annotations.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Controllers</term>
        <listitem>
          <para>
            The actual code that handles the HTTP methods on a resource is known as a <firstterm>controller</firstterm>.
            This term comes from the <firstterm>Model-View-Controller</firstterm> (MVC) design pattern
            <citation>GammaEtAl94</citation>.
          </para>
          <para>
            MVC isn't the only possible architecture for a REST server. Similar approaches like hexagonal architecture, 
            clean architecture, ports and adapters, etc., work too. In the following discussion we'll assume MVC, but 
            the main ideas work equally well for any of the other approaches.
          </para>
          <para>
            The "controller" part of MVC binds the data from the model to the presentation in the view and attaches 
            logic from the model to affordances in the presentation. For REST APIs, those affordances are the HTTP
            methods of the uniform interface.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Message converters</term>
        <listitem>
          <para>
            The HTTP server handles most of the HTTP protocol, but not all. The HTTP protocol is extensible, for 
            example, media types define how the content of the HTTP message body is encoded (see
            <xref linkend="media-types"/>).
          </para>
          <para>
            While HTTP servers handle standard media types used on the Web, like <literal>text/html</literal>, they may
            not handle the one(s) you selected for your REST API.
          </para>
          <para>
            The HTTP framework may be able to handle additional media types that are often used in REST APIs, like
            <literal>application/json</literal> and <literal>application/xml</literal>. It does this through
            <firstterm>serialization libraries</firstterm> like JAXB and Jackson. Different frameworks use different
            names for these media type handlers; in this book we'll borrow the term <firstterm>message
            converter</firstterm> from Spring.
          </para>
          <para>
            In addition to providing some default message converters, HTTP frameworks also allow you to register new
            ones to handle unsupported media types. You should use this extensibility feature to write your own message
            converter if needed rather than limit your choice of media type to the selection that the HTTP framework
            offers out of the box. It's usually not all that hard to implement a new message converter based on existing
            ones.
          </para>
          <para>
            Separating out message converters from other code makes it easier to change media types (e.g. from plain
            JSON or HAL to a more mature media type like JSON-LD with Hydra). It also makes it easy to support multiple
            media types. This in turn enables you to switch media types without breaking clients, as we'll see in
            <xref linkend="breaking-changes"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Data transfer objects</term>
        <listitem>
          <para>
            In a REST API, the "view" part of MVC is the data content that is serialized in the body of the HTTP
            message. The message converter translates those bytes, whose meaning is defined by the media type, into a
            programming language object known as a data transfer object (DTO). As we saw in
            <xref linkend="granularity"/>, a DTO is an object that carries data between processes.
          </para>
          <para>
            There are two basic approaches for constructing DTOs. The first is to make them immutable objects, where
            all the input is provided in the constructor and the data can only be read. This doesn’t work well for
            large or deeply nested objects, however, and it doesn’t play nice with serialization frameworks.
          </para>
          <para>
            The better approach is therefore to make all the properties writable. Since a DTO must not have logic, this 
            is one of the few occasions where you can safely make the fields public and omit getters and setters.
          </para>
          <para>
            Of course, that means that some other part of the code is responsible for checking whether individual
            values in the DTO make sense, and whether the different values make sense together. We'll discuss this 
            topic in <xref linkend="input-validation"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Domain objects</term>
        <listitem>
          <para>
            The "model" in the MVC pattern is the domain model. Domain model objects capture the logic of your problem 
            domain in a way that is decoupled from technology like databases and UI <citation>Evans04</citation>.
          </para>
          <para>
            We believe the easiest way to achieve this decoupling is to practice Domain-Driven Design (DDD)
            <citation>Evans04</citation>, where you start out with the domain logic and then add other concerns, like
            persistence and a REST API, around it.
          </para>
          <para>
            Other approaches can work as well. Whatever approach you choose to follow, make sure to separate the domain
            logic from the controllers and clearly distinguish between data transfer objects and domain objects.
          </para>
          <para>
            Data transfer objects transfer data between processes; in this case between a REST client and server. They
            don't have any behavior associated with them; they just exposes data. A domain object, in contrast, is all
            about encapsulating data rather than exposing it. You use domain objects for their behavior rather than
            their data.
          </para>
          <para>
            Domain objects are <emphasis>discovered</emphasis> during analysis, while data transfer objects are
            <emphasis>designed</emphasis> and thus are subject to all kinds of design trade-offs. As we saw in
            <xref linkend="granularity"/>, performance and scalability concerns may prompt us to change the structure
            of our messages in a certain way. That doesn't mean that the problem domain has changed, however, and thus 
            should not lead to changes in the domain objects.
          </para>
          <para>
            So while there is a certain degree of overlap between the data exposed by a data transfer object and that
            encapsulated by a domain object, there isn't necessarily a one-to-one correspondence. It then follows
            that we need to map the DTOs onto domain objects and back.
          </para>
          <para>
            This mapping can be 1:1, and that's the best way to start. But when the need arises to change the message
            structure for performance or other reasons, resist the temptation to modify your domain objects. Instead
            put a mapping layer in place to handles the translation from DTO to domain object and back.
          </para>
          <para>
            Since this mapping is part of binding the "model" (domain) and "view" (data transfer object) parts of MVC,
            the right place to implement it is in the controller.
          </para>
          <para>
            Some frameworks are very easy to work with when the mapping is 1:1, but they get in the way when the mapping 
            becomes more complicated. Again, resist the temptation to go with the tool and change your domain objects.
            Code that matches the domain objects is too valuable to give up: it keeps developers and users on the same
            page and prevents subtle bugs based on misunderstandings <citation>Evans04</citation>.
          </para>
          <para>
            <firstterm>Dependency injection</firstterm> is a design pattern where an object doesn't create or look up
            its dependencies itself, but rather gets told from the outside what they are. One application of this
            pattern is to inject domain objects as dependencies into controllers, so that the controllers can call the
            domain objects to execute business logic.
          </para>
          <para>
            Domain-driven design distinguishes between different kinds of domain objects, like entities (something with
            an identity, such as a person), value objects (something without identity, such as a dollar amount), and
            services (an operation that doesn't conceptually belong in one object, such as paying an order). Like REST
            services, domain services are stateless. They are often injected as dependencies into controllers.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Persistency</term>
        <listitem>
          <para>
            Remember from <xref linkend="rest"/> that state in a RESTful system is separated into application state and
            resource state. Application state is maintained on the client, which we'll discuss in
            <xref linkend="client"/>.
          </para>
          <para>
            Resource state is maintained on the server, so you'll need some sort of database to persist it.
            There are a lot of options for doing so. Traditionally, persistency meant storing data in a relational
            database and that may be the right answer for you today.
          </para>
          <para>
            But if your API is publicly accessible by just about anybody, then you may need a solution that is more
            specifically tailored to that kind of scale, like a NoSql database. There are many options out there, like
            Cassandra, CouchDB, etc., so you'll have to do some homework to pick the right tool for your job.
          </para>
          <para>
            To keep your domain objects independent from your persistency solution, you may want to introduce an
            abstraction known as a <firstterm>Data Access Layer</firstterm> (DAL). The DAL should be captured in a
            technology-independent way, so you can inject it as a dependency into your domain objects without binding 
            the domain model to a specific database technology.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      <xref linkend="rest-server"/> shows the relationships between the components. Components in blue are standard
      components, while those in yellow and red are specific to your project. The difference is that yellow components
      can be generated, as we'll see in <xref linkend="radl-supports-implementation"/>, while red components must be
      hand-coded. Green components may be either standard or project-specific. So in the best case scenario, you only
      have to implement the domain model yourself.
    </para>
    <para>
      For each standard component you can look for the best implementation for your specific situation.
      Alternatively, you can use a suite of components that are proven to work well together. An example of the latter
      for Java is offered by the Spring community:
    </para>
    <itemizedlist>
      <listitem>
        <para>
         The <citation>Spring WebMVC</citation> project lets you build REST controllers by adding annotations to your
         POJOs. It comes with some predefined message converters, like for <literal>application/json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring HATEOAOS</citation> project adds support for link relations and a message converter for
          <literal>application/hal+json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring Hydra</citation> community contribution adds support for actions and semantics, and a
          message converter for <literal>application/ld+json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring Data</citation> project adds support for a Data Access Layer.
        </para>
      </listitem>
      <listitem>
        <para>
          Finally, Spring's dependency injection glues everything together <citation>Spring Platform</citation>.
          For instance, you can use annotations to automatically wire controllers to domain services.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We'll use Spring in the remainder of this chapter, but the ideas carry over very well to other Java frameworks
      (like JAX-RS) and other programming languages.
    </para>
  </section>
  
  <section id="controller">
    <title>Controllers</title>
    <para>
      An important principle in software development is <firstterm>Don't Repeat Yourself</firstterm> (DRY). If every
      concept is expressed in only one place, then you only need to update one place when changes are required. If you
      distribute a concept over multiple places, then you your maintenance burden goes up and your future productivity
      down.
    </para>
    <para>
      If you clearly distinguish the components described in the previous section, you're already in a good position,
      but there is more you can do. The domain model is a good example: every concept from the problem domain should be
      captured in one place in the code (e.g. in one class).
    </para>
    <para>
      The DRY guideline is helpful in controllers as well. Controllers bind code to resources and media types.
      For instance, the following code snippet uses the Spring <literal>@RequestMapping</literal> annotation to specify
      which media type to use as the <literal>Content-Type</literal> of the response:
    </para>
    <programlisting>@RequestMapping(method = RequestMethod.GET,
    produces = { "application/ld+json" })
public HomeDto get() {
  return new HomeDto();
}</programlisting>
    <para>
      This looks fine in isolation, but if you code all your controllers like this, the string
      <literal>"application/ld+json"</literal> will be all over the place. It's better to use a constant instead, e.g.
      <literal>produces = { Api.MEDIA_TYPE_APPLICATION_LD_JSON }</literal>.
      Here we've created a new <literal>Api</literal> class to hold a constant for the media type. We'll get back to
      that class later.
    </para>
    <para>
      If you've selected a media type for which your HTTP framework has native support, then you probably can use a
      constant defined by the HTTP framework rather than your own. For instance, Spring has a
      <literal>MediaType</literal> class with constants for basic media types like
      <literal>application/json</literal>.
    </para>
    <para>
      Imagine what would have to happen if we were to change media type. We'd introduce a new constant for the new 
      media type and we'd still have to go in and update all our controllers. We could ease our pain by using a
      refactoring tool to rename the constant, but we'd still end up with changes in all our controller classes.
    </para>
    <para>
      We can prevent that by introducing another layer of indirection:
    </para>
    <programlisting>String MEDIA_TYPE_DEFAULT = MEDIA_TYPE_APPLICATION_LD_JSON;
String MEDIA_TYPE_APPLICATION_LD_JSON = "application/ld+json";</programlisting>
    <para>
      We can now use <literal>produces = { Api.MEDIA_TYPE_DEFAULT }</literal> in our controllers, and
      they won't need to change if we decide to use a different media type.
    </para>
    <para>
      The use of media types is only one example of where we can apply the DRY principle. You should do something
      similar for URLs, namespaces (if you use XML-based media types), link relations, error constants, etc.
    </para>
    <para>
      Some of the identifiers in that list are part of your API, like link relations, while others are implementation
      choices, like the URLs used to identify resources. Don't put all of these in the same location, because they will
      change for different reasons.
    </para>
    <para>
      In the example above, we've put the constants for the media types in a class called <literal>Api</literal>. You
      can make this class the home of all identifiers that are part of your API. That makes it possible to publish the
      <literal>Api</literal> class somewhere where clients can consume it. This is actually the beginning of a Software
      Development Kit (SDK)! We'll talk more about that in <xref linkend="sdk"/>.
    </para>
    <para>
      We just said that URLs are implementation choices, but there is one exception: the billboard URI. The constant
      for this URL should therefore be part of the <literal>Api</literal> class rather than the internal class that
      contains the other URLs.
    </para>
    <para>
      Since URLs are hierarchical in nature, we can apply the DRY principle to them by defining one URL constant in
      terms of another:
    </para>
    <programlisting>String URL_ORDERS = "/orders/";
String URL_ORDER = URL_ORDERS + "{id}/";</programlisting>
    <para>
      Sometimes duplication is a little harder to spot. A common place in REST servers where this happens is with error
      handling code. It's tempting to catch exceptions in your controllers and translate them to appropriate status
      codes there, but it's better to do that in a central location. Without such centralization, you run the risk of
      handling exceptions inconsistently.
    </para>
    <para>
      Different HTTP frameworks support this in different ways. For example, in Spring you can use a combination of the
      <literal>@ControllerAdvice</literal> and <literal>@ExceptionHandler</literal> annotations to centralize exception
      handling:
    </para>
    <programlisting><![CDATA[public class NotFoundException extends RuntimeException {
  super("http://errors.restbucks.com/not-found");
}

public class MissingItemException extends IllegalArgumentException {
  super("http://errors.restbucks.com/missing-item");
}

public class UnknownItemException extends IllegalArgumentException {
  super("http://errors.restbucks.com/unknown-item");
}

// Other exception classes ...


@ControllerAdvice
public class CentralErrorHandler {

 @ExceptionHandler({ NotFoundException.class })
 public ResponseEntity<String> notFound(Exception e) {
  return new ResponseEntity<>(e.getMessage(), HttpStatus.NOT_FOUND);
 }
       
 @ExceptionHandler({ IllegalArgumentException.class })
 public ResponseEntity<String> illegalArgument(IllegalArgumentException e) {
  return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);
 }
 
 // Other exception handlers...
}]]></programlisting>
    <para>
      As the above example shows, it makes sense to define custom exception classes for each of the API's error
      conditions (see <xref linkend="error"/>). You should not, however, define new exceptions for cases that are
      already covered by standard exceptions. For instance, in Java <literal>IllegalArgumentException</literal> covers
      the <literal>400 Bad Request</literal> status, and <literal>IllegalStateException</literal> covers
      <literal>500 Internal Server Error</literal>.
    </para>
    <para>
      The central error handler maps exception classes onto HTTP status codes and translates them to something that can
      be serialized as an HTTP response body. In the example above that is a simple message string, but you serve your
      clients better by more structured messages with additional details that can help the client recover, as we
      discussed in <xref linkend="serialize-errors"/>. This is relatively straightforward:
    </para>
    <programlisting><![CDATA[public class ErrorDto {
  public String type;
  public String title;
  // Any more fields you want to return to the client, like details
}

@ControllerAdvice
public class CentralErrorHandler {

 @ExceptionHandler({ NotFoundException.class })
 public ResponseEntity<ErrorDto> notFound(Exception e) {
   ErrorDto error = new ErrorDto();
   error.type = "http://errors.restbucks.com/not-found";
   error.title = "The URI you requested doesn't exists or is not accessible by you.";
  return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
 }]]></programlisting>
    <para>
      This example shows how easy it is with Spring to return a data transfer object (DTO): you just declare a class
      with properties and Spring's message converters take care of the rest. If you're not using Spring, you may need
      to do some extra work. For instance, with JAXB you add some annotations on the DTO's fields so that the JAXB
      (un)marshaller can properly (de)serialize them <citation>JAXB</citation>.
    </para>
    <para>
      As we saw earlier, the properties of a DTO can be regular JavaBeans properties (private fields with accessors and
      mutators), or they can simply be public fields. A DTO doesn't contain any behavior, so the latter is perfectly
      fine in this specific case.
    </para>
    <para>
      You should also define DTOs for any other data that you want to transfer (see <xref linkend="design-messages"/>).
      DTOs are needed not just for returning data from the server to the client, but also for the server to accept data
      from the client as input.
    </para>
    <para>
      Controllers don't just return data, or else we'd have a level 2 API (see <xref linkend="maturity"/>). They need
      to include links (level 3a) and forms (level 3b) as well.
    </para>
    <para>
      Links can be seen as a special form of data and thus serialized through the DTO. However, that requires the
      controller to know the details of the media type, since links are serialized differently in different media
      types. That means you can't support multiple media types with the same controller code. It also means that you
      have to rewrite multiple controller classes if you decide to change the media type. This is undesirable.
    </para>
    <para>
      The solution is to capture the concept of a link in code, so it can be abstracted from the physical form as used
      in the media type. The Spring HATEOAS project provides support for this through the
      <literal>ResourceSupport</literal> class <citation>Spring HATEOAS</citation>. You must derive your DTOs from this 
      class, which is yet another reason to distinguish DTOs from domain objects.
    </para>
    <para>
      The <literal>ResourceSupport</literal> class provides an <literal>add()</literal> method that accepts links
      built using <literal>LinkBuilder</literal>. The <literal>LinkBuilder</literal> is coupled to the destination 
      controller rather than to the URI it handles:
    </para>
    <programlisting>public class HomeDto extends ResourceSupport {
}

@RequestMapping("/")
public class HomeController {

  @RequestMapping(method = RequestMethod.GET,
      produces = { MEDIA_TYPE_DEFAULT })
  public HomeDto get() {
    HomeDto result = new HomeDto();
    result.add(LinkBuilder.TODO);
    return result;
  }
  
}</programlisting>
    <para>
      If the media type supports forms, then you need to do something similar for them as for links. At the time of
      writing there is no support for forms in Spring's projects, but fortunately there is a contribution from the
      community that provides an <literal>AffordanceBuilder</literal> that works analogous to
      <literal>LinkBuilder</literal> <citation>Spring Hydra</citation>.
    </para>
    <programlisting>TODO</programlisting>
    <para>
      With data, links, and forms, our API is at level 3(b). To get to level 4, we need to add semantics (see 
      <xref linkend="semantics"/>). If you've selected JSON-LD as the media type and Hydra as the vocabulary for REST
      semantics, then you can use the annotations from Spring Hydra to easily add application semantics to DTOs:
    </para>
    <programlisting>TODO</programlisting>
    <para>
      Controllers and services often call upon the help of other, external, services. This is especially true in a
      microservices architecture (see <xref linkend="apis"/>). In those situations, the REST server acts as a client to
      another server, so all the advice for building clients applies (see <xref linkend="client"/>).
    </para>
    <para>
      TODO: one-thread-per-connection vs one-thread-per-event
    </para>
    <para>
      <firstterm>Reactive programming</firstterm> is an emerging discipline which combines concurrency and event-based
      and asynchronous systems <citation>Reactive Manifesto</citation>. It is at the core of many high-performance
      concurrent systems.
    </para>
  </section>

  <section id="secure-impl">
    <title>Security</title>
    <para>
      We discussed security features in <xref linkend="security"/>. Security features address design flaws, which
      account for roughly half of all vulnerabilities. The other half are implementation bugs, and we will discuss
      them here. 
    </para>
    
    <section id="impl-authz">
      <title>Authorization</title>
	    <para>
	      The traditional way to implement authorization of REST APIs is to specify restrictions at the level of URI and 
	      HTTP method. For instance, this is the approach that Spring Security takes.
	    </para>
	    <para>
	      There are two places where such access control checks comes into play. The first is obviously when receiving a 
	      request. You should also check permissions on any links you want to put in the response. The links that the 
	      requester is not allowed to follow should be omitted from the response, because the links are supposed to be
	      options that the client can choose from for its next move.
	    </para>
	    <para>
	      The problem with specifying access control in terms of URIs and HTTP methods is that these are implementation 
	      details. 
	      URIs shouldn’t be known to anybody but the API designer/developer; the client will discover them through link 
	      relations. Even the HTTP methods can be hidden until runtime with mature media types like JSON-LD with Hydra.
	      This is great for decoupling the client and server, but now we have to specify our security constraints in terms 
	      of implementation details! This means that only the developers can specify the access control policy.
	    </para>
	    <para>
	      This flies in the face of best security practices, where the access control policy is externalized 
	      from the code (so it can be reused across applications) and specified by a security officer rather than a 
	      developer. So how do we satisfy both requirements?
	    </para>
	    <para>
	      The answer lies in the state diagram underlying the REST API. Remember, we want to authorize all transitions. 
	      Yes, a transition in an HTTP-based API is implemented using an HTTP method on a URI. But in REST, we shield the 
	      URI using a link relation. The link relation is very closely related to the type of action you want to perform.
	    </para>
	    <para>
	      The same link relation can be used from different states, so the link relation can’t be the whole answer. We 
	      also need the state, which is based on the representation returned by the REST server. This representation 
	      usually contains a set of properties and a set of links. We’ve got the links covered with the link relations, 
	      but we also need the properties.
	    </para>
	    <para>
	      The link relation indicates the action to be performed, while the properties correspond to 
	      resource attributes. Add to that the subject attributes obtained through the authentication process, and you 
	      have all the ingredients for making an XACML request.
	    </para>
	    <para>
	      TODO: Think this through. When implementing a controller, we no longer have access to the link relation that
	      led to the method being invoked on the URI...
	    </para>
    </section>
    
    <section id="input-validation">
      <title>Input Validation</title>
      <para>
        You should design your API such that it is easy to use (see <xref linkend="dx"/>). One aspect of that is to
        make it difficult to use the API incorrectly.
      </para>
      <para>
        For instance, in RESTBucks we decided that each item in the order must be listed separately. There is no
        <literal>count</literal> property on an item that specifies how many of the items are ordered. If there were,
        someone could specify a negative number and steal our money <citation>WhiteHatSec12</citation>. We'd prevent
        that by checking the count. Making the client repeat the items makes this kind of attack impossible and
        therefore eliminates the need for a check.
      </para>
      <para>
        This approach only goes so far, of course. In a different domain, where a client would routinely add hundreds 
        of the same item to an order, having to specify each one individually would be very annoying, for instance.
        So at some point you need to verify that input supplied by the client meets the criteria you have set for it.
      </para>
      <para>
        One example in RESTBucks is the <literal>payment</literal> message, which contains an <literal>amount</literal>
        property (see <xref linkend="design-messages"/>). This property is also vulnerable to an attack when the client
        specifies a negative value. So we need to verify that the input is valid.
      </para>
      <para>
        Input validation plays an important role in preventing these kinds of undesired business outcomes. It is also 
        important for preventing security bugs. For instance, in languages like C a client could provide data that
        extends beyond the memory allocated for it (a so-called <firstterm>Buffer Overrun</firstterm> vulnerability), 
        which can lead to all sorts of subsequent problems, like Elevation of Privilege (see
        <xref linkend="security"/>).
      </para>
      <para>
        Remember that the input from the client arrives as part of the HTTP message that a message converter translate
        into a data transfer object, which the HTTP framework subsequently makes available to a controller. This is 
        our first opportunity to validate the input. For the payment example, the controller may look something like
        this:
      </para>
      <programlisting>@RestController
@RequestMapping(Uris.PAYMENT)
public class PaymentController() {
  
  @RequestMapping(method = RequestMethod.POST,
      consumes = Api.MEDIA_TYPE_DEFAULT)
  public void pay(Payment payment) {
    double amount = payment.amount;
    // ...
  }
  
}</programlisting>
      <para>
        Note that our <literal>Payment</literal> data transfer object declares the <literal>amount</literal> field to
        be of type <literal>double</literal>. One could argue that this is the first step in validation, where the type
        of the property is checked. If the provided sequence of bytes doesn't specify a double under the rules of the
        media type, then the message converter will likely throw an exception.
      </para>
      <para>
        This is a form of <firstterm>syntactic</firstterm> validation, because you only need to understand the syntax
        rules governing the value to perform the validation.
        Syntactic validation is all about the syntax of the message, and should therefore be handled by the message
        converter. If it encounters the value <literal>foo</literal> for the <literal>amount</literal> property, it can
        throw an <literal>IllegalArgumentException</literal>, which the central error handling will convert to a
        <literal>400 Bad Request</literal> response to the client.
      </para>
      <para>
        <firstterm>Semantic validation</firstterm> is the next step where you perform further checks based on knowledge 
        of what the value represents in the problem domain. In this example, the <literal>amount</literal> should be 
        positive.
      </para>
      <para>
        Since semantic checking depends on an understanding of the problem domain, it must be handled by domain-aware
        code. For generic domain concepts, like email addresses, you may be able to find libraries that perform the
        validation for you. For more specialized domains, you will have to implement the validation yourself.
        There are several ways to accomplish this. 
      </para>
      <para>
        This first is to use an XML or JSON schema to validate the HTTP message body. There are, however, several
        problems with this approach. The first is that schema validation can only go so far. Validating individual
        properties will probably work fine, but things get hairy when we want to validate relations between properties.
        For maximum flexibility, we’d like to use a general purpose programming language like Java to express constraints.
      </para>
      <para>
        More importantly, <emphasis>schema validation is generally not a good idea in a REST service</emphasis>.
        A major goal of REST is to decouple client and server so that they can evolve separately. If we validate against 
        a schema, then a new client that sends a new property would break against an old server that doesn’t understand 
        the new property. (We discuss evolution of REST APIs in <xref linkend="maintenance"/>.)
      </para>
      <para>
        It’s better to silently ignore properties you don’t understand. The JAXB serialization library is a good 
        example of this. It also works the other way around: properties that are not sent by an old client end up as 
        <literal>null</literal> in the data transfer object. Consequently, a server must be careful to handle 
        <literal>null</literal> values properly.
      </para>
      <para>
        Instead of schema validation we should use programming language specific validation frameworks, if available.
        For instance, the Java world offers <firstterm>Bean Validation</firstterm> <citation>JSR 303</citation>. With
        Bean Validation, you could add annotations to your data transfer objects to perform semantic checking:
      </para>
      <programlisting>public class Payment {
  @Min(1)
  public double amount;
}

public class PaymentController {
  
  public void pay(@Valid Payment payment) {
    // ...
  }
  
}</programlisting>
      <para>
        The <literal>@Min</literal> annotation declares that the <literal>amount</literal> is only valid when it's at
        least <literal>1</literal>. The <literal>@Valid</literal> annotation on <literal>Payment</literal> declares
        that the Bean Validation framework must validate the data transfer object and throw a
        <literal>ConstraintViolationException</literal> when the object isn't valid. The HTTP framework must call the 
        Bean Validation framework, catch the exception and return <literal>400 Bad Request</literal>.
      </para>
      <para>
        Note that in Spring you can inspect the validation errors by adding an <literal>Errors</literal> parameter
        directly after the parameter with the <literal>@Valid</literal> annotation if you need more control over the
        error handling:
      </para>
      <programlisting>public void pay(@Valid Payment payment, Errors errors) {
    if (errors.hasErrors()) {
      // Handle errors ...
    }
    // ...
  }</programlisting>
      <para>
        The <literal>@Valid</literal> approach works as intended when the entire data transfer object is transferred,
        but it breaks down if we start using <literal>PUT</literal> or <literal>PATCH</literal> to update individual
        properties. In RESTBucks we can't update a payment, but we can update an order. So let's look at that example: 
      </para>
      <programlisting>public class Order {
  
  @Name
  public String customer;
  // ...
}

@RestController
@RequestMapping(Uris.ORDER)
public class OrderController {
  
  @RequestMapping(method = PUT, consumes = Api.DEFAULT_MEDIA_TYPES,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public Order update(@PathVariable("order-id") String id, @Valid Order order) {
    // ...
  }
  
  @RequestMapping(method = PATCH, consumes = Api.MEDIA_FORM, 
      produces = Api.DEFAULT_MEDIA_TYPES)
  public Order partialUpdate(@PathVariable("order-id") String id, 
      @RequestPart("customer") @Name String customer) {
    // ...
  }
  
}</programlisting>
      <para>
        This example uses a custom <literal>@Name</literal> annotation that validates the customer's name. By the way,
        this is actually a surprisingly difficult thing to get right <citation>McKenzie10</citation>.
      </para>
      <para>
        As this example shows, we now need to specify the validation annotation in more than one place. In order to
        make this DRY, we need to change the <literal>customer</literal> from a <literal>String</literal> to a new
        class that will handle the validation:
      </para>
      <programlisting><![CDATA[public class Name implements Comparable<Name> {
  private String name;
        
  public Name(@Name String value) {
    this.name = value;
  }
  
  // toString(), compareTo(), hashCode(), equals()
}

public class Order {
  
  public Name customer;
  
}

@RequestMapping(Uris.ORDER)
public class OrderController {
  
  @RequestMapping(method = PUT, consumes = Api.DEFAULT_MEDIA_TYPES,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public Order update(@PathVariable("order-id") String id, Order order) {
    // ...
  }
  
  @RequestMapping(method = PATCH, consumes = Api.MEDIA_FORM,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public Order partialUpdate(@PathVariable("order-id") String id, 
      @RequestPart("customer") Name customer) {
    // ...
  }
  
}]]></programlisting>
      <para>
        Now we have nicely DRY code, but it is still fundamentally flawed. The <literal>Order</literal> class is a data 
        transfer object (DTO), while the <literal>Name</literal> class is a domain object, so we're mixing different
        abstraction levels here. It's better to keep them separate:
      </para>
      <programlisting><![CDATA[public class OrderDto {
  
  public String customer;
  
  public OrderDto() {
  }
  
  public OrderDto(Order order) {
    customer = order.getCustomer().toString();
  }
  
}

public class Order {

  private Name customer;
  
  public Name getCustomer() {
    return customer;
  }
    
  public void setCustomer(Name customer) {
    this.customer = customer;
  }
  
}

@RestController
@RequestMapping(Uris.ORDER)
public class OrderController {
  
  @Autowired
  private OrderRepository orderRepository;
  
  @RequestMapping(method = PUT, consumes = Api.DEFAULT_MEDIA_TYPES,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public OrderDto update(@PathVariable("order-id") String id, OrderDto orderDto) {
    // ...
  }
  
  @RequestMapping(method = PATCH, consumes = Api.MEDIA_FORM,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public OrderDto partialUpdate(@PathVariable("order-id") String id,
      @RequestPart("customer") String customer) {
    Order order = orderRepository.findOne(id);
    if (order == null) {
      throw new NotFoundException();
    }
    order.setCustomer(new Name(customer));
    order = orderRepository.save(order);
    return new OrderDto(order);
  }
  
}]]></programlisting>
      <para>
        This code is DRY <emphasis>and</emphasis> follows the Single Responsibility Principle <citation>SOLID</citation>.
        The DTO only needs to change when we need to optimize the message structure for performance reasons, not when
        our understanding or support of the problem domain changes.
      </para>
    </section>
    
    <section id="output-encoding">
      <title>Output Encoding</title>
      <para>
        Sometimes there is a security issue that looks like it can be fixed with input validation, but where that is 
        not appropriate. For example, consider the classic <firstterm>SQL Injection</firstterm> vulnerability, where a
        SQL query string is built up using input provided by the client:
      </para>
      <programlisting>String query = "select * from order where customer = '" + customer + "'";
Statement statement = connection.createStatement();
ResultSet results = statement.executeQuery(query);</programlisting>
      <para>
        This code is susceptible to attacks where the client puts a quote in the value for <literal>customer</literal>,
        like <literal>1' OR '1'='1</literal>. Instead of showing the orders for one customer, this will show all
        orders, which is an Information Disclosure vulnerability (see <xref linkend="security"/>).
      </para>
      <para>
        Since the malicious input in this example causes the problem, you may think that we can fix it by fixing the
        input, i.e. by using input validation. We could use the <literal>@Name</literal> validation constraint of the
        previous section and have it refuse names with quotes.
      </para>
      <para>
        This is incorrect and may lead to negative business outcomes. Suppose you were to build an API around Academy
        Award winners and wouldn't be able to accept Tatum O'Neal!
        The problems is not that <literal>O'Neal</literal> is an invalid name, but rather that the name causes 
        problems <emphasis>when used in the context of SQL queries</emphasis>.
      </para>
      <para>
        Such problems call for a solution known as <firstterm>output encoding</firstterm>, where the value is encoded
        in such a way that it can't wreak havoc in that particular context. In the SQL example, the problem is the 
        mixing of code (the SQL query) and data (the name of the customer). Using <firstterm>parameterized
        queries</firstterm> eliminates that confusion:
      </para>
      <programlisting>PreparedStatement statement = connection.prepareStatement(
    "select * from order where customer = ?");
statement.setString(1, customer);
ResultSet results = statement.executeQuery();</programlisting>
      <para>
        The <literal>setString()</literal> method encodes the value of <literal>customer</literal> in such a way that
        it can never be treated as code.
      </para>
      <para>
        Other injection attacks are based on the same idea of mixing code and data, and they can also be fixed using
        output encoding. Common examples are XML/HTML and JSON/JavaScript. Even plain text log files can suffer from 
        an injection attack known as log forging, where the meaning of the text changes when it's split across lines.
      </para>
      <para>
        Most output contexts that you will encounter are standard contexts that other people use as well, because they
        depend on the technology rather than the problem domain. You should use an existing output encoding library 
        rather than build something yourself, because there are often tricky corner cases that are easy to get wrong. 
        ESAPI is an example of an output encoding library that covers most common output contexts
        <citation>ESAPI</citation>.
      </para>
      <para>
        The type of encoding is specific to the context, so extra special care must be taken when data is used in
        multiple contexts. One example is a client-provided value that is used in a JavaScript string that is embedded
        in an HTML page. Output encoding must be performed for each context and in the correct order, or else
        vulnerabilities will remain.
      </para>
      <para>
        Output encoding is the mirror twin of input validation. Input validation ensures that all input is properly
        converted to values that meet the constraints of the problem domain. Output encoding conversely ensures that
        these values remain valid in whatever technological context they are used.
      </para>
      <para>
        Input validation and output encoding are simple enough tools, but the trick is to apply them everywhere. An
        attacker only needs to find one place where they are forgotten to breach your system. We'll discuss how to
        ensure that you've covered all your bases in <xref linkend="test-security"/>.
      </para>
    </section>
  </section>
  
  <section id="radl-supports-implementation">
    <title>RADL Support During Implementation</title>
    <para>
      Some of the components of a REST server that we saw in <xref linkend="rest-server"/> are unique to the service
      the API is providing, but other parts are more or less boiler plate code. If you're following the design-first
      approach with an API description language (see <xref linkend="radl"/>), you may be able to generate some or all
      of the boilerplate code.
    </para>
    <para>
      For example, the Spring code generator for RADL creates the following classes for you:
    </para>
    <variablelist>
      <varlistentry>
        <term><literal>Api</literal></term>
        <listitem>
          <para>
            Constants for the billboard URI, link relations, media types, and error conditions.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Uris</literal></term>
        <listitem>
          <para>
            Constants for the URIs that identify the resources.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Controllers</term>
        <listitem>
          <para>
            The URI mapping, HTTP method handlers, and media type declarations for each resource. The handlers delegate
            to helper classes that are injected. The helper processes the input DTO, if any, and creates the DTO for
            the response. The controller adds the links and forms defined in RADL that the helper reports as enabled
            for the current response.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Controller helpers</term>
        <listitem>
          <para>
            Skeleton code for controllers to separate the tool-controlled part from the developer-controlled part (see
            below). The controller helpers are responsible for processing request DTOs, talking to domain objects, 
            building response DTOs, and determining whether links and/or forms should be added to them.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Errors</term>
        <listitem>
          <para>
            Custom exceptions for the defined error conditions, a DTO for transferring errors, and a central error
            handler that translates exceptions into error DTOs and returns the appropriate status codes.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Data transfer objects</term>
        <listitem>
          <para>
            Any data exchanged between client and server that is described using <literal>property-group</literal>s is
            translated to a DTO. If your media type supports links, then they are derived from
            <literal>ResourceSupport</literal>. TODO: What's the equivalent in Spring Hydra? 
            If you use JSON-LD as the media type and add <literal>uri</literal>
            attributes to the <literal>property</literal> and/or <literal>property-group</literal> elements, then the 
            DTOs and their fields are annotated using Spring Hydra.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      The code is divided into two parts. The first part is completely specified by the API description and is under
      control of the code generator. Any changes to this code will be overwritten. The second part is skeleton code
      that the developer is supposed to implement. These files are under control of the developer and will never be
      overwritten once generated.
    </para>
    <para>
      This division makes it possible to add code generation to the automated build process. There are plugins for
      build tools to make this even easier. At the time of writing there is support for Gradle, Maven, and command-line
      builds.
    </para>
    <para>
      Generating code pays back some of the effort put into maintaining an API description. At the time of writing
      there is no support for creating RADL files, so this is a manual activity. But it's easy to see how tooling could
      be built to help with that.
    </para>
    <para>
      For instance, an IDE plug-in could walk an API designer through the steps of procedure
      "<xref linkend="state-diagram-to-resource-model"/>" (see <xref linkend="design"/>). It's even conceivable that
      API descriptions can be kickstarted from BDD scenarios, following procedure
      "<xref linkend="bdd-scenario-to-state-diagram"/>" of <xref linkend="bdd-to-sd"/>.
    </para>
    <para>
      Manually writing an API description for a large existing service is tedious. Fortunately, there is also RADL
      tooling that is useful in a code-first approach. At the time of writing, either Spring or JAX-RS code can be
      analyzed and turned into a (partial) RADL file, although the tooling isn't as mature as for the design-first
      approach.
    </para>
    <para>
      RADL extraction doesn't have to be a one-time event either. You can generate code, manually update the code and 
      then run the extraction tool to update the RADL file. Any manual updates to the developer-controlled part of the 
      API description are preserved. Documentation for resources, etc. is extracted from JavaDoc comments, so 
      developers can stay close to the code.
    </para>
  </section>

  <section>
    <title>Summary</title>
    <para>
      This chapter covers how to implement a REST API in such a way that it is secure and easy to maintain. We'll now
      turn our attention to how to verify that this implementation meets the expectations of all stakeholders.
    </para>
  </section>
</chapter>
