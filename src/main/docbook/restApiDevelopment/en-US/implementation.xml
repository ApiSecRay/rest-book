<chapter id="implementation">
  <title>Implementation</title>
  <para>
    We now have a design for an API that meets the requirements, causes the least amount of surprise by reusing
    well-known design patterns, is helpful when things go wrong, gives good performance and scalability, and is secure.
    But until we've implemented that design, we don't actually have anything. 
    This chapter discusses some important topics to consider while building a REST server.
  </para>
  
  <section>
    <title>Anatomy of a REST Server</title>
    <para>
      There are a number of areas each REST API implementation must address. Since it's important to separate things
      that change for different reasons <citation>SOLID</citation>, these areas should be implemented by different
      components, as shown in <xref linkend="rest-server"/>.
    </para>
    <figure id="rest-server">
      <title>The components of a REST server</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/rest-server.png" scale="58" align="center"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
      Here's what each of the components is responsible for:
    </para>
    <variablelist>
      <varlistentry>
        <term>HTTP Server</term>
        <listitem>
          <para>
            The HTTP messages that the client sends must be handled somewhere in the server. A socket must be open on
            the standard ports 80 (for HTTP) and/or 433 (for HTTPS) or on some custom port. Code must listen on these
            ports and speak the HTTP protocol.
          </para>
          <para>
            There isn't any good reason to build this yourself. You should deploy your code into a running HTTP server
            like Tomcat or Apache that handles all this for you. Alternatively, you may embed an HTTP server like Jetty
            in your code.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>HTTP Framework</term>
        <listitem>
          <para>
            The HTTP server will speak the HTTP protocol, but it will not implement your resources. You need to extend
            it so that it will call into your code whenever it sees one of the URIs that identify your resources. An
            HTTP framework provides easy ways of doing that.
          </para>
          <para>
            This is another component that you should not write yourself. There are plenty of excellent frameworks out
            there that do this for you, like Jersey or Spring WebMVC. Those frameworks make it easy to link URIs to
            your code in a declarative manner.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Controllers</term>
        <listitem>
          <para>
            The actual code that handles the HTTP methods on your resources is known as a
            <firstterm>controller</firstterm>. This term comes from the <firstterm>Model-View-Controller</firstterm>
            (MVC) design pattern <citation>GammaEtAl94</citation>.
          </para>
          <para>
            MVC isn't the only possible architecture for a REST server. Approaches like hexagonal architecture, clean
            architecture, ports and adapters, etc., work too. In the following discussion we'll assume MVC, but the
            main ideas work equally well for any of the other approaches.
          </para>
          <para>
            The "controller" part of MVC is the glue that binds the logic from the model to the presentation in the
            view and the actions that update the model. We'll discuss the model and view below. For REST APIs, actions
            are the HTTP methods of the uniform interface, which the HTTP framework binds to your controllers.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Message converters</term>
        <listitem>
          <para>
            The HTTP server will handle the HTTP protocol, but that protocol is extensible. Media types define how the
            content of the HTTP message body is encoded (see <xref linkend="media-types"/>).
          </para>
          <para>
            While HTTP servers handle standard media types used on the Web, like HTML, they most likely won't handle
            the ones you selected for your REST API.
          </para>
          <para>
            Your HTTP framework may be able to handle additional media types, like <literal>application/json</literal>
            and <literal>application/xml</literal> through serialization libraries like JAX-B and Jackson. Different
            frameworks have different names for these media type handlers; we'll borrow the term <firstterm>message
            converter</firstterm> from Spring.
          </para>
          <para>
            In addition to providing some default message converters, HTTP frameworks also allow you to register new
            ones to handle additional media types. Rather than limit your choice of media type to the selection that the
            HTTP framework offers out of the box, you should use its extensibility features to write your own message
            converter if needed. It's usually not all that hard to implement a new message converter based on existing 
            ones.
          </para>
          <para>
            Separating out message converters from other code makes it easier to change media types (e.g. from plain
            JSON or HAL to a more mature media type like JSON-LD with Hydra). It also makes it easy to support multiple
            media types. This in turn enables you to switch media types without breaking clients, as we'll see in
            <xref linkend="breaking-changes"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Data transfer objects</term>
        <listitem>
          <para>
            In a REST API, the "view" part of MVC is the data content that is serialized in the body of the HTTP
            message. The message converter translates those bytes, whose meaning is defined by the media type, into a
            programming language object known as a data transfer object (DTO). As we saw in
            <xref linkend="granularity"/>, a DTO is an object that carries data between processes.
          </para>
          <para>
            There are two basic approaches for constructing DTOs. The first is to make them immutable objects, where
            all the input is provided in the constructor and the data can only be read. This doesn’t work well for
            large or deeply nested objects, however, and it doesn’t play nice with serialization frameworks.
          </para>
          <para>
            The better approach is thus to make all the properties writable. Since a DTO must not have logic, this is
            one of the few occasions where you can safely make the fields public and omit getters and setters.
          </para>
          <para>
            Of course, that means some other part of the code is responsible for checking whether individual values in
            the DTO make sense, as well as for checking combinations of values. We'll discuss this topic in
            <xref linkend="input-validation"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Domain objects</term>
        <listitem>
          <para>
            The "model" in the MVC pattern is the domain model. Domain model objects capture the logic of your problem 
            domain in an abstract way that is decoupled from technology like databases and UI
            <citation>Evans04</citation>.
          </para>
          <para>
            We believe the easiest way to ensure the desired separation of concerns is to practice Domain-Driven Design
            <citation>Evans04</citation>, where you start out with the domain logic and then add other concerns, like
            persistence and a REST API, around it.
          </para>
          <para>
            Other approaches can work as well. Whatever approach you choose to follow, make sure to separate the domain
            logic from the controllers and clearly distinguish between data transfer objects and domain objects.
          </para>
          <para>
            Data transfer objects transfer data between processes; in this case between a REST client and server. They
            don't have any behavior associated with them; they just exposes data. A domain object, in contrast, is all
            about encapsulating data rather than exposing it. You use domain objects for their behavior rather than
            their data.
          </para>
          <para>
            Domain objects are <emphasis>discovered</emphasis> during analysis, while data transfer objects are
            <emphasis>designed</emphasis> and thus are subject to all kinds of design trade-offs. As we saw in
            <xref linkend="granularity"/>, performance and scalability concerns may force us to structure our messages
            a certain way. That doesn't mean that the domain has changed, however, and thus should not lead to changes
            in the domain objects.
          </para>
          <para>
            So while there is a certain degree of overlap between the data exposed by a data transfer object and that
            encapsulated by a domain object, there isn't necessarily a one-to-one correspondence. It then follows
            that we need to map the DTOs onto domain objects and back.
          </para>
          <para>
            This mapping can be 1:1, and that's the best way to start. But when the need arises to change the message
            structure for performance or other reasons, resist the temptation to modify your domain objects. Instead
            you should have a mapping layer in place that handles the translation.
          </para>
          <para>
            Since this mapping is part of binding the "model" (domain) and "view" (data transfer object) parts of MVC,
            the right place to implement it is in the controller.
          </para>
          <para>
            Some frameworks are very easy to work with when the mapping is 1:1, but they get in the way when the mapping 
            becomes more complicated. Again, resist the temptation to go with the tool and change your domain objects.
            Code that matches the domain objects is too valuable to give up: it keeps developers and users on the same
            page and prevents subtle bugs based on misunderstandings <citation>Evans04</citation>.
          </para>
          <para>
            <firstterm>Dependency injection</firstterm> is a design pattern where an object doesn't create or look up
            its dependencies itself, but rather gets told from the outside what they are. One application of this
            pattern is to inject domain objects as dependencies into controllers, so that the controllers can call the
            domain objects to execute business logic.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Persistency</term>
        <listitem>
          <para>
            Remember from <xref linkend="rest"/> that state in a RESTful system is separated into application state and
            resource state. The former is maintained on the client and is discussed in <xref linkend="client"/>.
            Resource state is maintained on the server, so you'll need some sort of database to persist it.
          </para>
          <para>
            There are a lot of options for doing so. Traditionally, persistency meant storing data in a relational
            database and that may be the right answer for you today.
          </para>
          <para>
            But if your API is publicly accessible by just about anybody, then you may need a solution that is more
            specifically tailored to that scale, like a NoSql database. There are many options out there, like
            Cassandra, CouchDB, etc., so you'll have to do some homework to pick the right tool for your job.
          </para>
          <para>
            To keep your domain objects independent from your persistency solution, you may want to introduce an
            abstraction known as a <firstterm>Data Access Layer</firstterm> (DAL). The DAL should be captured in a
            technology-independent way, so you can inject it into your domain objects without binding the domain model
            to a specific database technology.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      <xref linkend="rest-server"/> shows the relationships between the components. Components in blue are standard
      components, while those in yellow and red are specific to your project. The difference is that yellow components
      can be generated, as we'll see in <xref linkend="radl-supports-implementation"/>, while red components must be
      hand-coded. Green components may be either standard or project-specific. So in the best case scenario, you only
      have to implement the domain model yourself.
    </para>
    <para>
      For each standard component you can look for the best implementation for your specific situation.
      Alternatively, you can use a suite of components that are proven to work well together. An example of the latter
      for Java is offered by the Spring community:
    </para>
    <itemizedlist>
      <listitem>
        <para>
         The <citation>Spring WebMVC</citation> project lets you build REST controllers by adding annotations to your
         POJOs. It comes with some predefined message converters, like for <literal>application/json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring HATEOAOS</citation> project adds support for link relations and a message converter for
          <literal>application/hal+json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring Hydra</citation> community contribution adds support for actions and semantics, and a
          message converter for <literal>application/ld+json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring Data</citation> project adds support for a Data Access Layer.
        </para>
      </listitem>
      <listitem>
        <para>
          Finally, Spring's dependency injection glues everything together <citation>Spring Platform</citation>.
          For instance, you can use annotations to automatically wire controllers to domain objects.
        </para>
      </listitem>
    </itemizedlist>      
  </section>
  
  <section id="dry">
    <title>Keeping it DRY</title>
    <para>
      TODO: Define URL structure, media type, namespace, error handling, etc. in a single place.
    </para>
  </section>

  <section id="reactive">
    <title>Reactive programming</title>
    <para>
      <firstterm>Reactive programming</firstterm> is an emerging discipline which combines concurrency and 
      event-based and asynchronous systems. It is at the core of many high-performance concurrent systems.
    </para>
  </section>

  <section id="radl-supports-implementation">
    <title>RADL Support During Implementation</title>
    <para>
      TODO: Generate code from RADL, extract RADL from code.
    </para>
  </section>

  <section id="secure-impl">
    <title>Security</title>
    <section id="impl-authz">
      <title>Authorization</title>
	    <para>
	      The traditional way to implement authorization of REST APIs is to specify restrictions at the level of URI and 
	      HTTP method. For instance, this is the approach that Spring Security takes.
	    </para>
	    <para>
	      There are two places where such access control checks comes into play. The first is obviously when receiving a 
	      request. You should also check permissions on any links you want to put in the response. The links that the 
	      requester is not allowed to follow should be omitted from the response, because the links are supposed to be
	      options that the client can choose from for its next move.
	    </para>
	    <para>
	      The problem with specifying access control in terms of URIs and HTTP methods is that these are implementation 
	      details. 
	      URIs shouldn’t be known to anybody but the API designer/developer; the client will discover them through link 
	      relations. Even the HTTP methods can be hidden until runtime with mature media types like JSON-LD with Hydra.
	      This is great for decoupling the client and server, but now we have to specify our security constraints in terms 
	      of implementation details! This means that only the developers can specify the access control policy.
	    </para>
	    <para>
	      This flies in the face of best security practices, where the access control policy is externalized 
	      from the code (so it can be reused across applications) and specified by a security officer rather than a 
	      developer. So how do we satisfy both requirements?
	    </para>
	    <para>
	      The answer lies in the state diagram underlying the REST API. Remember, we want to authorize all transitions. 
	      Yes, a transition in an HTTP-based API is implemented using an HTTP method on a URI. But in REST, we shield the 
	      URI using a link relation. The link relation is very closely related to the type of action you want to perform.
	    </para>
	    <para>
	      The same link relation can be used from different states, so the link relation can’t be the whole answer. We 
	      also need the state, which is based on the representation returned by the REST server. This representation 
	      usually contains a set of properties and a set of links. We’ve got the links covered with the link relations, 
	      but we also need the properties.
	    </para>
	    <para>
	      The link relation indicates the action to be performed, while the properties correspond to 
	      resource attributes. Add to that the subject attributes obtained through the authentication process, and you 
	      have all the ingredients for making an XACML request.
	    </para>
	    <para>
	      TODO: Think this through. When implementing a controller, we no longer have access to the link relation that
	      led to the method being invoked on the URI...
	    </para>
      <para>
        TODO: eXtensible Access Control Markup Language?
      </para>
    </section>
    
    <section id="input-validation">
      <title>Input Validation</title>
    </section>
    
    <section id="output-encoding">
      <title>Output Encoding</title>
    </section>
  </section>
  
  <section id="external">
    <title>Calling external services</title>
    <para>
      TODO: Calling external services. Circuit breakers, etc.
    </para>
  </section>

  <section>
    <title>Summary</title>
    <para>
      TODO:
    </para>
  </section>
</chapter>
