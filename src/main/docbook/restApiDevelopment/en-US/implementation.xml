<chapter id="implementation">
  <title>Implementation</title>
  <para>
    We now have a design for an API that meets the requirements, causes the least amount of surprise by reusing
    well-known design patterns, is helpful when things go wrong, gives good performance and scalability, and is secure.
    But until we've implemented that design, we don't actually have anything at all. We need to implement the design
    to derive value from it.
  </para>
  <para>
    This chapter discusses how to build a REST server, while <xref linkend="client"/> shows how to build a client to
    consumer the API.
  </para>
  
  <section id="server-arch">
    <title>Anatomy of a REST Server</title>
    <para>
      There are a number of areas that each REST API implementation must address. Since it's important to separate
      things that change for different reasons <citation>SOLID</citation>, these areas should be implemented by
      different components, as shown in <xref linkend="rest-server"/>.
    </para>
    <figure id="rest-server">
      <title>The components of a REST server</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/rest-server.png" scale="52" align="center"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
      Here's what each of the components is responsible for:
    </para>
    <variablelist>
      <varlistentry>
        <term>HTTP server</term>
        <listitem>
          <para>
            The HTTP messages that the client sends must be handled somewhere in the server. A socket must be opened on
            the standard ports 80 (for HTTP) and/or 433 (for HTTPS) or on some custom port. Code must listen on these
            ports and speak the HTTP protocol.
          </para>
          <para>
            There isn't any good reason to build this yourself. You should deploy your code to an HTTP server like
            Tomcat or Apache that handles this for you. Alternatively, you can embed an HTTP server like Jetty or Netty
            in your code.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>HTTP framework</term>
        <listitem>
          <para>
            The HTTP server will speak the HTTP protocol, but it will not implement your resources. You need to extend
            it so that it will call into your code whenever it sees one of the URIs that identify your resources. An
            HTTP framework provides the glue between the HTTP server and the code that implements the resources.
          </para>
          <para>
            This is another component that you should not write yourself. There are plenty of excellent frameworks out
            there that do this for you, like Jersey or Spring WebMVC. Those frameworks make it easy to link URIs to
            your code, for example using annotations.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Controllers</term>
        <listitem>
          <para>
            The actual code that handles the HTTP methods on a resource is known as a <firstterm>controller</firstterm>.
            This term comes from the <firstterm>Model-View-Controller</firstterm> (MVC) design pattern
            <citation>GammaEtAl94</citation>.
          </para>
          <para>
            MVC isn't the only possible architecture for a REST server. Similar approaches like hexagonal architecture, 
            clean architecture, ports and adapters, etc., work too. In the following discussion we'll assume MVC, but 
            the main ideas work equally well for any of the other approaches.
          </para>
          <para>
            The "controller" part of MVC binds the data from the model to the presentation in the view and attaches 
            logic from the model to affordances in the presentation. For REST APIs, those affordances are the HTTP
            methods of the uniform interface.
          </para>
          <para>
            Controllers make up an important part of a REST server. We'll discuss them in depth below in 
            <xref linkend="controller"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Message converters</term>
        <listitem>
          <para>
            The HTTP server handles most of the HTTP protocol, but not all. The HTTP protocol is extensible; for 
            example, media types define how the content of the HTTP message body is encoded (see
            <xref linkend="media-types"/>).
          </para>
          <para>
            While HTTP servers handle standard media types used on the Web, like <literal>text/html</literal>, they may
            not handle the one(s) you selected for your REST API.
          </para>
          <para>
            The HTTP framework may be able to handle additional media types that are often used in REST APIs, like
            <literal>application/json</literal> and <literal>application/xml</literal>. It does this through
            <firstterm>serialization libraries</firstterm> like JAXB and Jackson. Different frameworks use different
            names for these media type handlers; in this book we'll borrow the term <firstterm>message
            converter</firstterm> from Spring.
          </para>
          <para>
            In addition to providing some default message converters, HTTP frameworks also allow you to register new
            ones to handle unsupported media types. You should use this extensibility feature to write your own message
            converter if needed rather than limit your choice of media type to the selection that the HTTP framework
            offers out of the box. It's usually not all that hard to implement a new message converter based on existing
            ones.
          </para>
          <para>
            Separating out message converters from other code makes it easier to change media types (e.g. from plain
            JSON or HAL to a more mature media type like JSON-LD with Hydra). It also makes it easy to support multiple
            media types. This in turn enables you to switch media types without breaking clients, as we'll see in
            <xref linkend="breaking-changes"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Data transfer objects</term>
        <listitem>
          <para>
            In a REST API, the "view" part of MVC is the data content that is serialized in the body of the HTTP
            message. The message converter translates those bytes, whose meaning is defined by the media type, into a
            programming language object that carries data between processes.
          </para>
          <para>
            While the term Data Transfer Object (DTO) captures that meaning well, many people associate it exclusively 
            with the data transfered to and from a database server. Some people therefore prefer to use the term 
            <firstterm>Transport Layer Object</firstterm> for DTOs exchanged between REST clients and servers. We won't 
            discuss the data layer in this book, as it's not specific to REST APIs, and therefore there is no risk of
            confusion here, but you should be aware of the issue.
          </para>
          <para>
            There are two basic approaches for constructing DTOs. The first is to make them immutable objects, where
            all the input is provided in the constructor and the data can only be read. This doesn’t work well for
            large or deeply nested objects, however, and it doesn’t play nice with serialization frameworks.
          </para>
          <para>
            The better approach is therefore to make all the properties writable. Since a DTO must not have logic, this 
            is one of the few occasions where you could safely choose to make the fields public and to omit getters and 
            setters.
          </para>
          <para>
            Of course, that means that some other part of the code is responsible for checking whether individual
            values in the DTO make sense, and whether the different values make sense together. We'll discuss this 
            topic in <xref linkend="input-validation"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Domain model</term>
        <listitem>
          <para>
            The "model" in the MVC pattern is the domain model. Domain model objects capture the logic of your problem 
            domain in a way that is decoupled from technology like databases and UI <citation>Evans04</citation>.
          </para>
          <para>
            We believe the easiest way to achieve this decoupling is to practice Domain-Driven Design (DDD)
            <citation>Evans04</citation>, where you start out with the domain logic and then add other concerns, like
            persistence and a REST API, around it.
          </para>
          <para>
            Other approaches can work as well. Whatever approach you choose to follow, make sure to separate the domain
            logic from the controllers and clearly distinguish between data transfer objects and domain objects.
          </para>
          <para>
            Data transfer objects transfer data between processes; in this case between a REST client and server.
            They don't have any behavior associated with them; they just exposes data. A domain object, in contrast, is 
            all about encapsulating data rather than exposing it. You use domain objects for their behavior rather than
            their data.
          </para>
          <para>
            Domain objects are <emphasis>discovered</emphasis> during analysis, while data transfer objects are
            <emphasis>designed</emphasis> and thus are subject to all kinds of design trade-offs. As we saw in
            <xref linkend="granularity"/>, performance and scalability concerns may prompt us to change the structure
            of our messages in a certain way. That doesn't mean that the problem domain has changed, however, and thus 
            should not lead to changes in the domain objects.
          </para>
          <para>
            So while there is a certain degree of overlap between the data exposed by a data transfer object and that
            encapsulated by a domain object, there isn't necessarily a one-to-one correspondence. It then follows
            that we need to map the DTOs onto domain objects and back.
          </para>
          <para>
            This mapping can be 1:1, and that's generally the best way to start. But when the need arises to change the
            message structure for performance or other reasons, resist the temptation to modify your domain objects.
            Instead put a mapping in place to translate from DTO to domain object and back.
          </para>
          <para>
            Since this mapping is part of binding the "model" (domain) and "view" (data transfer object) parts of MVC,
            the right place to implement it is in the controller.
          </para>
          <para>
            Some frameworks are very easy to work with when the mapping is 1:1, but they get in the way when the mapping 
            becomes more complicated. Again, resist the temptation to go with the tool and change your domain objects.
            Code that matches the domain objects is too valuable to give up: it keeps developers and users on the same
            page and prevents subtle bugs based on misunderstandings <citation>Evans04</citation>.
          </para>
          <para>
            Domain-driven design distinguishes between different kinds of domain objects, like entities (something with
            an identity, such as a person), value objects (something without identity, such as a dollar amount, where
            you don't care about individual coins or bills, just the amount), and services (an operation that transcends
            a single object, such as the process of paying an order). Like REST services, domain services are stateless.
            They are often injected as dependencies into controllers.
          </para>
          <para>
            <firstterm>Dependency injection</firstterm> is a design pattern where an object doesn't create or look up
            its dependencies itself, but rather gets told from the outside what they are. This pattern has many
            benefits, and it works well for adding domain services to controllers.
          </para>
          <para>
            The domain model is what your application is really about. That makes it the logical place to add logging
            of events that are interesting from a business perspective, as we'll see in <xref linkend="logging"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Persistency</term>
        <listitem>
          <para>
            Remember from <xref linkend="rest"/> that state in a RESTful system is separated into application state and
            resource state. Application state is maintained on the client, as we'll see in <xref linkend="client"/>.
          </para>
          <para>
            Resource state is maintained on the server, so you'll need some sort of database to persist it.
            There are a lot of options for doing so. Traditionally, persistency meant storing data in a relational
            database and that may be the right answer for you today.
          </para>
          <para>
            But if your API is publicly accessible by just about anybody, then you may need a solution that is more
            specifically tailored to that kind of scale, like a NoSql database. There are many options out there, like
            Cassandra, CouchDB, etc., so you'll have to do some homework to pick the right tool for your job.
          </para>
          <para>
            To keep your domain objects independent from your persistency solution, you may want to introduce an
            abstraction known as a <firstterm>Data Access Layer</firstterm> (DAL). The DAL should be captured in a
            technology-independent way, so you can inject it as a dependency into your domain model while keeping it
            independent of a specific database technology.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      <xref linkend="rest-server"/> shows the relationships between the server components. Components in blue are
      standard components, while those in yellow and red are specific to your project. The difference is that yellow
      components could be generated if you use sufficiently powerful tools in combination with an
      API description language (see <xref linkend="api-description"/>), while red components
      must be hand-coded. Green components may be either standard or project-specific. So in the best case scenario, 
      you only have to implement the domain model yourself.
    </para>
    <para>
      For each standard component you can look for the best-of-breed implementation for your specific situation.
      Alternatively, you can use a suite of components that are proven to work well together. An example of the latter
      for Java is offered by the Spring community:
    </para>
    <itemizedlist>
      <listitem>
        <para>
         The <citation>Spring WebMVC</citation> project lets you build REST controllers by adding annotations to your
         POJOs. It comes with some predefined message converters, like for <literal>application/json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring HATEOAOS</citation> project adds support for link relations and a message converter for
          <literal>application/hal+json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring Hydra</citation> community contribution adds support for actions and semantics, and a
          message converter for <literal>application/ld+json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring Data</citation> project adds support for a Data Access Layer.
        </para>
      </listitem>
      <listitem>
        <para>
          Finally, Spring's dependency injection glues everything together <citation>Spring Platform</citation>.
          For instance, you can use annotations to automatically wire controllers to domain services and domain services
          to the DAL.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      We'll use Spring in the remainder of this chapter, but the ideas carry over very well to other Java frameworks
      (like JAX-RS) and other programming languages.
    </para>
  </section>
  
  <section id="controller">
    <title>Controllers</title>
    <para>
      An important principle in software development is <firstterm>Don't Repeat Yourself</firstterm> (DRY). If every
      concept is expressed in only one place, then you only need to update one place when changes are required. If you
      distribute a concept over multiple places, then you your maintenance burden goes up and your future productivity
      down.
    </para>
    <para>
      If you clearly distinguish the components described in the previous section, you're already in a good position to
      prevent duplication, but there is more that you can do. The domain model is a good example: every concept from
      the problem domain should be captured in one place in the code (e.g. in one class).
    </para>
    <para>
      The DRY guideline is helpful in controllers as well. Controllers bind code to resources and media types.
      For instance, the following code snippet uses the Spring <literal>@RequestMapping</literal> annotation to specify
      which media type to use as the <literal>Content-Type</literal> of the response:
    </para>
    <programlisting>@RequestMapping(method = RequestMethod.GET,
    produces = { "application/ld+json" })
public HomeResource get() {
  return new HomeResource();
}</programlisting>
    <para>
      This looks fine in isolation, but if you code all your controllers like this, the string
      <literal>"application/ld+json"</literal> will be all over the place. It's better to use a constant instead, e.g.
      <literal>produces = { Api.MEDIA_TYPE_APPLICATION_LD_JSON }</literal>.
      Here we've created a new <literal>Api</literal> class to hold a constant for the media type. We'll come back to
      that class later.
    </para>
    <para>
      If you've selected a media type for which your HTTP framework has native support, then you probably can use a
      constant defined by the HTTP framework rather than your own. For instance, Spring has a
      <literal>MediaType</literal> class with constants for basic media types like
      <literal>application/json</literal>.
    </para>
    <para>
      Imagine what would have to happen if we were to change media type. We'd introduce a new constant for the new 
      media type and we'd still have to go in and update all our controllers. We could ease our pain by using a
      refactoring tool to rename the constant, but we'd still end up with changes in all our controller classes.
    </para>
    <para>
      We can prevent that by introducing another layer of indirection:
    </para>
    <programlisting>String MEDIA_TYPE_APPLICATION_LD_JSON = "application/ld+json";
String MEDIA_TYPE_DEFAULT = MEDIA_TYPE_APPLICATION_LD_JSON;</programlisting>
    <para>
      We can now use <literal>produces = { Api.MEDIA_TYPE_DEFAULT }</literal> in our controllers, and they won't need
      to change if we decide to use a different media type. Additionally, this code also clearly expresses that things
      are business as usual with regard to the media type for this controller. That makes the cases where we use a
      non-default media type stand out better.
    </para>
    <para>
      The use of media types is only one example of where we can apply the DRY principle. You should do something
      similar for URLs, XLM namespaces (if you use XML-based media types), link relations, error constants, etc.
    </para>
    <para>
      Some of the identifiers in that list are part of your API, like link relations, while others are implementation
      choices, like the URLs used to identify resources. Don't put all of these in the same location, because they will
      change for different reasons.
    </para>
    <para>
      In the example above, we've put the constants for the media types in a class called <literal>Api</literal>. You
      can make this class the home of all identifiers that are part of your API. That makes it possible to publish the
      <literal>Api</literal> class somewhere where clients can consume it. This is actually the beginning of a Software
      Development Kit (SDK)! We'll talk more about that in <xref linkend="sdk"/>.
    </para>
    <para>
      We just said that URLs are implementation choices, but there is one exception: the billboard URI. The constant
      for this URL should therefore be part of the <literal>Api</literal> class rather than the internal class that
      contains the other URLs.
    </para>
    <para>
      Since URLs are hierarchical in nature, we can apply the DRY principle to them as well by defining one URL
      constant in terms of another:
    </para>
    <programlisting>String URL_ORDERS = "/orders/";
String URL_ORDER = URL_ORDERS + "{order-id}/";</programlisting>
    <para>
      Sometimes duplication is a little harder to spot. A common place in REST servers where this happens is with error
      handling code. It's tempting to catch exceptions in your controllers and translate them to appropriate status
      codes there, but it's better to do that in a central location. Without such centralization, you run the risk of
      handling exceptions inconsistently.
    </para>
    <para>
      Different HTTP frameworks support this in different ways. For example, in Spring you can use a combination of the
      <literal>@ControllerAdvice</literal> and <literal>@ExceptionHandler</literal> annotations to centralize exception
      handling:
    </para>
    <programlisting><![CDATA[public class NotFoundException extends RuntimeException {
  super("http://errors.restbucks.com/not-found");
}

public class MissingItemException extends IllegalArgumentException {
  super("http://errors.restbucks.com/missing-item");
}

public class UnknownItemException extends IllegalArgumentException {
  super("http://errors.restbucks.com/unknown-item");
}

// Other exception classes ...


@ControllerAdvice
public class CentralErrorHandler {

 @ExceptionHandler({ NotFoundException.class })
 public ResponseEntity<String> notFound(Exception e) {
  return new ResponseEntity<>(e.getMessage(), HttpStatus.NOT_FOUND);
 }
       
 @ExceptionHandler({ IllegalArgumentException.class })
 public ResponseEntity<String> illegalArgument(
    IllegalArgumentException e) {
  return new ResponseEntity<>(e.getMessage(), HttpStatus.BAD_REQUEST);
 }
 
 // Other exception handlers...
}]]></programlisting>
    <para>
      As the above example shows, it makes sense to define custom exception classes for each of the API's error
      conditions (see <xref linkend="error"/>). You should not, however, define new exceptions for cases that are
      already covered by standard exceptions. For instance, in Java <literal>IllegalArgumentException</literal> maps
      naturally to the <literal>400 Bad Request</literal> status, while <literal>IllegalStateException</literal>
      corresponds to <literal>500 Internal Server Error</literal>.
    </para>
    <para>
      The central error handler maps exception classes onto HTTP status codes and translates them to something that can
      be serialized as an HTTP response body. In the example above that is a simple message string, but you serve your
      clients better by poviding more structured messages with additional details that can help the client recover, as 
      we discussed in <xref linkend="serialize-errors"/>:
    </para>
    <programlisting><![CDATA[public class ErrorResource {

  public String type;
  public String title;
  // Any other fields you want to return to the client, like details

}

@ControllerAdvice
public class CentralErrorHandler {

  @ExceptionHandler({ NotFoundException.class })
  public ResponseEntity<ErrorResource> notFound(Exception e) {
    ErrorResource error = new ErrorResource();
    error.type = "http://errors.restbucks.com/not-found";
    error.title = 
       "The URI you requested doesn't exists or is not accessible by you.";
    return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
  }

}]]></programlisting>
    <para>
      This example shows how easy Spring makes it to return a data transfer object (DTO): you just declare a class
      with properties and the message converters take care of the rest. If you're using XML, you may need to do some
      extra work to define the mapping of DTO fields to XML elements and attributes. For instance, JAXB provides
      <literal>@XmlElement</literal> and <literal>@XmlAttribute</literal> annotations for the DTO's fields
      <citation>JAXB</citation>.
    </para>
    <para>
      As we saw earlier, the properties of a DTO can be regular JavaBeans properties (private fields with accessors and
      mutators), or they can simply be public fields. A DTO doesn't contain any behavior, so the latter is perfectly
      fine.
    </para>
    <para>
      You should define DTOs not just for error reporting, but for any data that you want to transfer (see 
      <xref linkend="design-messages"/>). This includes returning data to the client as well as accepting data from the 
      client as input.
    </para>
    <para>
      Controllers don't just return data, or else we'd have a level 2 API (see <xref linkend="maturity"/>). They need
      to include links (level 3a) and forms (level 3b) in their responses as well.
    </para>
    <para>
      Links can be seen as a special form of data and thus serialized through the DTO. However, that requires the
      controller to know the details of the media type, since links are serialized differently in different media
      types. That means you can't support multiple media types with the same controller code. It also means that you
      have to rewrite many controller classes if you decide to change the media type. This is obviously undesirable.
    </para>
    <para>
      The solution is to capture the concept of a link in code, so different message converters can serialize it
      differently, depending on the rules of the media type. Spring HATEOAS provides the <literal>Link</literal> class
      for this purpose <citation>Spring HATEOAS</citation>, which you can build links using a 
      <literal>LinkBuilder</literal>. The <literal>ControllerLinkBuilder</literal> is a <literal>LinkBuilder</literal>
      that points to the destination controller class/method rather than to the URI it handles. This reduces the impact 
      of URL changes on your code.
    </para>
    <para>
      Once you've built links, you have to add them to your DTO. You do this by deriving your DTO from the       
      <literal>ResourceSupport</literal> class. This is yet another reason to distinguish DTOs from domain objects,
      where you want the freedom to derive from any class the problem domain calls for.
      The <literal>ResourceSupport</literal> class provides methods to add, remove, and query links:
    </para>
    <programlisting>public class HomeResource extends ResourceSupport {
}

@RequestMapping("/")
public class HomeController {

  @RequestMapping(method = RequestMethod.GET,
      produces = { Api.MEDIA_TYPE_DEFAULT })
  public HomeResource get() {
    HomeResource result = new HomeResource();
    Link link = ControllerLinkBuilder
        .linkTo(ControllerLinkBuilder.methodOn(MenuController.class).get())
        .withRel(Api.LINK_REL_MENU);
    result.add(link);
    return result;
  }
  
}</programlisting>
    <para>
      The above only works for controller methods that take no arguments and return a response. For a controller method
      that doesn't return a response, say one implementing <literal>DELETE</literal>, you can't use the
      <literal>methodOn</literal> trick. Assuming the delete method uses the same URI as the controller it is part of
      (in other words, the delete method doesn't supply any URI in its <literal>@RequestMapping</literal>), you can
      simply link to the controller class instead of to the method:
    </para>
    <programlisting>Link link = ControllerLinkBuilder
    .linkTo(OrderController.class)
    .withRel(Api.LINK_REL_DELETEACTION)</programlisting>
    <para>
      This approach doesn't work when the method defines its own URI rather than inherit it from the class level. It 
      also doesn't express the intent clearly. A better solution is therefore to make the method return a dummy type:
    </para>
    <programlisting><![CDATA[@RequestMapping(method = RequestMethod.DELETE)
public ResponseEntity<Void> delete() {
  // ...
  return new ResponseEntity<>(HttpStatus.NO_CONTENT);
}]]></programlisting>
    <para>
      If the controller method expects input, say one implementing <literal>PUT</literal>, then you must supply
      that input during link building. For instance, if the method uses a <literal>@PathVariable</literal> to extract an 
      ID from the URI, then you can supply it if you know it. If you don't know it, you can supply
      <literal>null</literal>, and a URI template will be returned rather than a URI. The client then has to fill in 
      the URI template variable to get a URI.
    </para>
    <para>
      Remember that the response from the server is a menu for the client to choose from, so the server shouldn't return
      options that the client isn't supposed to select. The controller should check two things before adding a link:
    </para>
    <variablelist>
      <varlistentry>
        <term><emphasis>Does the link make sense for the current state?</emphasis></term>
        <listitem>
          <para>
            For instance, once an order in RESTBucks is paid, it cannot be paid again or changed. The state diagram 
            (see <xref linkend="state-diagrams"/>) should tell you what is possible at any given moment.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><emphasis>Is the current user permitted to follow the link?</emphasis></term>
        <listitem>
          <para>
            For instance, an unpaid order can be paid by the customer who placed the order, but not by any other
            customer. The threat model should tell you what the current user can do at any given moment (see
            <xref linkend="threat-modeling"/>).
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      There are many technologies that you can use to implement access control. Many applications today follow an
      RBAC model (see <xref linkend="authorization"/>). As the above example shows, there are limits to what you can do
      with roles, however, so for context-aware, fine-grained access control, you may want to look into ABAC and XACML.
    </para>
    <para>
      When implementing these checks, make sure to keep the code at the right abstraction level. For instance, you
      shouldn't check whether a user has access to a URI or link relation, as these are implementation choices. Instead,
      focus on the transitions of the state diagram, as they capture the actions from the business perspective:
    </para>
    <programlisting>if (userIsPermitted(Actions.CANCEL)) {
  Link link = ControllerLinkBuilder
      .linkTo(OrderController.class)
      .withRel(Api.LINK_REL_DELETEACTION);
  result.add(link);
}</programlisting>
    <para>
      In some cases there could be many such if statements, because there could be many links. Each check might be 
      relatively expensive to perform, for instance when you have to call out to an external authorization system such 
      as a XACML PDP. This isn't a good combination from the performance perspective, so you may be better off with
      calculating all permitted actions in one go:
    </para>
    <programlisting><![CDATA[Collection<String> permittedActions = getPermittedActions();
if (permittedActions.contains(Actions.CANCEL)) {
  // Build and add link ...
}

if (permittedActions.contains(...)) {
  // Build and add link ...
}]]></programlisting>
    <para>
      If the media type supports forms, then you need to do something similar for them as for links. At the time of
      writing there is no support for forms in official Spring projects, but fortunately there is a contribution from
      the community that provides an <literal>AffordanceBuilder</literal> that is a drop-in replacement for
      <literal>ControllerLinkBuilder</literal> and that does support forms <citation>Spring Hydra</citation>. The
      <literal>AffordanceBuilder</literal> will render the method to use in the response and a template for any data
      that the client must provide.
    </para>
    <para>
      With data, links, and forms, our API is at level 3(b). To get to level 4, we need to add semantics (see 
      <xref linkend="semantics"/>). If you've selected JSON-LD as the media type and Hydra as the vocabulary for REST
      semantics, then you can use the <literal>Expose</literal> annotation from Spring Hydra to easily add application 
      semantics to DTOs:
    </para>
    <programlisting>@Expose("http://schema.org/Order")
public class OrderResource extends ResourceSupport {

  @Expose("http://schema.org/priceCurrency")
  public String currency;
  @Expose("http://schema.org/customer")
  public String customer;
  public ItemResource[] items;
  @Expose("http://schema.org/totalPrice")
  public double total;

}</programlisting>
    <para>
      Controllers and services often call upon the help of other, external, services. This is especially true in a
      microservices architecture (see <xref linkend="apis"/>). In those situations, the REST server acts as a client to
      another server, so all the advice for building clients applies (see <xref linkend="client"/>).
    </para>
    <!-- 
      TODO: Reactive programming 
      
      one-thread-per-connection vs one-thread-per-event

      <firstterm>Reactive programming</firstterm> is an emerging discipline which combines concurrency and event-based
      and asynchronous systems <citation>Reactive Manifesto</citation>. It is at the core of many high-performance
      concurrent systems.
    -->
  </section>

  <section id="secure-impl">
    <title>Secure Implementation</title>
    <para>
      We discussed security features in <xref linkend="security"/>. Security features address design flaws, which
      account for roughly half of all vulnerabilities. The other half are implementation bugs, and we'd do well to take
      measures to prevent those too. We'll now take a look at two complementary techniques that can help with that.
    </para>
    
    <section id="input-validation">
      <title>Input Validation</title>
      <para>
        You should design your API such that it is easy to use (see <xref linkend="dx"/>). One aspect of that is to
        make it difficult to use the API incorrectly so that developers are less likely to stray.
      </para>
      <para>
        For instance, in RESTBucks we decided that each item in the order must be listed separately. There is no
        <literal>count</literal> property on an item that specifies how many of the items are ordered. If there were,
        someone could specify a negative number and steal our money <citation>WhiteHatSec12</citation>. We'd prevent
        that by checking the count. Making the client repeat the items makes this kind of attack impossible and
        therefore eliminates the need for a check.
      </para>
      <para>
        This approach only goes so far, of course. In a different domain, where a client would routinely add hundreds 
        of the same item to an order, having to specify each one individually would be very wasteful in terms of both
        space and time required for transmitting and processing messages. So at some point you need to verify that the
        input supplied by the client meets the criteria that you have set for it.
      </para>
      <para>
        One example in RESTBucks is the <literal>payment</literal> message, which contains an <literal>amount</literal>
        property (see <xref linkend="design-messages"/>). This property is also vulnerable to an attack when the client
        specifies a negative value. So we need to verify that the input is valid.
      </para>
      <para>
        Input validation plays an important role in preventing these kinds of undesired business outcomes. It is also 
        important for preventing security bugs. For instance, in languages like C a client could provide data that
        extends beyond the memory allocated for it (a so-called <firstterm>Buffer Overrun</firstterm> vulnerability), 
        which can lead to all sorts of subsequent problems, like Elevation of Privilege (see
        <xref linkend="security"/>).
      </para>
      <para>
        Remember that the input from the client arrives as part of the HTTP message that a message converter translates
        into a data transfer object, which the HTTP framework subsequently makes available to a controller. This is 
        our first opportunity to validate the input. For the payment example, the controller may look something like
        this:
      </para>
      <programlisting>@RestController
@RequestMapping(Uris.PAYMENT)
public class PaymentController() {
  
  @RequestMapping(method = RequestMethod.POST,
      consumes = Api.MEDIA_TYPE_DEFAULT)
  public void pay(Payment payment) {
    double amount = payment.amount;
    // ...
  }
  
}</programlisting>
      <para>
        Note that our <literal>Payment</literal> data transfer object declares the <literal>amount</literal> field to
        be of type <literal>double</literal>. One could argue that this is the first step in validation, where the type
        of the property is checked. If the provided sequence of bytes doesn't specify a double under the rules of the
        media type, then the message converter will likely throw an exception.
      </para>
      <para>
        This form of validation is <firstterm>syntactic</firstterm> in nature, because you only need to understand the 
        syntax rules governing the value in order to perform the validation.
        Syntactic validation is all about the syntax of the message, and should therefore be handled by the message
        converter. If it encounters the value <literal>foo</literal> for the <literal>amount</literal> property, it can
        throw an <literal>IllegalArgumentException</literal>, which the central error handler will convert to a
        <literal>400 Bad Request</literal> response.
      </para>
      <para>
        <firstterm>Semantic validation</firstterm> is the next step where you perform further checks based on knowledge 
        of what the value represents in the problem domain. In this example, the <literal>amount</literal> should be 
        positive.
      </para>
      <para>
        Since semantic checking depends on an understanding of the problem domain, it must be handled by domain-aware
        code. For generic domain concepts, like email addresses, you may be able to find libraries that perform the
        validation for you. For more specialized domains, you will have to implement the validation yourself.
        There are several ways to accomplish this. 
      </para>
      <para>
        This first is to use an XML or JSON schema to validate the HTTP message body. There are, however, several
        problems with this approach. The first is that schema validation can only go so far: validating individual
        properties will probably work fine, but things get hairy when we want to validate relations between properties.
        For maximum flexibility, we’d like to use a general purpose programming language like Java to express constraints.
      </para>
      <para>
        More importantly, <emphasis>schema validation is generally not a good idea in a REST service</emphasis>.
        A major goal of REST is to decouple client and server so that they can evolve separately. If we validate against 
        a schema, then a new client that sends a new property would break against an old server that doesn’t understand 
        the new property. (We discuss evolution of REST APIs in <xref linkend="maintenance"/>.)
      </para>
      <para>
        It’s better to silently ignore properties you don’t understand. The JAXB serialization library is a good 
        example of this. It also works the other way around: properties that are not sent by an old client end up as 
        <literal>null</literal> in the data transfer object. Consequently, a server must be careful to handle 
        <literal>null</literal> values properly.
      </para>
      <para>
        Instead of schema validation we should use programming language specific validation frameworks, if available.
        For instance, the Java world offers <firstterm>Bean Validation</firstterm> <citation>JSR 303</citation>. With
        Bean Validation, you could add annotations to your data transfer objects to perform semantic checking:
      </para>
      <programlisting>public class Payment {
  @Min(1)
  public double amount;
}

public class PaymentController {
  
  public void pay(@Valid Payment payment) {
    // ...
  }
  
}</programlisting>
      <para>
        The <literal>@Min</literal> annotation declares that the <literal>amount</literal> is only valid when it's at
        least <literal>1</literal>. The <literal>@Valid</literal> annotation on <literal>Payment</literal> declares
        that the Bean Validation framework must validate the data transfer object and throw a
        <literal>ConstraintViolationException</literal> when the object isn't valid. The HTTP framework must call the 
        Bean Validation framework, catch the exception and return <literal>400 Bad Request</literal>.
      </para>
      <para>
        Note that in Spring you can inspect the validation errors by adding an <literal>Errors</literal> parameter
        directly after the parameter with the <literal>@Valid</literal> annotation if you need more control over the
        error handling:
      </para>
      <programlisting>public void pay(@Valid Payment payment, Errors errors) {
  if (errors.hasErrors()) {
    // Handle errors ...
  }
  // ...
}</programlisting>
      <para>
        The <literal>@Valid</literal> approach works as intended when the entire data transfer object is transferred,
        but it breaks down if we start using <literal>PUT</literal> or <literal>PATCH</literal> to update individual
        properties. In RESTBucks we can't update a payment, but we can update an order. Let's look at that example: 
      </para>
      <programlisting>public class OrderResource {
  
  @Name
  public String customer;
  // ...
}

@RestController
@RequestMapping(Uris.ORDER)
public class OrderController {
  
  @RequestMapping(method = PUT, consumes = Api.DEFAULT_MEDIA_TYPES,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public OrderResource update(@PathVariable(Uris.VAR_ORDER_ID) String id,
      @Valid OrderResource order) {
    // ...
  }
  
  @RequestMapping(method = PATCH, consumes = Api.MEDIA_FORM, 
      produces = Api.DEFAULT_MEDIA_TYPES)
  public OrderResource partialUpdate(@PathVariable(Uris.VAR_ORDER_ID) String id, 
      @RequestPart("customer") @Name String customer) {
    // ...
  }
  
}</programlisting>
      <para>
        This example uses a custom <literal>@Name</literal> annotation that validates the customer's name. By the way,
        this is actually a surprisingly difficult thing to get right, so you may want to think twice about it
        <citation>McKenzie10</citation>.
      </para>
      <para>
        As the example shows, we now need to specify the validation annotation in more than one place. In order to
        make this DRY, we need to change the <literal>customer</literal> from a <literal>String</literal> to a new
        class that will handle the validation:
      </para>
      <programlisting><![CDATA[public class Name implements Comparable<Name> {
  private String name;
        
  public Name(@Name String value) {
    this.name = value;
  }
  
  // toString(), compareTo(), hashCode(), equals()
}

public class OrderResource {
  
  public Name customer;
  
}

@RequestMapping(Uris.ORDER)
public class OrderController {
  
  @RequestMapping(method = PUT, consumes = Api.DEFAULT_MEDIA_TYPES,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public OrderResource update(@PathVariable(Uris.VAR_ORDER_ID) String id,
      OrderResource order) {
    // ...
  }
  
  @RequestMapping(method = PATCH, consumes = Api.MEDIA_FORM,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public OrderResource partialUpdate(@PathVariable(Uris.VAR_ORDER_ID) String id, 
      @RequestPart("customer") Name customer) {
    // ...
  }
  
}]]></programlisting>
      <para>
        Now we have nicely DRY code, but it still suffers from a fundamental problem: the <literal>OrderResource</literal>
        class is a data transfer object, while the <literal>Name</literal> class is a domain object, so we're
        mixing different abstraction levels here. It's better to keep them separate:
      </para>
      <programlisting><![CDATA[public class OrderResource {
  
  public String customer;
  // ...
  
  public OrderResource() {
  }
  
  public OrderResource(Order order) {
    customer = order.getCustomer().toString();
    // ...
  }
  
}

public class Order {

  private Name customer;
  
  public Name getCustomer() {
    return customer;
  }
    
  public void setCustomer(Name customer) {
    this.customer = customer;
  }
  
}

@RestController
@RequestMapping(Uris.ORDER)
public class OrderController {
  
  @Autowired
  private OrderRepository orderRepository;
  
  @RequestMapping(method = PUT, consumes = Api.DEFAULT_MEDIA_TYPES,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public OrderResource update(@PathVariable(Uris.VAR_ORDER_ID) String id,
      OrderResource OrderResource) {
    // ...
  }
  
  @RequestMapping(method = PATCH, consumes = Api.MEDIA_FORM,
      produces = Api.DEFAULT_MEDIA_TYPES)
  public OrderResource partialUpdate(@PathVariable(Uris.VAR_ORDER_ID) String id,
      @RequestPart("customer") String customer) {
    Order order = orderRepository.findOne(id);
    if (order == null) {
      throw new NotFoundException();
    }
    order.setCustomer(new Name(customer));
    order = orderRepository.save(order);
    return new OrderResource(order);
  }
  
}]]></programlisting>
      <para>
        This code is DRY <emphasis>and</emphasis> follows the Single Responsibility Principle <citation>SOLID</citation>.
        The DTO only needs to change when we need to optimize the message structure for performance reasons, not when
        our understanding of or support for the problem domain changes.
      </para>
      <para>
        Input validation is a good tool to prevent problems caused by illegal values being used. But legal values can
        sometimes also cause problems. For instance, an order may contain so many items that storing it in the database
        could take a long time. If the service accepts such an order, then it opens the door to a Denial of Service
        attack (see <xref linkend="security"/>). The validation routines should therefore also reject such input.
      </para>
      <para>
        There are two approaches for implementing input validation: <firstterm>whitelisting</firstterm> and
        <firstterm>blacklisting</firstterm>. The first specifies what constitutes valid input and rejects anything that 
        doesn't match the specification. The latter works the other way around: it specifies what is invalid and accepts 
        anything that isn't invalid. Both approaches can benefit greatly from using <firstterm>regular
        expressions</firstterm>.
      </para>
      <para>
        While both approaches can be made to work, blacklisting is much trickier to get right. If you miss a corner
        case an attacker can get in, whereas with whitelisting a missing corner case leads to valid input being rejected.
        Whitelisting thus errs on the side of security.
      </para>
      <para>
        Many developers have trouble accepting that their blacklists are imperfect, but they often are. They simply
        haven't been exposed to the kinds of tricks that hackers have in their bags, like using special Unicode
        characters or doubly encoding input. This is one of those cases where you don't know what you don't know, so
        beware. Just because <emphasis>you</emphasis> can't think of a way to break the blacklist doesn't mean that
        someone else can't.
      </para>
    </section>
    
    <section id="output-encoding">
      <title>Output Encoding</title>
      <para>
        Sometimes there is a security issue that looks like it can be fixed with input validation, but where that is 
        not appropriate. For example, consider the classic <firstterm>SQL Injection</firstterm> vulnerability, where a
        SQL query string is built up using input provided by the client:
      </para>
      <programlisting>String query = "select * from order where customer = '" + customer + "'";
Statement statement = connection.createStatement();
ResultSet results = statement.executeQuery(query);</programlisting>
      <para>
        This code is susceptible to attacks where the client puts a quote in the value for <literal>customer</literal>,
        like <literal>1' OR '1'='1</literal>. Instead of showing the orders for one customer, this will show all
        orders, which is an Information Disclosure vulnerability (see <xref linkend="security"/>).
      </para>
      <para>
        Since the malicious input in this example causes the problem, you may think that we can fix it by fixing the
        input, i.e. by using input validation. We could use the <literal>@Name</literal> validation constraint of the
        previous section and have it refuse names with quotes.
      </para>
      <para>
        This is incorrect and may lead to negative business outcomes. Suppose you were to build an API around Academy
        Award winners and wouldn't be able to accept Tatum O'Neal!
        The problem is not that <literal>O'Neal</literal> is an invalid name, but rather that the name causes 
        problems <emphasis>when used in the context of SQL queries</emphasis>.
      </para>
      <para>
        Such problems call for a solution known as <firstterm>output encoding</firstterm>, where the value is encoded
        in such a way that it can't wreak havoc in that particular context. In the SQL example, the problem is the 
        mixing of code (the SQL query) and data (the name of the customer). Using <firstterm>parameterized
        queries</firstterm> eliminates that confusion:
      </para>
      <programlisting>PreparedStatement statement = connection.prepareStatement(
    "select * from order where customer = ?");
statement.setString(1, customer);
ResultSet results = statement.executeQuery();</programlisting>
      <para>
        The <literal>setString()</literal> method clearly marks the value of <literal>customer</literal> as data, so
        that it can never be confused with code.
      </para>
      <para>
        Other injection attacks are based on the same idea of mixing code and data, and they can also be fixed using
        output encoding. Common examples are XML/HTML and JSON/JavaScript. Even plain text log files can suffer from 
        an injection attack known as <firstterm>log forging</firstterm>, where the meaning of the text changes when it's
        split across multiple lines.
      </para>
      <para>
        Most output contexts that you will encounter are standard contexts that other people use as well, because they
        depend on the technology rather than the problem domain. You should use an existing output encoding library 
        rather than build something yourself, because there are often tricky corner cases that are easy to get wrong. 
        ESAPI is an example of an output encoding library that covers most common output contexts
        <citation>ESAPI</citation>.
      </para>
      <para>
        The type of encoding is specific to the context, so extra special care must be taken when data is used in
        multiple contexts. One example is a client-provided value that is used in a JavaScript string that is then
        embedded in an HTML page. Output encoding must be performed for each context and in the correct order, or else
        vulnerabilities will remain.
      </para>
      <para>
        Output encoding is the mirror twin of input validation. Input validation ensures that all input is properly
        converted to values that meet the constraints of the problem domain. Output encoding conversely ensures that
        these values remain valid in whatever technological context they are used.
      </para>
      <para>
        Input validation and output encoding are simple enough tools, but the real trick is to apply them consistently 
        across the board. An attacker only needs to find one place where they are left out to breach your system. We'll 
        discuss how to ensure that you've covered all your bases in <xref linkend="test-security"/>.
      </para>
    </section>
  </section>
  
  <section>
    <title>Summary</title>
    <para>
      This chapter covers how to implement a REST API in such a way that it is both easy to maintain and secure.
      The DRY and SOLID principles helps keep code in good shape over time. It helps to clearly identify the different
      components that make up the server and honor the boundaries between them. To keep the code secure, we use the
      tools of input validation and output encoding.
    </para>
    <para>
      We'll now turn our attention to verification that the implementation meets the expectations of all stakeholders.
    </para>
  </section>
</chapter>
