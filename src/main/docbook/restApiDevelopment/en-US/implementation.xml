<chapter id="implementation">
  <title>Implementation</title>
  <para>
    TODO: This chapter...
  </para>
  
  <section id="dto">
    <title>Data Transfer Objects</title>
    <para>
      The last couple of decades saw the rise of architectures that separate different concerns into different
      components. These architectures go by names like Model-View-Controller, hexagonal architecture, clean
      architecture, ports and adapters, etc. What they all share is an emphasis on keeping the code that captures the
      domain separate from other code. The domain code is the core of any application, and not likely to change for
      technology reasons. Other parts of the application, deal with things like data persistence and user interfaces
      that are more likely to be affected by technology hype cycles.
    </para>
    <para>
      It's important to understand that the REST architectural style doesn't concern itself with the domain.  
      Remember from <xref linkend="granularity"/> that the HTTP messages that client and server exchange in a RESTful 
      system are data transfer objects (DTOs). DTOs transfer data in a technology neutral way between layers or
      components of the system. In this case, they isolate other code from the media type that was used to serialize
      the messages.
    </para>
    <para>
      DTOs are optimized for data transfer. We saw how performance and scalability concerns may force us to structure
      our messages a certain way. That doesn't mean that the domain has changed, it's simply a design trade-off. It
      then follows that we need to map the DTOs onto domain objects. This mapping can be 1:1, and that's the best way
      to start. But when the need arises to change the message structure for performance or other reasons, resist the
      temptation to modify your domain objects. Instead you should have a mapping layer in place that handles the
      translation.
    </para>
    <para>
      Some frameworks are very easy to work with when the mapping is 1:1, but they get in the way when the mapping 
      becomes more complicated. Again, resist the temptation to go with the tool and change your domain objects.
      Code that matches the domain objects is too valuable to give up. It keeps developers and users on the same page
      and prevents subtle bugs based on misunderstandings <citation>Evans04</citation>.
    </para>
    <para>
      Other frameworks actually help with separating domain code from UI code like REST message DTOs. Those based on
      the <firstterm>Model-View-Controller</firstterm> (MVC) architecture, for instance, clearly distinguish between
      the domain (model), DTO (view), and mapping between them (controller). But even with MVC frameworks there is a
      temptation to put domain logic into controllers. Extracting that out may seem like more work, but that's only
      true in the short term. You can help yourself resist temptation by practicing Domain-Driven Design
      <citation>Evans04</citation>, where you start out with the domain logic and then add other concerns, like
      persistence and a REST API, around it.
    </para>
    <para>
      One example of a Java MVC framework for REST APIs is <citation>Spring WebMVC</citation>. It lets you build REST 
      controllers easily by adding annotations. You can then use Spring's dependency injection to autowire the
      controllers to domain services. Spring WebMVC comes with predefined translations from HTTP messages to Java
      objects (DTOs). The Spring community also supports link relations via the <citation>Spring HATEOAOS</citation>
      project. There is even a contribution for assigning semantics to DTOs and their fields <citation>Spring
      Hydra</citation>.
    </para>
    <para>
      You should have exactly one place in your code where you convert your internal DTO to a message that is sent over 
      the wire and one place where you do the reverse.
      In JAX-RS, for example, that one place should be an Entity Provider. In Spring, the same mechanism is called a 
      Message Converter. Note that both frameworks have support for several often-used serialization formats.
    </para>
    <para>
      Following this advice not only makes it easier to change media types (e.g. from plain JSON or HAL to a more 
      mature media type like JSON-LD with Hydra). It also makes it easy to support multiple media types. This in turn 
      enables you to switch media types without breaking clients, as we'll see in <xref linkend="breaking-changes"/>.
    </para>
    <para>
      A DTO should not have any behavior; it’s purpose in life is to transfer data between remote systems. This is a
      major difference from a domain object.
      There are two basic approaches for dealing with the data in a DTO. 
    </para>
    <para>
      The first is to make them immutable objects, where all the input is provided in the constructor and the data can 
      only be read. This doesn’t work well for large objects, however, and it doesn’t play nice with serialization 
      frameworks.
    </para>
    <para>
      The better approach is to make all the properties writable. Since a DTO must not have logic, this is one of the 
      few occasions where you can safely make the fields public and omit the getters and setters.
			Of course, that means some other part of the code is responsible for filling the DTO with combinations of 
			properties that together make sense. Conversely, you should validate DTOs that come in from the client. We'll
			show you how in <xref linkend="input-validation"/>.
    </para>
  </section>
  
  <section id="dry">
    <title>Keeping it DRY</title>
    <para>
      TODO: Define URL structure, media type, namespace, error handling, etc. in a single place.
    </para>
  </section>

  <section id="reactive">
    <title>Reactive programming</title>
    <para>
      <firstterm>Reactive programming</firstterm> is an emerging discipline which combines concurrency and 
      event-based and asynchronous systems. It is at the core of many high-performance concurrent systems.
    </para>
  </section>

  <section>
    <title>Generating Code From RADL</title>
  </section>

  <section>
    <title>Extracting RADL From Code</title>
  </section>

  <section id="secure-impl">
    <title>Security</title>
    <section id="impl-authz">
      <title>Authorization</title>
	    <para>
	      The traditional way to implement authorization of REST APIs is to specify restrictions at the level of URI and 
	      HTTP method. For instance, this is the approach that Spring Security takes.
	    </para>
	    <para>
	      There are two places where such access control checks comes into play. The first is obviously when receiving a 
	      request. You should also check permissions on any links you want to put in the response. The links that the 
	      requester is not allowed to follow should be omitted from the response, because the links are supposed to be
	      options that the client can choose from for its next move.
	    </para>
	    <para>
	      The problem with specifying access control in terms of URIs and HTTP methods is that these are implementation 
	      details. 
	      URIs shouldn’t be known to anybody but the API designer/developer; the client will discover them through link 
	      relations. Even the HTTP methods can be hidden until runtime with mature media types like JSON-LD with Hydra.
	      This is great for decoupling the client and server, but now we have to specify our security constraints in terms 
	      of implementation details! This means that only the developers can specify the access control policy.
	    </para>
	    <para>
	      This flies in the face of best security practices, where the access control policy is externalized 
	      from the code (so it can be reused across applications) and specified by a security officer rather than a 
	      developer. So how do we satisfy both requirements?
	    </para>
	    <para>
	      The answer lies in the state diagram underlying the REST API. Remember, we want to authorize all transitions. 
	      Yes, a transition in an HTTP-based API is implemented using an HTTP method on a URI. But in REST, we shield the 
	      URI using a link relation. The link relation is very closely related to the type of action you want to perform.
	    </para>
	    <para>
	      The same link relation can be used from different states, so the link relation can’t be the whole answer. We 
	      also need the state, which is based on the representation returned by the REST server. This representation 
	      usually contains a set of properties and a set of links. We’ve got the links covered with the link relations, 
	      but we also need the properties.
	    </para>
	    <para>
	      The link relation indicates the action to be performed, while the properties correspond to 
	      resource attributes. Add to that the subject attributes obtained through the authentication process, and you 
	      have all the ingredients for making an XACML request.
	    </para>
	    <para>
	      TODO: Think this through. When implementing a controller, we no longer have access to the link relation that
	      led to the method being invoked on the URI...
	    </para>
      <para>
        TODO: eXtensible Access Control Markup Language?
      </para>
    </section>
    
    <section id="input-validation">
      <title>Input Validation</title>
    </section>
    
    <section id="output-encoding">
      <title>Output Encoding</title>
    </section>
  </section>
  
  <section id="external">
    <title>Calling external services</title>
    <para>
      TODO: Calling external services. Circuit breakers, etc.
    </para>
  </section>

  <section id="sdk">
    <title>Providing Client Libraries</title>
  </section>

  <section>
    <title>Summary</title>
    <para>
      TODO:
    </para>
  </section>
</chapter>
