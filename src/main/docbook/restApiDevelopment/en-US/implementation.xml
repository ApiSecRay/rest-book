<chapter id="implementation">
  <title>Implementation</title>
  <para>
    We now have a design for an API that meets the requirements, causes the least amount of surprise by reusing
    well-known design patterns, is helpful when things go wrong, gives good performance and scalability, and is secure.
    But until we've implemented that design, we don't actually have anything at all. 
    This chapter discusses some important topics to consider while building a REST server.
  </para>
  
  <section>
    <title>Anatomy of a REST Server</title>
    <para>
      There are a number of areas that each REST API implementation must address. Since it's important to separate
      things that change for different reasons <citation>SOLID</citation>, these areas should be implemented by
      different components, as shown in <xref linkend="rest-server"/>.
    </para>
    <figure id="rest-server">
      <title>The components of a REST server</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/rest-server.png" scale="58" align="center"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
      Here's what each of the components is responsible for:
    </para>
    <variablelist>
      <varlistentry>
        <term>HTTP Server</term>
        <listitem>
          <para>
            The HTTP messages that the client sends must be handled somewhere in the server. A socket must be opened on
            the standard ports 80 (for HTTP) and/or 433 (for HTTPS) or on some custom port. Code must listen on these
            ports and speak the HTTP protocol.
          </para>
          <para>
            There isn't any good reason to build this yourself. You should deploy your code to an HTTP server like
            Tomcat or Apache that handles this for you. Alternatively, you can embed an HTTP server like Jetty in your 
            code.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>HTTP Framework</term>
        <listitem>
          <para>
            The HTTP server will speak the HTTP protocol, but it will not implement your resources. You need to extend
            it so that it will call into your code whenever it sees one of the URIs that identify your resources. An
            HTTP framework provides the glue between the HTTP server and the code that implements the resources.
          </para>
          <para>
            This is another component that you should not write yourself. There are plenty of excellent frameworks out
            there that do this for you, like Jersey or Spring WebMVC. Those frameworks make it easy to link URIs to
            your code, for example using simple annotations.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Controllers</term>
        <listitem>
          <para>
            The actual code that handles the HTTP methods on a resource is known as a <firstterm>controller</firstterm>.
            This term comes from the <firstterm>Model-View-Controller</firstterm> (MVC) design pattern
            <citation>GammaEtAl94</citation>.
          </para>
          <para>
            MVC isn't the only possible architecture for a REST server. Similar approaches like hexagonal architecture, 
            clean architecture, ports and adapters, etc., work too. In the following discussion we'll assume MVC, but 
            the main ideas work equally well for any of the other approaches.
          </para>
          <para>
            The "controller" part of MVC binds the data from the model to the presentation in the view and attaches 
            logic from the model to affordances in the presentation. For REST APIs, those affordances are the HTTP
            methods of the uniform interface.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Message converters</term>
        <listitem>
          <para>
            The HTTP server handles most of the HTTP protocol, but not all. The HTTP protocol is extensible, for 
            example, media types define how the content of the HTTP message body is encoded (see
            <xref linkend="media-types"/>).
          </para>
          <para>
            While HTTP servers handle standard media types used on the Web, like <literal>text/html</literal>, they may
            not handle the one(s) you selected for your REST API.
          </para>
          <para>
            The HTTP framework may be able to handle additional media types that are often used in REST APIs, like
            <literal>application/json</literal> and <literal>application/xml</literal>. It does this through
            <firstterm>serialization libraries</firstterm> like JAX-B and Jackson. Different frameworks use different
            names for these media type handlers; in this book we'll borrow the term <firstterm>message
            converter</firstterm> from Spring.
          </para>
          <para>
            In addition to providing some default message converters, HTTP frameworks also allow you to register new
            ones to handle unsupported media types. You should use this extensibility feature to write your own message
            converter if needed rather than limit your choice of media type to the selection that the HTTP framework
            offers out of the box. It's usually not all that hard to implement a new message converter based on existing
            ones.
          </para>
          <para>
            Separating out message converters from other code makes it easier to change media types (e.g. from plain
            JSON or HAL to a more mature media type like JSON-LD with Hydra). It also makes it easy to support multiple
            media types. This in turn enables you to switch media types without breaking clients, as we'll see in
            <xref linkend="breaking-changes"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Data transfer objects</term>
        <listitem>
          <para>
            In a REST API, the "view" part of MVC is the data content that is serialized in the body of the HTTP
            message. The message converter translates those bytes, whose meaning is defined by the media type, into a
            programming language object known as a data transfer object (DTO). As we saw in
            <xref linkend="granularity"/>, a DTO is an object that carries data between processes.
          </para>
          <para>
            There are two basic approaches for constructing DTOs. The first is to make them immutable objects, where
            all the input is provided in the constructor and the data can only be read. This doesn’t work well for
            large or deeply nested objects, however, and it doesn’t play nice with serialization frameworks.
          </para>
          <para>
            The better approach is therefore to make all the properties writable. Since a DTO must not have logic, this 
            is one of the few occasions where you can safely make the fields public and omit getters and setters.
          </para>
          <para>
            Of course, that means that some other part of the code is responsible for checking whether individual
            values in the DTO make sense, and whether the different values make sense together. We'll discuss this 
            topic in <xref linkend="input-validation"/>.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Domain objects</term>
        <listitem>
          <para>
            The "model" in the MVC pattern is the domain model. Domain model objects capture the logic of your problem 
            domain in a way that is decoupled from technology like databases and UI <citation>Evans04</citation>.
          </para>
          <para>
            We believe the easiest way to achieve this decoupling is to practice Domain-Driven Design (DDD)
            <citation>Evans04</citation>, where you start out with the domain logic and then add other concerns, like
            persistence and a REST API, around it.
          </para>
          <para>
            Other approaches can work as well. Whatever approach you choose to follow, make sure to separate the domain
            logic from the controllers and clearly distinguish between data transfer objects and domain objects.
          </para>
          <para>
            Data transfer objects transfer data between processes; in this case between a REST client and server. They
            don't have any behavior associated with them; they just exposes data. A domain object, in contrast, is all
            about encapsulating data rather than exposing it. You use domain objects for their behavior rather than
            their data.
          </para>
          <para>
            Domain objects are <emphasis>discovered</emphasis> during analysis, while data transfer objects are
            <emphasis>designed</emphasis> and thus are subject to all kinds of design trade-offs. As we saw in
            <xref linkend="granularity"/>, performance and scalability concerns may prompt us to change the structure
            of our messages in a certain way. That doesn't mean that the problem domain has changed, however, and thus 
            should not lead to changes in the domain objects.
          </para>
          <para>
            So while there is a certain degree of overlap between the data exposed by a data transfer object and that
            encapsulated by a domain object, there isn't necessarily a one-to-one correspondence. It then follows
            that we need to map the DTOs onto domain objects and back.
          </para>
          <para>
            This mapping can be 1:1, and that's the best way to start. But when the need arises to change the message
            structure for performance or other reasons, resist the temptation to modify your domain objects. Instead
            put a mapping layer in place to handles the translation from DTO to domain object and back.
          </para>
          <para>
            Since this mapping is part of binding the "model" (domain) and "view" (data transfer object) parts of MVC,
            the right place to implement it is in the controller.
          </para>
          <para>
            Some frameworks are very easy to work with when the mapping is 1:1, but they get in the way when the mapping 
            becomes more complicated. Again, resist the temptation to go with the tool and change your domain objects.
            Code that matches the domain objects is too valuable to give up: it keeps developers and users on the same
            page and prevents subtle bugs based on misunderstandings <citation>Evans04</citation>.
          </para>
          <para>
            <firstterm>Dependency injection</firstterm> is a design pattern where an object doesn't create or look up
            its dependencies itself, but rather gets told from the outside what they are. One application of this
            pattern is to inject domain objects as dependencies into controllers, so that the controllers can call the
            domain objects to execute business logic.
          </para>
          <para>
            Domain-driven design distinguishes between different kinds of domain objects, like entities (something with
            an identity, such as a person), value objects (something without identity, such as a dollar amount), and
            services (an operation that doesn't conceptually belong in one object, such as paying an order). Like REST
            services, domain services are stateless. They are often injected as dependencies into controllers.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Persistency</term>
        <listitem>
          <para>
            Remember from <xref linkend="rest"/> that state in a RESTful system is separated into application state and
            resource state. Application state is maintained on the client, which we'll discuss in
            <xref linkend="client"/>.
          </para>
          <para>
            Resource state is maintained on the server, so you'll need some sort of database to persist it.
            There are a lot of options for doing so. Traditionally, persistency meant storing data in a relational
            database and that may be the right answer for you today.
          </para>
          <para>
            But if your API is publicly accessible by just about anybody, then you may need a solution that is more
            specifically tailored to that kind of scale, like a NoSql database. There are many options out there, like
            Cassandra, CouchDB, etc., so you'll have to do some homework to pick the right tool for your job.
          </para>
          <para>
            To keep your domain objects independent from your persistency solution, you may want to introduce an
            abstraction known as a <firstterm>Data Access Layer</firstterm> (DAL). The DAL should be captured in a
            technology-independent way, so you can inject it as a dependency into your domain objects without binding 
            the domain model to a specific database technology.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      <xref linkend="rest-server"/> shows the relationships between the components. Components in blue are standard
      components, while those in yellow and red are specific to your project. The difference is that yellow components
      can be generated, as we'll see in <xref linkend="radl-supports-implementation"/>, while red components must be
      hand-coded. Green components may be either standard or project-specific. So in the best case scenario, you only
      have to implement the domain model yourself.
    </para>
    <para>
      For each standard component you can look for the best implementation for your specific situation.
      Alternatively, you can use a suite of components that are proven to work well together. An example of the latter
      for Java is offered by the Spring community:
    </para>
    <itemizedlist>
      <listitem>
        <para>
         The <citation>Spring WebMVC</citation> project lets you build REST controllers by adding annotations to your
         POJOs. It comes with some predefined message converters, like for <literal>application/json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring HATEOAOS</citation> project adds support for link relations and a message converter for
          <literal>application/hal+json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring Hydra</citation> community contribution adds support for actions and semantics, and a
          message converter for <literal>application/ld+json</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          The <citation>Spring Data</citation> project adds support for a Data Access Layer.
        </para>
      </listitem>
      <listitem>
        <para>
          Finally, Spring's dependency injection glues everything together <citation>Spring Platform</citation>.
          For instance, you can use annotations to automatically wire controllers to domain services.
        </para>
      </listitem>
    </itemizedlist>      
  </section>
  
  <section id="dry">
    <title>Keeping it DRY</title>
    <para>
      An important principle in software development is <firstterm>Don't Repeat Yourself</firstterm> (DRY). By making
      sure that every concept is expressed in one place only, you decrease your maintenance burden and keep your
      velocity up.
    </para>
    <para>
      If you clearly distinguish the components described in the previous section, you're already in a good position,
      but there is more you can do. The domain model is a good example of this: every concept from the problem domain
      should be captured in one place in the code (e.g. in one class).
    </para>
    <para>
      The DRY guideline is helpful in controllers as well. Controllers bind code to resources and media types.
      Most of your controllers will work with the same media type, so there may be a temptation to spread this choice
      all over your code. For instance, the following code snippet uses the <literal>@Produces</literal> JAX-RS
      annotation to specify which media type to use as the <literal>Content-Type</literal> of the response:
    </para>
    <programlisting>@GET
@Produces("application/ld+json")
public HomeDto get() {
  return new HomeDto();
}</programlisting>
    <para>
      This looks fine in isolation, but if you code all your controllers like this, the string
      <literal>"application/ld+json"</literal> will be all over the place. It's better to use a constant instead, e.g.
      <literal>@Produces(Api.MEDIA_TYPE_APPLICATION_LD_JSON)</literal>.
      Here we've created a new <literal>Api</literal> class to hold a constant for the media type.
    </para>
    <para>
      If you've selected a media type for which your HTTP framework has native support, then you probably can use a
      constant defined by the HTTP framework rather than your own. For instance, JAX-RS has a
      <literal>MediaTypes</literal> class with constants for basic media types like <literal>application/json</literal>
    </para>
    <para>
      Imagine what would have to happen if we were to change media type. We'd introduce a new constant for the new 
      media type and we'd still have to go in and update all our controllers. We could ease our pain by using a
      refactoring tool to rename the constant, but we'd still have to submit changes to all our controllers to our 
      version control system.
    </para>
    <para>
      We can prevent that by introducing another layer of indirection:
    </para>
    <programlisting>String MEDIA_TYPE_DEFAULT = MEDIA_TYPE_APPLICATION_LD_JSON;
String MEDIA_TYPE_APPLICATION_LD_JSON = "application/ld+json";</programlisting>
    <para>
      We can now use <literal>@Consumes(Api.MEDIA_TYPE_DEFAULT)</literal> in our controllers, and they won't need to
      change if we decide to use a different media type.
    </para>
    <para>
      We're still not completely out of the woods, however. As we'll see in <xref linkend="breaking-changes"/>, we'll
      sometimes want to <emphasis>add</emphasis> a supported media type rather than replace it. In that case we'd still 
      have to go in and change all our controllers. We can prevent that by using an array of media types instead of a
      single one:
    </para>
    <programlisting>String[] MEDIA_TYPE_DEFAULT = { MEDIA_TYPE_APPLICATION_LD_JSON };
String MEDIA_TYPE_APPLICATION_LD_JSON = "application/ld+json";</programlisting>
    <para>
      The use of media types is but one example of the DRY principle at work. You should do something similar for
      URLs, namespaces (if you use XML-based media types), link relations, error constants, etc. 
    </para>
    <para>
      Some of the identifiers in that list are part of your API, like link relations, while others are implementation
      choices, like the URLs used to identify resources. Don't put all of these in the same location, because they will
      change for different reasons.
    </para>
    <para>
      In the example above, we've put the constants for the media types in a class called <literal>Api</literal>. You
      can collect all identifiers there that are part of your API. That makes it possible to publish the
      <literal>Api</literal> class somewhere where clients can consume it. This is actually the beginning of an SDK!
      We'll talk more about SDKs in <xref linkend="sdk"/>.
    </para>
    <para>
      We just said that URLs are implementation choices, but that's only partially true. There is one URL that is
      actually part of your API: the billboard URI. The constant for this URL should therefore be part of the
      <literal>Api</literal> class rather than the internal class that contains the other URLs.
    </para>
    <para>
      Another example of using the DRY guideline is with URLs. Since URLs are hierarchical in nature, it makes sense to 
      define one URL constant in terms of another, for example:
    </para>
    <programlisting>String URL_ORDERS = "/orders/";
String URL_ORDER = URL_ORDERS + "{id}/";</programlisting>
    <para>
      Sometimes duplication is a little harder to spot. A common place in REST servers where this happens is with error
      handling code. It's tempting to catch exceptions in your controllers and translate them to appropriate status
      codes there, but it's better to do that in a central location. Without such centralization, you run the risk of
      handling exceptions inconsistently.
    </para>
    <para>
      Different HTTP frameworks support this in different ways. For example, in Spring you can use a combination of the
      <literal>ControllerAdvice</literal> and <literal>ExceptionHandler</literal> annotations to centralize exception
      handling:
    </para>
    <programlisting><![CDATA[@ControllerAdvice
public class CentralErrorHandler {

 @ExceptionHandler({OrderNotFoundException.class})
 public ResponseEntity<String> orderNotFound(OrderNotFoundException e) {
  return new ResponseEntity<String>(Api.ERROR_NOT_FOUND,
      HttpStatus.NOT_FOUND);
 }
       
 @ExceptionHandler({ItemOutOfStockException.class})
 public ResponseEntity<String> itemOutOfStock(ItemOutOfStockException e) {
  return new ResponseEntity<String>(Api.ERROR_ITEM_OUT_OF_STOCK,
      HttpStatus.BAD_REQUEST);
 }
 
 // Other exception handlers...
}]]></programlisting>
    <para>
      As the above example shows, it makes sense to define custom exception classes for each of the API's error
      conditions (see <xref linkend="error"/>). This facilitates translation to error messages and helps with providing
      details and/or recovery options to the client (not shown in the example).
    </para>
  </section>

  <section id="external">
    <title>Calling external services</title>
    <para>
      TODO: Calling external services. Circuit breakers, etc.
    </para>
  </section>

  <section id="reactive">
    <title>Reactive programming</title>
    <para>
      <firstterm>Reactive programming</firstterm> is an emerging discipline which combines concurrency and event-based
      and asynchronous systems <citation>Reactive Manifesto</citation>. It is at the core of many high-performance
      concurrent systems.
    </para>
  </section>

  <section id="secure-impl">
    <title>Security</title>
    <section id="impl-authz">
      <title>Authorization</title>
	    <para>
	      The traditional way to implement authorization of REST APIs is to specify restrictions at the level of URI and 
	      HTTP method. For instance, this is the approach that Spring Security takes.
	    </para>
	    <para>
	      There are two places where such access control checks comes into play. The first is obviously when receiving a 
	      request. You should also check permissions on any links you want to put in the response. The links that the 
	      requester is not allowed to follow should be omitted from the response, because the links are supposed to be
	      options that the client can choose from for its next move.
	    </para>
	    <para>
	      The problem with specifying access control in terms of URIs and HTTP methods is that these are implementation 
	      details. 
	      URIs shouldn’t be known to anybody but the API designer/developer; the client will discover them through link 
	      relations. Even the HTTP methods can be hidden until runtime with mature media types like JSON-LD with Hydra.
	      This is great for decoupling the client and server, but now we have to specify our security constraints in terms 
	      of implementation details! This means that only the developers can specify the access control policy.
	    </para>
	    <para>
	      This flies in the face of best security practices, where the access control policy is externalized 
	      from the code (so it can be reused across applications) and specified by a security officer rather than a 
	      developer. So how do we satisfy both requirements?
	    </para>
	    <para>
	      The answer lies in the state diagram underlying the REST API. Remember, we want to authorize all transitions. 
	      Yes, a transition in an HTTP-based API is implemented using an HTTP method on a URI. But in REST, we shield the 
	      URI using a link relation. The link relation is very closely related to the type of action you want to perform.
	    </para>
	    <para>
	      The same link relation can be used from different states, so the link relation can’t be the whole answer. We 
	      also need the state, which is based on the representation returned by the REST server. This representation 
	      usually contains a set of properties and a set of links. We’ve got the links covered with the link relations, 
	      but we also need the properties.
	    </para>
	    <para>
	      The link relation indicates the action to be performed, while the properties correspond to 
	      resource attributes. Add to that the subject attributes obtained through the authentication process, and you 
	      have all the ingredients for making an XACML request.
	    </para>
	    <para>
	      TODO: Think this through. When implementing a controller, we no longer have access to the link relation that
	      led to the method being invoked on the URI...
	    </para>
      <para>
        TODO: eXtensible Access Control Markup Language?
      </para>
    </section>
    
    <section id="input-validation">
      <title>Input Validation</title>
    </section>
    
    <section id="output-encoding">
      <title>Output Encoding</title>
    </section>
  </section>
  
  <section id="radl-supports-implementation">
    <title>RADL Support During Implementation</title>
    <para>
      Some of the components of a REST server that we saw in <xref linkend="rest-server"/> are unique to the service
      the API is providing, but other parts are more or less boiler plate code. If you're following the design-first
      approach with an API description language (see <xref linkend="radl"/>), you may be able to generate some code.
    </para>
    <para>
      For example, the Spring code generator for RADL creates the following classes for you:
    </para>
    <variablelist>
      <varlistentry>
        <term><literal>Api</literal></term>
        <listitem>
          <para>
            Constants for the billboard URI, link relations, media types, and error conditions.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><literal>Uris</literal></term>
        <listitem>
          <para>
            Constants for the URIs that identify the resources.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Controllers</term>
        <listitem>
          <para>
            The URI mapping, HTTP method handlers and media type declarations for each resource. The handlers delegate
            to services that are injected.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Services</term>
        <listitem>
          <para>
            Skeleton code for the services.
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>
      The code is divided into two parts. The first part is completely specified by the API description and is under
      control of the code generator. Any changes to this code will be overwritten. The second part is skeleton code
      that the developer is supposed to implement. These files are under control of the developer and will never be
      overwritten.
    </para>
    <para>
      This division makes it possible to add code generation to the automated build process. There are plugins for
      build tools to make this even easier. At the time of writing there is support for Gradle, Maven, and command-line
      builds.
    </para>
    <para>
      Generating code pays back some of the effort put into maintaining an API description. At the time of writing
      there is no support for creating RADL files, so this is a manual activity. But it's easy to see how tooling could
      be built to help with that.
    </para>
    <para>
      For instance, an IDE plug-in could walk an API designer through the steps of procedure
      "<xref linkend="state-diagram-to-resource-model"/>" (see <xref linkend="design"/>). It's even conceivable that
      API descriptions can be kickstarted from BDD scenarios, following procedure
      "<xref linkend="bdd-scenario-to-state-diagram"/>" of <xref linkend="bdd-to-sd"/>.
    </para>
    <para>
      Manually writing an API description for a large existing service is tedious. Fortunately, there is also RADL
      tooling that is useful in a code-first approach. At the time of writing, either Spring or JAX-RS code can be
      analyzed and turned into a RADL file, although the tooling isn't as far along as for the design-first approach.
    </para>
    <para>
      RADL extraction doesn't have to be a one-time event either. You can update the code and run the extraction tool
      again to update your RADL file. Any manual updates to the API description are preserved. Documentation for
      resources, etc. is extracted from JavaDoc comments, so developers can stay close to the code.
    </para>
    <para>
    </para>
  </section>

  <section>
    <title>Summary</title>
    <para>
      TODO:
    </para>
  </section>
</chapter>
