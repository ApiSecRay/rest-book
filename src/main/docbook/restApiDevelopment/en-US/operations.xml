<chapter id="operations">
  <title>Operations</title>
  <para>
    Now that we have a fully functional implementation of the API that is known to meet expectations, we're ready to
    deploy the server into production and derive business value from it.
  </para>
  <para>
    Traditionally, development and operations groups have been separate teams with very different skill sets and goals.
    Just like Agile software development has merged many coding and testing efforts into a single development team, many
    organizations are moving to integrate development and operations into DevOps teams.   
  </para>
  <para>
    However you choose to organize it, most software requires work to run it. Servers must be provisioned, software
    installed and patched, etc. For some software this is easier than for others. We use the term 
    <emphasis>operability</emphasis> to indicate how easy it is to operate a product.
  </para>
  <para>
    Operability is one of the non-functional requirements that is often forgotten early on in the development lifecycle 
    (see <xref linkend="non-functional-requirements"/>). Yet with a little bit of thinking ahead, we can make our lives
    a lot easier later on. Remember that most of a software product's life is spent running.
  </para>
  <para>
    This chapter discusses some issues that often come up when running software with REST APIs in production.
  </para>
  
  <section>
    <title>Separating Configuration From Code</title>
    <para>
      One of the best practices for running software is to separate configuration from code. 
      <firstterm>Configuration</firstterm> encompasses information that is likely to differ from one environment to the 
      next. By separating it from the code you prevent having to change your code for every deployment.
    </para>
    <para>
      For programs with REST APIs, you should make the billboard URI part of the program's configuration, so that you
      can easily make the program available in different locations for different purposes. For instance, you'd want
      different instances of your programming running for development, testing, and production. But you may also want
      different instances running in production, say for different SLAs, or for sales demos. You may even offer a
      sandbox where interested people can try out your program, or where partners may test their add-ons against your
      API. This may be as simple as running the program on a different host, or it may involve configuring different
      URIs on the same host.
    </para>
    <para>
      If your program is part of a collection of microservices, then you will also want to make the locations of the
      other microservices part of the configuration. It may be worthwile to use a special <literal>service 
      discovery</literal> solution for this purpose. These programs maintain a registry of what microservices run where.
      This level of indirection shields decreases the configuration for each microservice, since they now only need to
      know where the service registry runs.
    </para>
    <para>
      One thing that all software should externalize in configuration, is passwords and other credentials. These change
      from environment to environment, like other configuration, but there are additional considerations. In case of
      a breach, you want to be able to change compromised credentials quickly, and changing code, testing it, and 
      deploying it into production is simply not quick enough. Also, developers in many environments may not have access 
      to production passwords, for external compliance or internal policy reasons.
    </para>
    <para>
      There are several ways to separate configuration from code. One way of doing that is using environment 
      variables, as is recommended for so-called twelve-factor apps <citation>12factor</citation>. Environment variables
      are a low-tech solution that is available on any conceivable platform. For this reason, this approach works well
      when deploying software into a Platform-as-a-Service (PaaS) solution like CloudFoundry or Heroku.
    </para>
    <para>
      Other solutions can work as well. Configuration files that the program reads on startup or when it needs
      information offer a bit more structure than environment variables. Structured data formats like XML, JSON, or YAML 
      work well for configuration files. Another solution would be to use the Windows registry.
    </para>
    <para>
      There exists a class of tools known as <firstterm>configuration management software</firstterm> that can maintain
      external configuration for you. Tools like Puppet, Chef, and Ansible let you manage your configuration from a
      single location. Perhaps more importantly, they let you treat the configuration as code, storing it in version
      control, etc. This helps streamline processes around updating configuration, as is common in DevOps teams.   
    </para>
    <para>
      The alternative to configuration management tools that <emphasis>push</emphasis> the configuration to the program 
      is to let the program <emphasis>pull</emphasis> in the information it needs. For this you need a 
      <firstterm>configuration server</firstterm> that stores the configuration for all programs in a given environment. 
      The only configuration that you then still need for the program itself is the location of the configuration
      server. Each environment has its own configuration server that serves configuration applicable for that
      environment only.
    </para>
    <para>
      Building your own configuration server isn't all that hard, but you have to ask yourself whether this is something
      you should be spending your time on. The problem of serving configuration to programs isn't domain-specific, so
      it makes more sense to re-use an existing solution like Consul or Etcd. If you're deploying to a PaaS like
      CloudFoundry, then the PaaS may also play the role of configuration server, usually by providing the program with
      configuration in environment variables.
    </para>
  </section>
  
  <section id="logging">
    <title>Logging and Monitoring</title>
    <para>
      <firstterm>Logging</firstterm> is the act of spitting out information about the state of the application while it 
      runs. While in theory one can write log output to any medium, in practice logging goes to either the console or 
      to file. The former is the simplest and is favored in twelve-factor apps, because the PaaS in which these apps
      run provides facilities to further process the output.
    </para>
    <para>
      For instance, log output from multiple apps and multiple instances of the same app can be combined into a central
      log database that can be queried. Some of these queries can even happen automatically and the information thus 
      obtained can power statistics and graphs on production dashboards.
    </para>
    <para>
      Log files can be more convenient than the console if you don't have access to the aforementioned log 
      infrastructure. They are a sink in which information is collected, so the developer can analyze them at a later 
      time rather than having to watch the output fly by in real time.
    </para>
    <para>
      There exists several logging frameworks that can output to either the console, log files, or both. You should use 
      such a framework and make the destination a configuration option, so that you get the best of both worlds.
    </para>
    <para>
      There are two reasons for logging:
    </para>
    <orderedlist>
       <listitem>
         <para>
           To aid in finding and solving problems.
         </para>
       </listitem>
       <listitem>
         <para>
           To gather statistics about the application's usage.
         </para>
       </listitem>
    </orderedlist>
    <para>
      Logging can support both because it can look at what's happening inside the application.
    </para>
    <para>
      Logging can aid a developer in debugging an issue, which is an ad-hoc way of using log output. It can be very 
      instructive to use correlation IDs, especially in a microservices architecture (see <xref linkend="correlation"/>). 
      This allows you to see the connection between otherwise distinct messages and build up a global understanding of 
      how the system behaves when used by real users.
    </para>
    <para>
      Hopefully this pictures matches the expectations, but that isn't always the case. It's certainly possible to miss
      certain usage patterns during development. This usually leads to tests that don't accurately reflect the real use
      (see <xref linkend="test"/>). By measuring how users actually use the application we can improve our tests and
      close the feedback loop.
    </para>
    <para>
      While support for debugging is important in development and troubleshooting scenarios, it is fundamentally an 
      ad-hoc activity. You can also take a more structured approach by setting up monitoring tools that automatically
      look at the logs. These tools can be configured to recognize certain events in the log output and raise an
      <literal>alert</literal> when such an event occurs.
    </para>
    <para>
      Alerts can take many forms. They can be emails or pager messages that prompt a human to look at the event and 
      determine the appropriate course of action. You must take care to configure the alerts appropriately; if the tool 
      acts as the boy who cried wolf, then in time human operators will start to ignore the alerts.
    </para>
    <para>
      The next step in automation is when the monitoring tool takes automatic action without human intervention. The 
      tool could recognize that an application has crashed and automatically restart it, for instance (although this is 
      usually the job of a PaaS). The monitoring tool can even analyze and correlate multiple events and draw
      conclusions from emerging patterns and deviations from normal, as in the case of fraud detection tools.
    </para>
    <para>
      Debugging and alerting are reactive activities, prompted by seeing undesired events. But logging can also play a
      more positive role by making measurements that fuel future improvement initiatives.
    </para>
    <para>
      You should define a couple of <firstterm>Key Performance Indicators</firstterm> (KPIs) for your API, numbers that 
      ideally clearly express how well the application is doing in a certain dimension. For instance, the Apdex value 
      concisely captures the performance of the application from the user's perspective <citation>Apdex</citation>. 
      Advanced organizations can even automatically roll back changes when a drop in Apdex is detected.
    </para>
    <para>
      Some KPIs are particularly important for applications with REST APIs. They can help you drive adoption of your 
      API by improving the Developer eXperience (see <xref linkend="dx"/>). The percentage of client errors, as 
      indicated by 4xx status codes, for instance, says something about how easy or hard it is to use the API correctly. 
      TODO: What else? See Apigee whitepaper
    </para>
    <para>
      Ultimately the KPIs you track must roll up into the overall business' KPIs, like revenue and profit. These global
      KPIs are backward looking in the sense that they tell you how well you did over the last period. While this is
      important for reporting purposes, they are not very actionable.
    </para>
    <para>
      You need to decompose the global KPIs into other KPIs that are more forward looking and predictive. For instance,
      revenue can be decomposed in number of users and Average Revenue Per User (ARPU). Increasing either of these
      numbers will increase revenue, but you go about increasing them in different ways.
    </para>
    <para>
      Consider the number of users. Most services have a so-called <firstterm>sales funnel</firstterm>, as depicted in
      <xref linkend="funnel"/>. The funnel consists of various stages that users have to go through before they can
      generate revenue. They can get stuck at each stage, so measuring the <firstterm>conversion rate</firstterm> at
      each stage is important. You do that by logging the events of moving to a new stage.
    </para>
    <para>
      The KPIs that are most relevant vary by API and by the goals they serve. Financial goals like revenue are common,
      but not every API is about making money. You should have put some thought into why you want to operate an API
      before you started building and operating it, so it shouldn't be too hard to come up with KPIs that work for you.
    </para>
    <figure id="funnel">
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/funnel.png" scale="68" align="center"/>
        </imageobject>
      </mediaobject>
      <title>Sales funnel</title>
    </figure>
  </section>
  
  <section id="sec-ops">
    <title>Security</title>
    <para>
      We discussed vulnerabilities in some detail in <xref linkend="security"/>, but there is an operational side to 
      them as well that we should look at.
    </para>
	  <para>
	    Vulnerabilities may be known or unknown. The latter are called <firstterm>zero-day</firstterm> vulnerabilities,
	    because we start counting days when we first become aware of a vulnerability. There is a lively black market 
	    for zero days. To counterbalance that, more and more companies have started <firstterm>bug bounty 
	    programs</firstterm>, where they pay people who report vulnerabilities to them, so they can fix them before
	    they are exploited.
	  </para>
	  <para>
	    Vulnerabilities may be discovered by criminals or other malicious agents, by <firstterm>security
	    researchers</firstterm>, by users of the API, or by the provider of the API itself. Security researches and 
	    users will generally report them to the provider so they can be fixed. Some security researchers give the
	    provider some time to fix vulnerabilities, after which they will <firstterm>disclose</firstterm> them. This 
	    means that they publicize their results, which usually contains a proof of concept that shows how to exploit
	    the vulnerability.
	  </para>
	  <para>
	    There is a strong debate about vulnerability disclosure. At one extreme, some researchers disclose anything
	    they find immediately. This means that the vulnerabilities can now be exploited, and users are at risk.
	    For this very reason, other people prefer to keep the vulnerabilities a secret until a fix is available. The
	    middle ground is taken by people who will give providers a certain amount of time, say 90 days, after which
	    they will disclose.
	  </para>
	  <para>
	    At the very least, you should offer a way for people to report vulnerabilities. If you don't you risk that
	    any vulnerabilities that are found are made public before you get a chance to protect your customers' data.
	    Our advice is to follow the convention of setting up an email address named 
	    <literal>security@yourcompany.com</literal> where vulnerabilities can be reported. Always thank anyone
	    using that email address for helping you out, and work closely with them to reproduce and fix the issue.
	  </para>
	  <para>
	    You should add a section to your website that describes in detail how you would like to see vulnerabilities 
	    reported. This should obviously include the security email address, but also very specific instructions on what 
	    information you want to receive and in what form.
	  </para>
	  <para>
	    You can also start your own bug bounty program. This may or may not make sense for your API, depending on a lot 
	    of factors such as how widely your API is used and how valuable the data is that flows through it.
	  </para>
  </section>
  
  <section id="support">
    <title>Support</title>
  </section>
  
  <section>
    <title>Summary</title>
  </section>
</chapter>
