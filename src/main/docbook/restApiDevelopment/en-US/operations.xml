<chapter id="operations">
  <title>Operations</title>
  <para>
    Now that we have a fully functional implementation of the API that is known to meet expectations, we're ready to
    deploy the server into production and derive business value from it.
  </para>
  <para>
    Traditionally, development and operations groups have been separate teams with very different skill sets and goals.
    Just like Agile software development has merged many coding and testing efforts into a single development team, many
    organizations are moving to integrate development and operations into DevOps teams.   
  </para>
  <para>
    However you choose to organize it, most software requires work to run it. Servers must be provisioned, software
    installed and patched, etc. For some software this is easier than for others. We use the term 
    <emphasis>operability</emphasis> to indicate how easy it is to operate a product.
  </para>
  <para>
    Operability is one of the non-functional requirements that is often forgotten early on in the development lifecycle 
    (see <xref linkend="non-functional-requirements"/>). Yet with a little bit of thinking ahead, we can make our lives
    a lot easier later on. Remember that most of a software product's life is spent running.
  </para>
  <para>
    This chapter discusses some issues that often come up when running software with REST APIs in production.
  </para>
  
  <section>
    <title>Separating Configuration From Code</title>
    <para>
      One of the best practices for running software is to separate configuration from code. 
      <firstterm>Configuration</firstterm> encompasses information that is likely to differ from one environment to the 
      next. By separating it from the code you prevent having to change your code for every deployment.
    </para>
    <para>
      For programs with REST APIs, you should make the billboard URI part of the program's configuration, so that you
      can easily make the program available in different locations for different purposes. For instance, you'd want
      different instances of your programming running for development, testing, and production. But you may also want
      different instances running in production, say for different SLAs, or for sales demos. You may even offer a
      sandbox where interested people can try out your program, or where partners may test their add-ons against your
      API. This may be as simple as running the program on a different host, or it may involve configuring different
      URIs on the same host.
    </para>
    <para>
      If your program is part of a collection of microservices, then you will also want to make the locations of the
      other microservices part of the configuration. It may be worthwile to use a special <firstterm>service 
      discovery</firstterm> solution for this purpose. These programs maintain a registry of what microservices run where.
      This level of indirection decreases the amount of configuration for each microservice, since they now only need to
      know where the one service registry runs instead of where all the microservices run that they want to call.
    </para>
    <para>
      One thing that all software should externalize in configuration, is passwords and other credentials. These change
      from environment to environment, like other configuration, but additional considerations apply. In case of
      a breach, you want to be able to change compromised credentials quickly, and changing code, testing it, and 
      deploying it into production is simply not fast enough. Also, developers in many environments are not allowed to 
      have access to production passwords, for external compliance or internal policy reasons.
    </para>
    <para>
      There are several ways to separate configuration from code. One way of doing that is using environment 
      variables, as is recommended for so-called twelve-factor apps <citation>12factor</citation>. Environment variables
      are a low-tech solution that is available on any conceivable platform. For this reason, this approach works well
      when deploying software into a Platform-as-a-Service (PaaS) solution like CloudFoundry or Heroku.
    </para>
    <para>
      Other solutions can work as well. Configuration files that the program reads on startup or when it needs
      information offer a bit more structure than environment variables. Structured data formats like XML, JSON, or YAML 
      work well for configuration files. Another solution would be to use the Windows registry.
    </para>
    <para>
      There also exists a class of tools known as <firstterm>configuration management software</firstterm> that can
      maintain external configuration for you. Tools like Puppet, Chef, and Ansible let you manage your configuration
      from a single location. Perhaps more importantly, they let you treat the configuration as code, storing it in
      version control, etc. This helps streamline processes around updating configuration, as is common in DevOps teams.
    </para>
    <para>
      The alternative to configuration management tools that <emphasis>push</emphasis> the configuration to the program 
      is to let the program <emphasis>pull</emphasis> in the information it needs. For this you need a 
      <firstterm>configuration server</firstterm> that stores the configuration for all programs in a given environment. 
      The only configuration that you then still need for the program itself is the location of the configuration
      server. Each environment should have its own configuration server that serves configuration applicable for that
      environment only.
    </para>
    <para>
      Building your own configuration server isn't all that hard, but you have to ask yourself whether this is something
      you should be spending your time on. The problem of serving configuration to programs isn't domain-specific, so
      it makes more sense to re-use an existing solution like Consul or Etcd. If you're deploying to a PaaS like
      CloudFoundry, then the PaaS may also play the role of configuration server, usually by providing the program with
      configuration in environment variables.
    </para>
  </section>
  
  <section id="logging">
    <title>Logging and Monitoring</title>
    <para>
      <firstterm>Logging</firstterm> is the act of sending out information about the state of the application while it 
      runs. While in theory one can write log output to any medium, in practice logging goes to either the console or 
      to file. The former is the simplest and is favored in twelve-factor apps, because the PaaS in which these apps
      run provides facilities to further process the output.
    </para>
    <para>
      For instance, log output from multiple apps and multiple instances of the same app can be combined into a central
      log database that can be queried. Some of these queries can even happen automatically and the information thus 
      obtained can power statistics and graphs in production dashboards.
    </para>
    <para>
      Log files can be more convenient than the console if you don't have access to such log 
      infrastructure. They are a sink in which information is collected, so the developer can analyze them at a later 
      time rather than having to watch the output fly by in real time.
    </para>
    <para>
      There exists several logging frameworks that can output to either the console, log files, or both. You should use 
      such a framework and make the destination a configuration option, so that you get the best of both worlds.
    </para>
    <para>
      There are two reasons for logging:
    </para>
    <orderedlist>
       <listitem>
         <para>
           To aid in finding and solving problems.
         </para>
       </listitem>
       <listitem>
         <para>
           To gather statistics about the application's usage.
         </para>
       </listitem>
    </orderedlist>
    <para>
      Logging can support both use cases because it paints a picture of what's happening inside the application.
    </para>
    <para>
      Logging can aid a developer in debugging an issue, which is an ad-hoc way of using log output. It can be very 
      instructive to use correlation IDs, especially in a microservices architecture (see <xref linkend="correlation"/>). 
      This allows you to see the connection between otherwise distinct messages and build up a global understanding of 
      how the system behaves when used by real users.
    </para>
    <para>
      Hopefully this pictures matches the expectations, but that isn't always going to be the case. It's certainly 
      possible to miss certain usage patterns during development. This usually leads to tests that don't accurately 
      reflect the real use (see <xref linkend="test"/>). By measuring how users actually use the application we can 
      improve our tests and close the feedback loop.
    </para>
    <para>
      While support for debugging is important in development and troubleshooting scenarios, it is fundamentally an 
      ad-hoc activity. You can also take a more structured approach by setting up monitoring tools that automatically
      look at the logs. These tools can be configured to recognize certain events in the log output and raise an
      <firstterm>alert</firstterm> when such an event occurs.
    </para>
    <para>
      Alerts can take many forms. They can be emails or pager messages that prompt a human to look at the event and 
      determine the appropriate course of action. You must take care to configure the alerts appropriately; if the tool 
      acts as the boy who cried wolf, then in time human operators will learn to ignore the alerts.
    </para>
    <para>
      Some monitoring tools can also take automatic action without any human intervention. The tool could recognize that 
      an application has crashed and automatically restart it, for instance (although this is usually the job of a 
      PaaS). The monitoring tool can even analyze and correlate multiple events and draw conclusions from emerging 
      patterns and deviations from normal, as in the case of fraud detection tools.
    </para>
    <para>
      Debugging and alerting are reactive activities, prompted by seeing undesired events. But logging can also play a
      more proactive role by making measurements that show problems before they arise or that fuel future improvement 
      initiatives.
    </para>
    <para>
      You should define a couple of <firstterm>Key Performance Indicators</firstterm> (KPIs) for your API, numbers that 
      ideally clearly express how well the application is doing in a certain dimension. For instance, the 
      <firstterm>Apdex</firstterm> value concisely captures the performance of the application from the user's 
      perspective <citation>Apdex</citation>. Advanced organizations can even automatically roll back changes when a
      drop in Apdex is detected.
    </para>
    <para>
      Some KPIs are particularly important for applications with REST APIs. They can help you drive adoption of your 
      API by improving the Developer eXperience (see <xref linkend="dx"/>). The percentage of client errors, as 
      indicated by 4xx status codes, for instance, says something about how easy or hard it is to use the API correctly. 
    </para>
    <para>
      Ultimately the KPIs you track must roll up into the overall business KPIs, like revenue and profit. These global
      KPIs are backward looking in the sense that they tell you how well you did over the last period. While this is
      important for reporting purposes, those numbers are not very actionable.
    </para>
    <para>
      You need to decompose the global KPIs into other KPIs that are more forward looking and predictive. For instance,
      revenue can be decomposed into number of users and Average Revenue Per User (ARPU). Increasing either of these
      numbers will increase revenue, but you go about increasing them in different ways. Making the distinction yields
      more actionable KPIs.
    </para>
    <para>
      Consider the number of users. Most services have a so-called <firstterm>sales funnel</firstterm>, as depicted in
      <xref linkend="funnel"/>. The funnel consists of various stages that users can go through to generate increasing 
      revenue, from first becoming aware that the service exists all the way to becoming advocates for it.
    </para>
    <para>
      Each stage of the funnel may have its own KPIs. For instance, in the awareness stage you may want to track where
      users come from, while NPS is a more relevant KPI in the later stages. Since you'll have users in all stages,
      you need many different KPIs. One particularly important KPI for the early stages is <emphasis>Time To First
      Hello World</emphasis>, which measure the time it takes a developer to write their first simple client of your API.
    </para>
    <para>
      Users can get stuck at each stage of the funnel, so measuring the <firstterm>conversion rate</firstterm> at
      each stage is important to get insight into how to increase adoption. We can do that by logging the events of 
      users moving to a new stage. The resulting measurements can help drive improvements. For instance, you can use 
      the relative conversion rates to identify the phase of the Hook model of user adoption that requires more 
      attention <citation>Eyal14</citation>.
    </para>
    <para>
      Users of your API are developers. While developers share many characteristics, they are not a homogeneous group
      and can be segmented by type of application, preferred technology, and professional level. You may want to use
      different KPIs for each of those segments, or at least calculate a single KPI for each segment, to drive focused
      adoption campaigns.
    </para>
    <para>
      The KPIs that are most relevant vary by API, because each API serves different users and is an instrument to
      achieve different goals. Financial goals like revenue are common, but not every API is about making money. If you 
      explicitly define your goals before you start building the service, you can add logging as required and measure 
      KPIs based on that logging. Measuring KPIs for internal APIs is often just as important as for external
      ones.
    </para>
    <para>
      For most KPIs you will want to capture both the current numbers and the trends. The latter will give you some
      indication of where things are going and thus has more predictive power that can fuel decision making.
    </para>
    <figure id="funnel">
      <mediaobject>
        <imageobject>
          <imagedata fileref="images/funnel.png" scale="100" align="center"/>
        </imageobject>
      </mediaobject>
      <title>Sales funnel</title>
    </figure>
  </section>
  
  <section id="sec-ops">
    <title>Security</title>
    <para>
      We discussed vulnerabilities in some detail in <xref linkend="security"/>, but there is an operational side to 
      them as well that we should look at.
    </para>
	  <para>
	    Vulnerabilities may be known or unknown. The latter are called <firstterm>zero-day</firstterm> vulnerabilities,
	    because we start counting days when we first become aware of a vulnerability. Unfortunately, there is a lively 
      black market for zero days. Whether that is something that will affect your API depends largely on the value of
      the data that your API captures.
	  </para>
	  <para>
	    Vulnerabilities may be discovered by criminals or other malicious agents, by <firstterm>security
	    researchers</firstterm>, by users of the API, or by the provider of the API itself. Security researches and 
	    users will generally report them to the provider so they can be fixed. Some security researchers give the
	    provider some time to fix vulnerabilities, after which they will <firstterm>disclose</firstterm> them. This 
	    means that they publicize their results, which usually contains a proof of concept that shows how to exploit
	    the vulnerability.
	  </para>
	  <para>
	    There is a strong debate about vulnerability disclosure. At one extreme, some researchers disclose anything
	    they find immediately. This means that the vulnerabilities can now be exploited by anyone, and users are at risk.
	    For this very reason, other people prefer to keep the vulnerabilities a secret until a fix is available. The
	    middle ground is taken by people who will give providers a certain amount of time, say 90 days, after which
	    they will disclose their findings  .
	  </para>
	  <para>
	    At the very least, you should offer a way for people to report vulnerabilities. If you don't you risk that
	    any vulnerabilities that are found are made public before you get a chance to protect your customers' data.
	    Our advice is to follow the convention of setting up an email address named 
	    <literal>security@yourcompany.com</literal> where vulnerabilities can be reported. Always thank anyone
	    using that email address for helping you out, and work closely with them to reproduce and fix the issue.
	  </para>
	  <para>
	    You should add a section to your website that describes in detail how you would like to see vulnerabilities 
	    reported. This should obviously include the security email address, but also very specific instructions on what 
	    information you want to receive and in what form.
	  </para>
	  <para>
	    Once you have fixed a publicly disclosed vulnerability, you should report that you have fixed it using some form
	    of <firstterm>service bulletin</firstterm>. Different organizations use different names for this document, but
	    the idea is to describe the vulnerability, including exactly what systems were vulnerable, and when it was fixed.
    </para>
    <para>
	    You may choose to provide details about the fix, but that is not necessary. In fact, those details may make it
	    easier for attackers to find a new hole in your defenses.
	  </para>
	  <para>
	    To counterbalance the financial rewards of the zero-day black market, you can start your own <firstterm>bug 
      bounty</firstterm> program, where they pay people who report vulnerabilities to them, so they can fix them before
      they are exploited. This may or may not make sense for your API, depending on a lot of factors such as how widely 
      your API is used and how valuable the data is that flows through it.
	  </para>
  </section>
  
  <section id="support">
    <title>Support</title>
    <para>
      Even if you do your utmost best to design, build, and run a rich and intuitive API, there will always be
      questions about it. Some aspect of your API may not be as intuitive as you think, or may simply not be what your
      particular user base is used to. There may also be questions around pricing, licensing, terms of conditions, etc.
    </para>
    <para>
      Your users will want answers to their questions. Remember that the users of your API are developers. These people
      may be a little different from what you're used to a end users, and may require a different approach. For 
      instance, many developers will sooner look at <emphasis>StackOverflow</emphasis> that at your website. That 
      doesn't mean you shouldn't have a section of your sebsite dedicated to support, but it does mean you need to also
      use alternatives like StackOverflow and Twitter.
    </para>
    <para>
      It helps to think of support not as a reactive response to problems, but as a proactive enabler for users. Take
      them by the hand and guide them through their initial steps, which is where most of the questions usually arise.
      This is a good way to keep the user moving through the sales funnel.
    </para>
    <para>
      The first step is usually the sign-up process. If you can offer something without requiring someone to sign up,
      that's great, but if not, at least make it as easy as possible.
      Make some functionality free so developers get a chance to understand how the API works and what value the data or 
      service provides. If you don't want to do that, then you may want to consider creating the perception that you 
      are offering something for free, such as a month’s free access.
    </para>
    <para>
      Remember the sales funnel. These initial stages are all about driving adoption. Developers need to get some
      instant gratification within minutes as an incentive to keep going. The best way to achieve that is to make them
      clearly see that your product meets their needs without spending too much time. Optimize for Time To First Hello
      World.
    </para>
    <para>
      Authentication is often the hard part of using an API. Consider providing one endpoint that doesn’t require 
      credentials so that developers can try before signing up.
    </para>

    <para>
      Make sure your API documentation is complete and straightforward. Try one of the interactive API documentation 
      consoles, where developers can test API calls and see the results.
    </para>
    <para>
      Be very clear about your policies and careful about changing terms. Your terms should address issues of data 
      ownership, “what happens if I close my account?” and privacy.
    </para>
    <para>
      There are two dimensions to transparency. On the technology side, if you have rate-limiting policies for API
      consumption, display them clearly, like Twitter does. On the communication side, if there’s a problem, put a 
      notice front and center and make sure developers are in the loop. Solid examples of this in action are API status 
      pages from Amazon and Salesforce.
    </para>
    <para>
      Send a welcome email with a name and phone number. Be sure it lists a person, not a generic email address like 
      feedback@company. com. Use Google alerts to monitor blogs and newsgroups for mentions of your API. Participate on
      Stack Overflow and respond quickly to tweets.
    </para>
    <para>
       Your API portal needs to deliver a great experience from beginning to end. Do developers have all the things 
       they need to be successful? Developer resources and tools? Do you offer great SDKs for the common platforms? Do 
       developers have access to other developers so that they can get answers to questions? Is there a place to search 
       FAQs? Is it easy to find terms of service?
    </para>
    <para>
      Developers consistently cite SDKs and code samples in the top three resources that make them successful.
    </para>
  </section>
  
  <section>
    <title>Summary</title>
  </section>
</chapter>
