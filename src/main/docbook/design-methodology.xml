<chapter id="design">
  <title>Design Methodology</title>
  <para>
    This chapter presents our approach to designing REST APIs. We try to remove as much of the art from the design 
    process as possible and strive towards making it a robust and repeatable process that will work for designing any 
    API.
  </para>
  <para>
    We believe design should always be informed by an understanding of the problem you're designing a solution for. 
    That's why we start this chapter where we left off in <xref linkend="analysis"/>. 
  </para>
  <para>
    Here are the steps you should follow:
  </para>
  <procedure id="state-diagram-to-resource-model">
    <title>Design a REST API</title>
    <step>
      <para>Define requirements with state diagrams.</para>
    </step>
    <step>
      <para>Discover resources and methods from state transitions.</para>
    </step>
    <step>
      <para>Name resources with URIs.</para>
    </step>
    <step>
      <para>Name state transitions with link relations.</para>
    </step>
    <step>
      <para>Define the data model.</para>
    </step>
    <step>
      <para>Define the semantics.</para>
    </step>
    <step>
      <para>Select a media type to serialize messages.</para>
    </step>
    <step>
      <para>Validate the design.</para>
    </step>
  </procedure>
  <para>
    Note that this is a variation of the design process described in <citation>Richardson07</citation>. It's adapted to
    make explicit use of state diagrams and also to incorporate application semantics.
    Let's look at each of the steps in detail.
  </para>
  
  <section>
    <title>Define Requirements With State Diagrams</title>
    <para>
      We covered this in <xref linkend="state-diagrams"/>. A state diagram consists of all the
      possible states a client can be in and the transitions that the client can make between them. Note that a single
      REST API can serve more than one type of client, in which case you'd probably have one state diagram for each
      type. In that case, just follow procedure "<xref linkend="state-diagram-to-resource-model"/>" for each state 
      diagram and merge the results. 
    </para> 
    <para>
      A state diagram is a very concise way of capturing functional requirements, but it's also the basis for 
      discovering the resource model.
      The <firstterm>resource model</firstterm> is the collection of resources (see <xref linkend="uniform-interface"/>)
      that we offer, plus the methods that they support. The resource model is about how we implement the interface we
      came up with to meet our requirements. This means we're now shifting our focus from the client to the server. 
      Let's see how that works.
    </para>
  </section>

  <section>
    <title>Discover Resources and Methods From State Transitions</title>
    <para>
      Each transition in the state diagram will move the client from one state to the next. But the state diagram is
      nothing more than an abstract representation of the client's possibilities. To actually make anything happen, the 
      client will have to do something concrete, namely execute an HTTP method against a URI, as we saw in  
      <xref linkend="client-flow"/>.
    </para>
    <para>
      So for each transition, we have to decide on two things: which HTTP method to execute, and against which URI to
      execute it. In this step, we'll discover the resources and pick the HTTP methods they support; the next step
      deals with naming resources with URIs. While you can certainly combine these two steps, we think it's better to
      focus on the interaction dynamics first, since that's the essence of the API.
    </para>
    <para>
      Here's how to build up the resource model from the state diagram:
    </para>
    <procedure>
      <title>Derive the Resource Model From the State Diagram</title>
      <step>
        <para>
          Start with the initial state.
        </para>
      </step>
      <step>
        <para>
          Create (or re-use) a resource with a representation that corresponds to this state.
        </para>
      </step>
      <step>
        <para>
          For each transition starting from the current state, make sure there is a corresponding method in some
          resource that implements the transition.
        </para>
      </step>
      <step>
        <para>
          Repeat for all transitions in each of the remaining states.
        </para>
      </step>
    </procedure>
    <para>
      Let's see how that works on the state diagram in <xref linkend="sd-customer"/>:
    </para>
    <orderedlist>
      <listitem>
        <para>
          We start with the initial state, <literal>Arrived</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          We have no resources yet, so we can't re-use any and thus have to create a new one. What shall we name it? 
          Well, the client is in the state <literal>Arrived</literal>, which means she has just come into our store. 
          For the server, that's home, so let's call this resource <literal>Home</literal>.
        </para>
        <para>
          Most APIs have a resource similar to <literal>Home</literal>. This is the resource identified by the
          billboard URI. Executing <literal>GET</literal> on this resource returns a representation that corresponds to
          the initial state in the state diagram. We'll have more to say about home resources in <xref linkend="home"/>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          There is one transition from the current state, <literal>Read menu</literal>. We have to pick an HTTP method
          for it, and a resource.
        </para>
        <para>
          When selecting the HTTP method, we should carefully look at the characteristics of the interaction. Refer to 
          the sidebar "<xref linkend="http-methods"/>" in <xref linkend="maturity"/> for an explanation of the various
          HTTP methods' properties to guide you in this selection.
        </para>
        <para>
          We think that reading a menu should be a safe thing to do, so we pick the <literal>GET</literal> method. We 
          simply name the resource <literal>Menu</literal>. Note how the HTTP method followed by the resource name
          (<literal>GET Menu</literal>) sounds a lot like the transition name (<literal>Read menu</literal>). 
          This is not a coincidence. It's another reason for starting with simple names for resources rather than URIs.
        </para>
        <para>
          We could have made the menu part of the representation returned by the <literal>Home</literal> resource. 
          That would have saved the client from following one link, but it also would have tied our service to the menu. 
          We like to keep one level of indirection at the start, so that we always have a place to add additional 
          functionality in a backwards compatible way. We'll explain this approach in more detail in 
          <xref linkend="maintenance"/>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We now move to the next state, <literal>Deciding</literal>, which has one outgoing transition, 
          <literal>Place order</literal>. This is where the client informs the server about the order composed from 
          the items on the menu. This operation is neither safe nor idempotent, because ordering a coffee twice will 
          get you two coffees, rather than one. That leaves us a choice of <literal>POST</literal> and 
          <literal>PATCH</literal>. Since <literal>PATCH</literal> is specifically for updating existing resources,
          and we don't have one yet (we're not updating either <literal>Home</literal> or <literal>Menu</literal>),
          we should use <literal>POST</literal> to implement this transition.
        </para>
        <para>
          What resource should offer this <literal>POST</literal> method? Neither <literal>Home</literal> nor 
          <literal>Menu</literal> is a good candidate, so we need a new one. We use the <literal>POST</literal> to 
          create something new, namely a new order. This is something you'll see over and over again in REST APIs, and
          it's called the Create pattern. We'll talk more about it in <xref linkend="create"/>, but in short the idea
          is to have a collection resource (see <xref linkend="collection"/>) that supports the <literal>POST</literal> 
          method to add items to the collection. Since the item we want to create is an order, the collection is the
          collection of orders, and therefore it makes sense to name our new resource <literal>Orders</literal>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Place order</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          The next state is <literal>Ordered</literal> and it has three outgoing transitions, <literal>Cancel</literal>,
          <literal>Change order</literal>, and <literal>Pay</literal>.
        </para>
        <para>
          The <literal>Cancel</literal> transition is when the customer aborts the whole process and walks away. We 
          could allow the client to do nothing (the equivalent of the customer walking out without saying anything to 
          the cashier), which means we would have to have a background process to garbage collect any remaining unpaid 
          orders. The alternative is to have the customer explicitly tell us that she no longer wishes to pursue her 
          order.
        </para>
        <para>
          We'll take the latter approach here. The <literal>DELETE</literal> method is a perfect choice to make it read 
          like a natural sentence again ("Delete order"), assuming we have a <literal>Order</literal> resource as the 
          item in our <literal>Orders</literal> collection resource. 
          Note that we can't force our clients to be polite and let us know they no longer want the order, so we 
          might need to implement the garbage collection anyway. But we could start without it and see how big of a 
          problem it really is before we invest any time in implementing this edge case.
        </para>
        <para>
          The <literal>Change order</literal> transition is where the customer replaces one order with another. This
          changes the world and thus isn't safe. But it is idempotent, since changing an order multiple times gives the
          same end result. So our choices are <literal>PUT</literal> and <literal>DELETE</literal>. Given their 
          definitions it's clear that we should use <literal>PUT</literal> here. This method should be on the same
          <literal>Order</literal> resource.
        </para>
        <para>
          For the <literal>Pay</literal> transition we can use a little trick that often comes in handy when designing
          resources: convert a verb into a noun. Our state diagrams will have actions labeling the transitions, and
          actions are usually expressed using verbs. But resources are things, and thus expressed as nouns. We can
          often simply convert the verb into its corresponding noun to make this mapping. In this case, converting the
          verb "pay" to a noun gives "payment". Instead of "paying", we should think of "creating a payment". Once we 
          do that, we see that we can employ the Create pattern again with a <literal>POST</literal> method on the 
          <literal>Payments</literal> resource.
        </para>
        <para>
          An alternative would be to use the <literal>PUT</literal> method. While that has the advantage of being
          idempotent, it has the disadvantage of allowing only one payment. For now, we only accept credit cards,
          so that isn't a problem. But think about the future. What if we were to introduce coupons at some point?
          Someone would want to pay for a $15 order with a $10 coupon and a $5 credit card payment. So we can foresee
          that we might want to allow multiple payments to the same order and therefore it makes sense to stay with the
          Create pattern.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Place order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>PUT</td>
              <td>Change order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>DELETE</td>
              <td>Cancel</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          The next state is <literal>Paid</literal> with the <literal>Take receipt</literal> outgoing transition. 
          Although you can only take a receipt once in the real world, there really isn't anything destructive about
          it from an information point of view. In other words, the transition is safe and we should use 
          <literal>GET</literal> to implement it. If we name the resource <literal>Receipt</literal> we get a nice
          sentence again (<literal>GET Receipt</literal>) that matches the transition label.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Place order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>PUT</td>
              <td>Change order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>DELETE</td>
              <td>Cancel</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          Next up is <literal>Waiting</literal> with the <literal>Receive notification</literal> transition. This is
          an interesting case, because the transition isn't actually caused by something the client does, but rather
          by a state change on the server: the barista is done preparing the order. 
        </para>
        <para>
          There are two ways to implement this. We can try to stay as close to the state diagram as possible, and
          have the server notify us, or the client can repeatedly ask the server for its current status. In the real
          world the latter would be quite annoying, but machines don't suffer from such petty emotions. Server push
          is an advanced pattern that we'll talk more about in <xref linkend="notifications"/>, but here we'll go with
          the simpler pull model where the client polls the server repeatedly until it sees the changed state.
        </para>
        <para>
          Polling the server means nothing more than repeatedly asking the server for its current status until that 
          status has changed (see <xref linkend="polling"/>). Asking for a status is absolutely safe, so we can use the 
          <literal>GET</literal> method.
        </para>
        <para>
          What resource should we offer this method on? Well, we're waiting for our order to become a serving, which 
          we'll take in the next step of the workflow. So we should name the resource <literal>Serving</literal>.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Place order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>PUT</td>
              <td>Change order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>DELETE</td>
              <td>Cancel</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
            <tr>
              <td>Serving</td>
              <td>GET</td>
              <td>Receive notification</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We're now at the <literal>Served</literal> state, with the <literal>Take serving</literal> transition.
          This is not a safe transition, because goods exchange hands and the world looks differently afterwards. We
          can make it idempotent, however. If someone asks for her coffee, you give it to her. If she asks again,
          you simply say that you've already given it to her. The world isn't fundamentally different; the coffee is
          still in the customer's hands.
          So we can use either of the idempotent <literal>PUT</literal> and <literal>DELETE</literal> methods. The
          latter makes more sense, since we're removing the serving from our store and putting it in the customer's 
          hands.
          The name of the transition suggests we re-use our <literal>Serving</literal> resource.
        </para>
        <informaltable>
          <thead>
            <tr>
              <th>Resource</th>
              <th>Method</th>
              <th>Transition</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Home</td>
              <td>GET</td>
              <td></td>
            </tr>
            <tr>
              <td>Menu</td>
              <td>GET</td>
              <td>Read menu</td>
            </tr>
            <tr>
              <td>Orders</td>
              <td>POST</td>
              <td>Place order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>PUT</td>
              <td>Change order</td>
            </tr>
            <tr>
              <td>Order</td>
              <td>DELETE</td>
              <td>Cancel</td>
            </tr>
            <tr>
              <td>Payments</td>
              <td>POST</td>
              <td>Pay</td>
            </tr>
            <tr>
              <td>Receipt</td>
              <td>GET</td>
              <td>Take receipt</td>
            </tr>
            <tr>
              <td>Serving</td>
              <td>GET</td>
              <td>Receive notification</td>
            </tr>
            <tr>
              <td>Serving</td>
              <td>DELETE</td>
              <td>Take serving</td>
            </tr>
          </tbody>
        </informaltable>
      </listitem>
      <listitem>
        <para>
          We've now gone through all states and transitions, and we have discovered all resources required to
          implement the state diagram.
        </para>
      </listitem>
    </orderedlist>
    <table rowsep="0" colsep="0" pgwide="1" frame="topbot" id="restbucks-customer-resources">
      <title>Partial Resource Model To Support RESTBucks Customer</title>
      <tgroup cols="3">
        <thead>
          <row>
            <entry><para>Resource</para></entry>
            <entry><para>Method</para></entry>
            <entry><para>Transition</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Home</para></entry>
            <entry><para>GET</para></entry>
            <entry><para></para></entry>
          </row>
          <row>
            <entry><para>Menu</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Read menu</para></entry>
          </row>
          <row>
            <entry><para>Orders</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Place order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>PUT</para></entry>
            <entry><para>Change order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>DELETE</para></entry>
            <entry><para>Cancel</para></entry>
          </row>
          <row>
            <entry><para>Payments</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Pay</para></entry>
          </row>
          <row>
            <entry><para>Receipt</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Take receipt</para></entry>
          </row>
          <row>
            <entry><para>Serving</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Receive notification</para></entry>
          </row>
          <row>
            <entry><para>Serving</para></entry>
            <entry><para>DELETE</para></entry>
            <entry><para>Take serving</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>
  
  <section id="name-resources">
    <title>Name Resources With URIs</title>
    <para>
      Every resource should be identified by a URI. From the client’s perspective, this is an implementation detail,
      but we still need to do this before we can implement the server. We should follow existing best practices for URIs 
      that were developed for the human Web. The sidebar "<xref linkend="uris"/>" discusses the most relevant ones for 
      our current purpose.
    </para>

    <sidebar id="uris">
      <title>Patterns and Anti-Patterns around Uniform Resource Identifiers (URIs)</title>
      <para>
        You should always use a plural name for resources that are collections. For instance, if we were to build a REST 
        API for a social media platform, we should use <literal>/users/</literal> rather than <literal>/user/</literal>
        because it is immediately clear from the URI that it is a collection.
      </para>
      <para>
        URIs should be cool <citation>CoolUris</citation>, which means they won't change. Keeping URIs cool means that  
        bookmarks never break. Although bookmarks are less important for REST APIs than for the human Web, it's still 
        nice to be able to support them.
        In order to keep URIs stable, we shouldn't put information in them that is likely to 
        change. In the social media example, we shouldn't put user names in the URIs, but rather internal IDs. This 
        doesn't read as nicely, but that's okay since URIs are discovered anyway. Assuming the API is implemented by a 
        cluster of servers, you'll need a way to assign internal IDs without conflict. <firstterm>Universially Unique 
        Identifiers</firstterm> (UUIDs) are perfect for this, because they don't require any communication between the 
        servers.
      </para>
      <para>
        Indicate hierarchical relationships with slashes in the URIs. So if we have a collection of users at 
        <literal>/users/</literal>, then an individual user would live at <literal>/users/{id}/</literal>. Note that 
        this is not technically a URI, because the <literal>{</literal> and <literal>}</literal> symbols are not 
        allowed in URIs <citation>RFC 3986</citation>. It's actually a concise way of indicating a whole 
        range of URIs, like <literal>/users/1/</literal>, <literal>/users/2/</literal>, etc. This is also known as 
        a <firstterm>URI Template</firstterm> <citation>RFC 6570</citation>.
      </para>
      <para>
        Another common convention is to use only lowercase letters from the US ASCII character set. This sets the bar
        very low for clients to handle URIs, so you can reach as many people as possible with your API. For non-English 
        speakers, this may seem like a limitation, but it isn't since URIs are to be discovered by clients rather than 
        read by humans. The only humans reading them will be developers. To reach the largest number of developers, you 
        should use English names in your URIs. English names only use US ASCII characters, so that works out nicely.
      </para>
      <para>
        A less common, but still very useful convention is to end all URIs with a slash (<literal>/</literal>). The 
        rationale behind this is that it makes it very easy to resolve URIs, even if they're relative. Relative URIs are
        useful in deeply hierarchical cases to make the messages shorter. As as example, resolving the 
        relative URI <literal>1/</literal> against the base URI <literal>/users/</literal> gives the intended 
        <literal>/users/1/</literal>, whereas resolving the same relative URI against the base URI 
        <literal>/users</literal> results in <literal>/1/</literal>, which is probably not what we intended. 
        We'll talk more about resolving URIs in <xref linkend="client"/>.
      </para>
      <para>
        Now that we've seen some of the best practices around URIs, let's look at some of the anti-patterns. The first
        is putting actions in URIs. For instance, a task resource located at <literal>/tasks/1/</literal> could have
        an operation to complete it. One way of modeling that is to perform a <literal>POST</literal> at 
        <literal>/tasks/1/complete/</literal>. Don't do that. URIs by definition identify resources, and the complete
        action is not a resource itself, but an operation on a resource. Operations in HTTP are modeled by the HTTP
        methods, not by URIs. In the task example, you could introduce a <literal>status</literal> property, for 
        instance, and set it to <literal>completed</literal> using the <literal>PATCH</literal> or 
        <literal>PUT</literal> methods.
      </para>
      <para>
        Another anti-pattern is putting media types in URIs. An example of that would be to make a JSON 
        representation of a task available at <literal>/tasks/1.json</literal>. Don't do that. The way to request
        a certain representation of a resource in HTTP is to use <firstterm>content negotiation</firstterm> through the
        <literal>Accept</literal> header <citation>HTTP</citation>.
      </para>
    </sidebar>
  
    <para>
      Armed with this knowledge, let's take a swing at identifying our RESTBucks resources with URIs:
    </para>
    <table rowsep="0" colsep="0" pgwide="1" frame="topbot" tocentry="1" id="restbucks-resources">
      <title>Resource model to support RESTBucks customer</title>
      <tgroup cols="4">
        <thead>
          <row>
            <entry><para>Resource</para></entry>
            <entry><para>URI (Template)</para></entry>
            <entry><para>Method</para></entry>
            <entry><para>Transition</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>Home</para></entry>
            <entry><para>/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para></para></entry>
          </row>
          <row>
            <entry><para>Menu</para></entry>
            <entry><para>/menu/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Read menu</para></entry>
          </row>
          <row>
            <entry><para>Orders</para></entry>
            <entry><para>/orders/</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Place order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>PUT</para></entry>
            <entry><para>Change order</para></entry>
          </row>
          <row>
            <entry><para>Order</para></entry>
            <entry><para>/orders/{id}/</para></entry>
            <entry><para>DELETE</para></entry>
            <entry><para>Cancel</para></entry>
          </row>
          <row>
            <entry><para>Payments</para></entry>
            <entry><para>/orders/{id}/payments/</para></entry>
            <entry><para>POST</para></entry>
            <entry><para>Pay</para></entry>
          </row>
          <row>
            <entry><para>Receipt</para></entry>
            <entry><para>/orders/{id}/receipt/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Take receipt</para></entry>
          </row>
          <row>
            <entry><para>Serving</para></entry>
            <entry><para>/orders/{id}/serving/</para></entry>
            <entry><para>GET</para></entry>
            <entry><para>Receive notification</para></entry>
          </row>
          <row>
            <entry><para>Serving</para></entry>
            <entry><para>/orders/{id}/serving/</para></entry>
            <entry><para>DELETE</para></entry>
            <entry><para>Take serving</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>
      We've put our home resource at <literal>/</literal>, which is a common choice. Note that this is a relative URI.
      For our design it doesn't matter what the absolute URI is, that's more of an implementation detail. It could be
      <literal>http://dev.restbucks.com/</literal>, for instance, or <literal>http://buycoffeeonline.com/api/</literal>.
      While the billboard URI is an important decision from a marketing perspective, it's not all that important from
      a resource model perspective.
    </para>
    <para>
      We have two top-level resources, <literal>/menu/</literal> for the menu, and <literal>/orders/</literal> for the
      orders. The latter contains sub-resources for specific orders, including their payments, receipts, and servings.
    </para>
  </section>

  <section>
    <title>Name State Transitions With Link Relations</title>
    <para>
      A REST client follows transitions in the state diagram by discovering the URIs we just invented from the messages
      that the server sends.
      This discovery process is made possible by <firstterm>link relations</firstterm>. Link relations decouple the 
      client from the URIs that the server uses, giving the server the freedom to change its URI structure at will 
      without breaking any clients. Link relations enable evolution of the service and are therefore an important part 
      of any REST API.
    </para>
    <para>
      We should try to use existing link relations as much as possible. The <citation>IANA Registry of Link Relation 
      Types</citation> contains standard link relations and is maintained by IANA, the same organization that also 
      maintains a registry of media types.
      There usually won't be a registered link relation for every transition in your state diagram, so sometimes you 
      need to invent your own. But if you can, reuse existing link relations, because it is just another thing that a 
      client developer doesn't have to learn about your service.
    </para>
    <para>
      Publicly registered link relations have a short English name, like <literal>self</literal> or 
      <literal>edit</literal>. The registry makes sure that they are globally unique. That is not the case for 
      <firstterm>extension link relations</firstterm>, so they must take the form of URIs to avoid name conflicts. 
      Note that these URIs don't have to resolve, so you don't need to have them point to a web page. However, that 
      would be a good way to make them discoverable and provide a convenient place to document them.
    </para>
    <para>
      Here are the link relations for our example:
    </para>
    <table id="restbucks-link-relations">
      <title>Link Relations for RESTBucks</title>
      <thead>
        <tr>
          <th>Transition</th>
          <th>Link Relation</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Read menu</td>
          <td><literal>http://schema.org/menu</literal></td>
        </tr>
        <tr>
          <td>Place order</td>
          <td><literal>http://schema.org/OrderAction</literal></td>
        </tr>
        <tr>
          <td>Change order</td>
          <td><literal>https://schema.org/ReplaceAction</literal></td>
        </tr>
        <tr>
          <td>Cancel</td>
          <td><literal>https://schema.org/DeleteAction</literal></td>
        </tr>
        <tr>
          <td>Pay</td>
          <td><literal>https://schema.org/PayAction</literal></td>
        </tr>
        <tr>
          <td>Take receipt</td>
          <td><literal>http://schema.org/Order</literal></td>
        </tr>
        <tr>
          <td>Receive notification</td>
          <td><literal>https://schema.org/ListenAction</literal></td>
        </tr>
        <tr>
          <td>Take serving</td>
          <td><literal>http://schema.org/ReceiveAction</literal></td>
        </tr>
      </tbody>
    </table>
    <para>
      We selected extension link relations for all transitions, because we want to use concepts defined by
      <literal>schema.org</literal>. These may not be standard link relations, but they have a much bigger chance of 
      being familiar to a client developer than anything we invent ourselves. It also closely matches what we'll do in
      <xref linkend="semantics"/>.
    </para>
    <para>
      We could have used the <literal>edit</literal> link relation for updates and deletes, but decided against it.
      First of all, <literal>edit</literal> is defined in the context of the Atom Publishing Protocol
      <citation>APP</citation>, which we're not using in our API. Furthermore, <literal>edit</literal> doesn't
      distinguish between updates and deletes, so it isn't clear for a client whether the presence of an
      <literal>edit</literal> means one or the other. Also, <literal>edit</literal> is a verb rather than
      a noun. Finally, we're borrowing most of our link relations from <literal>schema.org</literal> anyway, so it's
      just more consistent to pick all of them from the same location.
    </para>
    <para>
      You may not be in a domain as generic as e-commerce. In that case you will have to invent your own extension link
      relations.
      The alternative to defining extension link relations is to start a standardization process of some sort, for 
      instance an IETF Internet Draft or similar document that defines reusable link relations. If you're striving to 
      be a thought leader in your domain, then that could be a good opportunity to demonstrate that ambition.
    </para>
  </section>

  <section id="design-messages">
    <title>Design the Data Model</title>
    <para>
      At this point we are done with the interaction part of our resource model. All that is left to do is address the
      data part. In other words, we have to design our representations.
      In this step we'll design the structure of the data transferred between client and server. In the next step
      (<xref linkend="semantics"/>), we'll assign precise meaning to that data. Finally, we'll tie the data and the
      links together in a message that we'll serialize into a series of bytes using a media type
      (<xref linkend="media-types"/>).
    </para>
    <para>
      We start with indicating which of our HTTP methods require a request and which require a response. This decision 
      is usually dictated by our choice of methods. The <literal>GET</literal> method, for instance, doesn't support
      a request but should get a response.
    </para>
    <informaltable>
      <thead>
        <tr>
          <th>Resource</th>
          <th>Method</th>
          <th>Request</th>
          <th>Response</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Home</td>
          <td>GET</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Menu</td>
          <td>GET</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Orders</td>
          <td>POST</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Order</td>
          <td>PUT</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Order</td>
          <td>DELETE</td>
          <td>No</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Payments</td>
          <td>POST</td>
          <td>Yes</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Receipt</td>
          <td>GET</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Serving</td>
          <td>GET</td>
          <td>No</td>
          <td>Yes</td>
        </tr>
        <tr>
          <td>Serving</td>
          <td>DELETE</td>
          <td>No</td>
          <td>No</td>
        </tr>
      </tbody>
    </informaltable>
    <para>
      There are ten entries marked with Yes in the above table, but the number of messages is smaller because messages
      are re-used. We really only need representations for our home, a menu, an order, a payment, a receipt, and a 
      serving.
    </para>
    <para>
      The <literal>Home</literal> resource is extremely simple, because by definition it only consists of links. 
      There is no data for us to design a structure for.
      The serving resource also has no data. It's purpose is solely to coordinate the customer and the barista. It
      will be empty while the barista is preparing the serving, and will contain a link to take the serving when he is 
      done.
      The other messages are easy to design if we have done our homework during the analysis phase.
    </para>
    <para>
      The <literal>menu</literal> consists of all the items that our customers can order. We could use a 
      generic item that can be sold by any shop, but we're not just any shop, we're RESTBucks. So we want to make it 
      easier on our clients to provide correct orders by giving our items a bit more structure. Each item needs to be
      identified, so we add the <literal>name</literal> property to our items. We serve our drinks in different sizes, 
      so we also add a <literal>size</literal> property. Our hot beverages also differ in how much milk they contain, 
      so we add a <literal>milk</literal> property. Finally, we're in this for the money, so we add a 
      <literal>price</literal> property. Since we have international aspirations, we should also add a
      <literal>currency</literal> property.
    </para>
    <para>
      Our menu is really nothing more than a list of items. We could go further and put the items into categories. This
      is quite a common trick to help human users, but our software clients don't mind going through a seemingly
      endless list of items, so we're not going to bother with the added complexity until we get clear requirements that
      force us to do so.
    </para>
    <para>
      An <literal>order</literal> contains of a number of items that the customer wants to purchase. These are the same 
      items that are on the menu, of course, so we can re-use the item design. We need a couple of other properties as
      well. The barista needs to call the customer when the order is prepared, so we should add a
      <literal>customer</literal> property for this purpose. We also like to include a <literal>total</literal> (with
      <literal>currency</literal>). One could argue that this can be calculated from the items, but there may be
      complications like volume discounts or specially priced combinations that we want to be prepared for.
    </para>
    <para>
      A <literal>payment</literal> could take many forms. We could go overboard and design a very flexible solution that 
      will cater to any and all payment methods, but this book is about REST, not payments. Since RESTBucks is an online 
      store, we'll simply assume a credit card payment. So we'll need the following properties: 
      <literal>amount</literal>, <literal>currency</literal>, <literal>cardholderName</literal>, 
      <literal>cardNumber</literal>, <literal>expiryMonth</literal>, <literal>expiryYear</literal>, and 
      <literal>cardSecurityCode</literal>.
      To be future-proof, we'll throw in a <literal>paymentMethod</literal> field, so that we can add different 
      payment methods later.
    </para>
    <para>
      The <literal>receipt</literal> should have a <literal>dateTime</literal> property and show the 
      <literal>shop</literal> to be RESTBucks. It should also have a list of the purchased <literal>item</literal>s and
      their <literal>price</literal>s, and a <literal>total</literal> price and <literal>currency</literal>. Finally, 
      it should have a <literal>paymentMethod</literal> so that customers can crosscheck the receipt with their credit 
      card statements.
    </para>
    <para>
      Here's a summary:
    </para>
    <table id="restbucks-messages">
      <title>RESTBucks Messages</title>
      <thead>
        <tr>
          <th>Message</th>
          <th>Properties</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><literal>home</literal></td>
          <td></td>
        </tr>
        <tr>
          <td><literal>menu</literal></td>
          <td><literal>item</literal>s</td>
        </tr>
        <tr>
          <td><literal>item</literal></td>
          <td>
            <literal>name</literal>, <literal>size</literal>, <literal>milk</literal>, <literal>price</literal>, 
            <literal>currency</literal>
          </td>
        </tr>
        <tr>
          <td><literal>order</literal></td>
          <td>
            <literal>item</literal>s, <literal>customer</literal>, <literal>total</literal>, 
            <literal>currency</literal>
          </td>
        </tr>
        <tr>
          <td><literal>payment</literal></td>
          <td>
            <literal>amount</literal>, <literal>currency</literal>, <literal>paymentMethod</literal>, 
            <literal>cardholderName</literal>, <literal>cardNumber</literal>, <literal>expiryMonth</literal>, 
            <literal>expiryYear</literal>, <literal>cardSecurityCode</literal>
          </td>
        </tr>
        <tr>
          <td><literal>receipt</literal></td>
          <td>
            <literal>dateTime</literal>, <literal>shop</literal>, <literal>item</literal>s, 
            <literal>total</literal>, <literal>currency</literal>, <literal>paymentMethod</literal>
          </td>
        </tr>
        <tr>
          <td><literal>serving</literal></td>
          <td></td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section id="semantics">
    <title>Define the Semantics</title>
    <para>
      Now that we've identified our messages, we must get a bit more specific about what the various data items in them
      mean and what values are acceptable for them.
    </para>
    <para>
      As much as we sometimes like to think we're unique, the fact is that we rarely are. Sure, RESTbucks is unique in
      that it sells coffee <emphasis>online</emphasis>. But it's also not unique, because it sells 
      <emphasis>coffee</emphasis>. It therefore makes sense to see how we are different from others, and more 
      important for the present discussion, how we are the same.
    </para>
    <para>
      There are a number of places where people have defined semantics for various things. Probably the best place to
      start looking for vocabularies is <literal>schema.org</literal> <citation>SchemaOrg</citation>, which defines a large number of
      concepts.
      Other examples where you can find vocabularies are Friend of a Friend <citation>FOAF</citation>, the Dublin Core 
      Metadata Initiative <citation>DublinCore</citation> and Microformats <citation>MicroFormats</citation>.
      Since we're in the e-commerce and coffee domains, we can find most of what we need at
      <literal>schema.org</literal>, but we need a bit of web payments as well:
    </para>
    <table id="restbuck-semantics">
      <title>Semantics for RESTBucks messages</title>
      <thead>
        <tr>
          <th>Data item</th>
          <th>Defined By</th>
          <th>Definition Maintained By</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><literal>cardHolderName</literal></td>
          <td>https://w3id.org/creditcard/v1/name</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>cardNumber</literal></td>
          <td>https://w3id.org/creditcard/v1/number</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>cardSecurityCode</literal></td>
          <td>https://w3id.org/creditcard/v1/verificationCode</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>currency</literal></td>
          <td>http://schema.org/priceCurrency</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>customer</literal></td>
          <td>http://schema.org/customer</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>dateTime</literal></td>
          <td>http://schema.org/orderDate</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>expiryMonth</literal></td>
          <td>https://w3id.org/creditcard/v1/expiryMonth</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>expiryYear</literal></td>
          <td>https://w3id.org/creditcard/v1/expiryYear</td>
          <td>web-payments.org</td>
        </tr>
        <tr>
          <td><literal>home</literal></td>
          <td>http://schema.org/CafeOrCoffeeShop</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>item</literal></td>
          <td>http://schema.org/Product</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>menu</literal></td>
          <td>http://schema.org/menu</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>milk</literal></td>
          <td>http://www.productontology.org/doc/Milk</td>
          <td>Product Types Ontology</td>
        </tr>
        <tr>
          <td><literal>name</literal></td>
          <td>http://schema.org/name</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>order</literal></td>
          <td>http://schema.org/Order</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>payment</literal></td>
          <td>http://reference.data.gov.uk/def/payment#payment</td>
          <td>UK Government</td>
        </tr>
        <tr>
          <td><literal>paymentMethod</literal></td>
          <td>http://schema.org/acceptedPaymentMethod</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>price</literal></td>
          <td>http://schema.org/price</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>receipt</literal></td>
          <td>http://schema.org/Order</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>serving</literal></td>
          <td>http://schema.org/Order</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>shop</literal></td>
          <td>http://schema.org/seller</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>size</literal></td>
          <td>http://schema.org/height</td>
          <td>schema.org</td>
        </tr>
        <tr>
          <td><literal>total</literal>, <literal>amount</literal></td>
          <td>http://schema.org/totalPrice</td>
          <td>schema.org</td>
        </tr>
      </tbody>
    </table>
    <para>
      As you can see, all concepts in our service are defined elsewhere.
      Although it took us a bit of time to find all of these, it was well worth it. Existing clients that already 
      understand these vocabularies will have a good chance of being able to work with our service. Even if they don't,
      we can save ourselves the trouble of documenting the concepts.
      Over time, we can only expect the number and sizes of the vocabularies to grow, so that it would be very rare to
      have to define anything yourself.
    </para>
    <para>
      <literal>schema.org</literal> defines an <literal>Order</literal> as follows: <quote>An order is a confirmation of a transaction 
      (a receipt), which can contain multiple line items, each represented by an Offer that has been accepted by the 
      customer</quote>. An <literal>Order</literal> has an <literal>orderStatus</literal> property which can be 
      <literal>OrderPaymentDue</literal>, <literal>OrderProcessing</literal>, <literal>OrderPickupAvailable</literal>, 
      and <literal>OrderDelivered</literal>, among others. So that covers all of our <literal>Order</literal>,
      <literal>Receipt</literal>, and <literal>Serving</literal>.
    </para>
    <para>
      At runtime, we will want to serve the above information as a semantic profile (see <xref linkend="maturity"/>).
      We have a couple of choices for that, like ALPS and JSON-LD. What the right choice for an API is, also depends
      on what media types you are serving your representations in. So let's look at that next.
    </para>
  </section>
  
  <section id="media-types">
    <title>Select a Media Type To Serialize Messages</title>
    <para>
      An API uses one or more media types to convert the abstract messages into bytes that are sent over the wire.
      One could use multiple media types for different resources, like Home Document for the <literal>Home</literal>
      resource and Collection+JSON for collection resources. That does increase the burden on the
      client, however, which now has to speak multiple languages to be able to communicate with the server. It also
      increases the complexity of the server code. For these reasons, we're going to assume that you'll
      use a single media type for your structured messages. You may use other media types for non-structured messages, 
      like images.
    </para>
    <para>
      There are different kinds of media types. <firstterm>Application-specific media types</firstterm> are designed for 
      a single application or service. For instance, <literal>application/vnd.github+json</literal> is a media type 
      only used by GitHub <citation>GitHub API</citation>. <firstterm>Domain-specific media types</firstterm> are 
      designed to represent problems in one particular domain. For instance, Scalable Vector Graphics 
      (<literal>image/svg+xml</literal>) deals only with vector graphics <citation>SVG</citation>. 
      <firstterm>General purpose media types</firstterm> can be used for any service in any domain. The best known 
      general purpose media type is of course <literal>text/html</literal> <citation>HTML</citation>.
    </para>
    <para>
      Another way to categorize media types is by who defined them <citation>RichAmun13</citation>. 
      <firstterm>Fiat standards</firstterm> are informal descriptions of the way someone does something. They don't try 
      to convince other people to do things the same way. <firstterm>Personal standards</firstterm> do invite people
      to follow them, but they're still just one person's opinion. <firstterm>Corporate standards</firstterm> are
      created by a single organization or a consortium of organizations to solve recurring problems. Finally, 
      <firstterm>open standards</firstterm> have gone through a process of design by committee or at least peer review
      and are blessed by some sort of standards body.
    </para>
    <para>
      There is some correlation between specificity and standardization. An application-specific media type will have 
      little chance of getting adopted as an open standard, for instance. However, SVG and HTML are both open 
      standards, but one is domain-specific while the other is general purpose.
    </para>
    <para>
      Media types that are described by a standard are usually registered with the Internet Assigned Numbers Authority 
      <citation>IANA</citation>. This makes them easy to discover. Registered media types are of the form
      type<literal>/</literal>sub-type, where the number of types is fixed. For REST APIs, most media types will fall
      within the <literal>application</literal> type. 
      The IANA registry is made up of several trees. The so-called personal tree is for registering personal standards,
      the vendor tree is for registering corporate standards, and the standards tree contains open standards. Media
      types in the vendor tree start the sub-type with the <literal>vnd.</literal> prefix; those in the personal tree
      with <literal>prs.</literal>.
    </para>
    <para>
      Ideally, you would select a general purpose media type defined as an open standard. This choice means
      you won't have to document anything; you can simply point to an existing specification. Chances are that there
      are existing tools and/or libraries available to work with the media type, so you can save yourself and your 
      clients some coding effort. You can also profit from a lot of thinking that went into the existing standard.
    </para>
    <para>
      The problem with a general purpose media type is, well, that it isn't specifically tailored to your needs. You 
      will have to find a way to express your particular domain in the media type. Remember from 
      <xref linkend="maturity"/> that semantic profiles can bridge that gap. If you're lucky enough to work in a domain
      for which such a semantic profile already exists, then you can re-use that. But even if you're not that lucky,
      you can still save yourself a lot of work by selecting a general purpose media type. You then only have to 
      describe the semantics, instead of the semantics plus the protocol plus the data format.
    </para>
    <para>
      Most media types are derived from an existing base format like XML (e.g. SVG) or JSON (e.g. GitHub). The default
      these days is to use JSON-based media types, so if you don't have a strong reason to use something else, you 
      should go with JSON.
    </para>
    <para>
      Note that JSON itself, <literal>application/json</literal>, is not a hypermedia type, since JSON doesn’t define 
      links. You can, of course, use a convention on top of JSON, for instance that there should be a 
      <literal>links</literal> property with a certain structure to describes the links. The problem with this approach
      is that it's a fiat or at best personal standard, and we've already seen that open standards are better. 
      In the following sections we will take a look at some JSON-based media types that allow the inclusion of 
      hyperlinks.
    </para>
    <para>
      At the time of writing, the jury is still out on which hypermedia type is going to win out as the 
      <emphasis>de facto</emphasis> standard media type for REST APIs. This means that any choice you make now has a
      decent chance of ending up being viewed as wrong in the future. That's unfortunate, but there isn't much we
      can do about it. The best we can do is be prepared to change our decision. You can minimize the impact of such a 
      change by being careful when implementing your service. We'll come back to that in 
      <xref linkend="implementation"/>. With that caveat, let's look at some of the contenders.
    </para>
    
    <!-- TODO: JSON API http://jsonapi.org/ -->
    
    <section>
      <title>HAL</title>
    </section>
    <para>
      Since <literal>application/json</literal> has no provisions for linking, we can't use it as a hypermedia format.
      In other words, you can use JSON for REST maturity levels 0, 1, and 2, but not for levels 3a, 3b, or 4 (see 
      <xref linkend="maturity"/>). To get to level 3a, we need to add linking capabilities. 
    </para>
    <para>
      That's exactly what Hypermedia Application Language provides <citation>HAL</citation>. HAL is registered in the 
      open standards tree of IANA as <literal>application/hal+json</literal>, but it hasn't reached the status of 
      standard yet. At the time of writing, HAL is a Internet Draft. Internet Drafts are the vehicle
      of the IETF standards body to propose new standards. Once an Internet Draft is vetted by reviewers, it may turn 
      into a full standard, or RFC. (HTTP is one example of an RFC.)
    </para>
    <para>
      HAL is a JSON-based language that adds a <literal>_links</literal> property. 
      The underscore is there to avoid naming conflicts, since JSON doesn't have a scoping mechanism like XML
      namespaces. 
      Here's what an unpaid RESTBucks order could look like in HAL:
    </para>
    <programlisting>{ "_links": {
    "self": { 
      "href": "http://api.restbucks.com/orders/1234/"
    },
    "https://schema.org/PayAction": {
      "href": "http://api.restbucks.com/orders/1234/payments/"
    },
    "https://schema.org/ReplaceAction": { 
      "href": "http://api.restbucks.com/orders/1234/"
    },
    "https://schema.org/DeleteAction": { 
      "href": "http://api.restbucks.com/orders/1234/"
    }
  },
  "_embedded": {
    "items": [{
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole",
      "price": 2.75,
      "currency": "USD"
    }]
  },
  "total": 2.75,
  "currency": "USD"
}</programlisting>
    <para>
      The value of the <literal>_links</literal> property is a JSON object where each property is a link relation. 
      This object must at least have an <literal>href</literal> property that contains the URL of the target resource.
    </para>
    <para>
      HAL only allows simple properties in the JSON object. But often that model doesn't fit your message structure. 
      In the RESTBucks example, an order is made up of potentially more than one item. HAL uses the 
      <literal>_embedded</literal> property to handle such sub-entities.
    </para>
    <para>
      Remember that a level 3b REST API must support both links and forms. While HAL provides hyperlinking capabilities 
      using the <literal>_links</literal> property, it doesn't have anything for handling forms. So with HAL you can 
      only build level 3a APIs. There are no HTTP methods in the example above. The client simply has to know that
      <literal>PUT</literal> is used with <literal>https://schema.org/ReplaceAction</literal> and
      <literal>DELETE</literal> with <literal>https://schema.org/DeleteAction</literal>. In practice, this means that 
      the client developer has to hard-code this knowledge.
    </para>
    <para>
      Despite these limitations, HAL is a big improvement over plain JSON, and it is quite popular. For instance, it is 
      used by default in <citation>Spring HATEAOS</citation>. HAL's popularity no doubt is due to its simplicity.
    </para>
    <para>
      There is a recent attempt to create a backward-compatible, non-standard extension to HAL called
      <citation>HAL-FORMS</citation>. This specification is still a draft and not nearly as well accepted as HAL.
    </para>
    
    <section>
      <title>Mason</title>
    </section>
    <para>
      The Mason media type, <literal>application/vnd.mason+json</literal>, fills the gap that HAL leaves 
      <citation>Mason</citation>. As you can tell from the <literal>vnd.</literal> prefix in the sub-type, Mason is a 
      personal standard. We're not aware of any efforts to move this to an open standard.
    </para>
    <para>
      Like HAL, Mason supports links (using the <literal>@links</literal> property), but it also supports
      forms using the <literal>@actions</literal> property. Here's what an unpaid RESTBucks order could look like in 
      Mason:
    </para>
    <programlisting>{ "item": [{
    "name": "caffe latte",
    "size": "tall",
    "milk": "whole",
    "price": 2.75,
    "currency": "USD"
  }],
  "total": 2.75,
  "currency": "USD",
  "@links": {
    "self": { 
      "href": "http://api.restbucks.com/orders/1234/"
    }
  },
  "@actions": {
    "https://schema.org/DeleteAction": { 
      "href": "http://api.restbucks.com/orders/1234/",
      "type": "void",
      "method": "DELETE"
    },
    "https://schema.org/ReplaceAction": { 
      "href": "http://api.restbucks.com/orders/1234/",
      "type": "any",
      "method": "PUT",
      "template": {
        "item": [{
          "name": "caffee latte",
          "size": "tall",
          "milk": "whole",
          "price": 2.75,
          "currency": "USD"
        }],
        "total": 2.75,
        "currency": "USD"
      }
    },
    "https://schema.org/PayAction": {
      "href": "http://api.restbucks.com/orders/1234/payments/",
      "title": "Pay the order",
      "type": "any",
      "method": "POST",
      "template": {
        "payment": {
          "amount": 2.75,
          "currency": "USD",
          "paymentMethod": "creditcard",
          "cardholderName": "",
          "cardNumber": "",
          "expiryMonth": "",
          "expiryYear": ""
          "cardSecurityCode": ""
        }
      }
    }
  }
}</programlisting>
    <para>
      Mason allows for natural sub-objects, rather than HAL's <literal>_embedded</literal> property. But the main
      advantage of Mason over HAL is the <literal>@actions</literal> property that supports forms. Mason is thus
      suited to build REST APIs at level 3b. The <literal>method</literal> property allows specifying which HTTP
      method to use, so clients no longer have to hard-code that knowledge. This gives you the opportunity to switch
      from <literal>PUT</literal> to <literal>PATCH</literal>, for instance, and not break existing clients.
    </para>
    <para>
      For HTTP methods that require input, the <literal>template</literal> property specifies what that input should
      look like. This makes it easy to translate the JSON message into an HTML form, or to dynamically build your 
      mobile UI.
    </para>
    <para>
      A peculiarity of <literal>@actions</literal> is the <literal>type</literal> property, which can be 
      <literal>void</literal>, <literal>json</literal>, <literal>json-files</literal>, or <literal>any</literal>.
      One would have expected a media type there instead.
    </para>
    <para>
      Mason doesn't provide any hooks for adding semantics. If you want to use something like ALPS to define meaning,
      the client will have to figure out on its own how to map data in a message to its definition in a semantic
      profile. So Mason doesn't lend itself very well to building level 4 APIs.
    </para>
    
    <section>
      <title>Siren</title>
    </section>
    <para>
      HAL and Mason use keywords starting with <literal>_</literal> or <literal>@</literal> so that they don't
      conflict with user-defined properties. Siren does things a bit differently <citation>Siren</citation>.
      It prescribes the structure of the message, so that it's always clear what part is defined by Siren and what part 
      is specific to the service. This has the benefit of clarity at the cost of a more deeply nested structure.
    </para>
    <para>
      Siren, or <literal>application/vnd.siren+json</literal>, is another personal standard. At the time of writing,
      there is an active user community, but no efforts to move to an open standard.
    </para>
    <para>
      Here's what an unpaid RESTBucks order could look like in Siren:
    </para>
    <programlisting>{ "class": [ "http://schema.org/Order" ],
  "properties": [{
    "total": 2.75,
    "currency": "USD"
  },
  "entities": [{
    "class": [ "http://schema.org/Product" ],
    "rel": [ "http://schema.org/orderedItem" ],
    "properties": {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole",
      "price": 2.75,
      "currency": "USD"
    }
  }],
  "actions": [{
    "name": "update",
    "class": [ "http://schema.org/DeleteAction" ],
    "title": "Cancel the order",
    "method": "DELETE",
    "href": "http://api.restbucks.com/orders/1234/"
  }, {
    "name": "delete",
    "class": [ "http://schema.org/ReplaceAction" ],
    "href": "http://api.restbucks.com/orders/1234/",
    "method": "PUT",
    "type": "application/vnd.siren.json"
    "fields": [{
      "name": "name",
      "type": "text"
    }, {
      "name": "size",
      "type": "text"
    }, {
      "name": "milk",
      "type": "text"
    }]
  }, {
    "name": "payment",
    "class": [ "http://schema.org/PayAction" ],
    "title": "Pay the order",
    "href": "http://api.restbucks.com/orders/1234/payments/",
    "type": "application/vnd.siren+json",
    "method": "POST",
    "fields": [{
      "name": "amount",
      "type": "number",
      "value": 2.75
    }, {
      "name": "currency",
      "type": "text",
      "value": "USD"
    }, {
      "name": "type",
      "type": "text"
      "value": "creditcard"
    }, {
      "name": "cardholderName",
      "type": "text"
    }, {
      "name": "cardNumber",
      "type": "text"
    }, {
      "name": "expiryMonth",
      "type": "number"
    }, {
      "name": "expiryYear",
      "type": "number"
    }, {
      "name": "cardSecurityCode",
      "type": "number"
    }],
  }],
  "links": [{ 
    "rel": "self",
    "href": "http://api.restbucks.com/orders/1234/"
  }]
}</programlisting>
    <para>
      Siren uses the <literal>properties</literal> property to capture the properties of the object being transmitted.
      The <literal>entities</literal> property is similar to the <literal>_embedded</literal> property of HAL.
      Siren uses the <literal>actions</literal> property much like Mason uses <literal>@actions</literal>, but it
      adds HTML types to the fields. For clients that use HTML, this allows for a seamless translation into forms. 
    </para>
    <para>
      The <literal>fields</literal> property within <literal>actions</literal> acts much like the
      <literal>template</literal> in Mason's <literal>@actions</literal>, but there is a significant difference:
      Mason's <literal>template</literal> may contain any JSON structure, but Siren's <literal>fields</literal> must be 
      a flat collection of values. Siren thus cannot encode the nested structure that we want in our example.
    </para>
    <para>
      Otherwise, Siren and Mason are similar in capabilities. One difference in Siren's favor is that it adds the 
      <literal>class</literal> property to define semantics, much like HTML does. This works well with an ALPS 
      profile that defines those semantics, enabling level 4 APIs.
    </para>
    
    <section>
      <title>UBER</title>
    </section>
    <para>
      Uniform Basis for Exchanging Representations, or <literal>application/vnd.uber+json</literal>, is another 
      personal standard media type that enables level 4 APIs <citation>UBER</citation>.
    </para>
    <para>
      UBER is optimized for the number of design elements used. While that keeps the specification fairly short, it 
      does make the messages a bit more difficult to read. Here's what an unpaid RESTbucks order could look like in 
      UBER:
    </para>
    <programlisting>{ "uber": {
  "version": "1.0",
  "data": [ {
    "rel": [ "self" ],
    "url": "http://api.restbucks.com/orders/1234/"
  }, {
    "id": "order",
    "data": [{
      "name": "item",
      "data": [ {
        "name": "name",
        "value": "caffe latte"
      }, {
        "name": "milk",
        "value": "whole"
      }, {
        "name": "size", 
        "value": "tall",
      }, {
        "name": "price",
        "value": 2.75
      }, {
        "name": "currency",
        "value": "USD"
      } ]
    }, 
      "name": "total",
      "value": 2.75
    }, {
      "name": "currency",
      "value": "USD"
    } ]
  }, {
    "rel": "http://schema.org/DeleteAction",
    "url": "http://api.restbucks.com/orders/1234/",
    "action": "remove"
  }, {
    "rel": "http://schema.org/ReplaceAction",
    "url": "http://api.restbucks.com/orders/1234/",
    "action": "replace",
    "sending": "application/vnd.uber.json",
    "data": [{
      "name": "item",
      "data": [{
        "name": "name",
        "value": "caffe latte"
      }, {
        "name": "milk",
        "value": "whole"
      }, {
        "name": "size", 
        "value": "tall",
      }, {
        "name": "price",
        "value": 2.75
      }, {
        "name": "currency",
        "value": "USD"
      }]
    }]
  }, {
    "rel": "http://schema.org/PayAction",
    "url": "http://api.restbucks.com/orders/1234/payments/",
    "action": "append",
    "sending": "application/vnd.uber+json",
    "data": [{
      "name": "amount",
      "value": 2.75
    }, {
      "name": "currency",
      "value": "USD"
    }, {
      "name": "type",
      "value": "creditcard"
    }, {
      "name": "cardholderName",
    }, {
      "name": "cardNumber",
    }, {
      "name": "expiryMonth",
    }, {
      "name": "expiryYear",
    }, {
      "name": "cardSecurityCode",
    }],
  }]
}</programlisting>
    <para>
      UBER differs from Mason and Siren in that it doesn't make a distinction between links (read-only operations) and 
      forms (write operations). All HTTP methods are treated the same, and they are also treated the same as the 
      properties of an object. Everything is data.
    </para>
    <para>
      There is nothing in the REST architectural style that ties it to HTTP, although that is the most commonly used
      protocol for transmitting the messages. UBER acknowledges this fact by abstracting away the HTTP methods.
      In the above example, we don't specify <literal>PUT</literal> for changing the order, but rather 
      <literal>replace</literal>. Most REST APIs today are HTTP-based, and this would be overkill for those APIs. But
      we'll see some interesting cases where this may come in handy in <xref linkend="beyond-http"/>.
    </para>
    <para>
      UBER makes a distinction between the media types used in the request and response, using the 
      <literal>sending</literal> and <literal>accepting</literal> properties. Siren only allows one value in its
      <literal>type</literal> property. But UBER doesn't provide anything in the way of data types, like Siren does.
    </para>

    <section>
      <title>JSON-LD &amp; Hydra</title>
    </section>
    <para>
      JSON-LD is an open standard maintained by the W3C <citation>JSON-LD</citation>. Hydra is a corporate standard 
      maintained by the Hydra W3C Community Group that builds on JSON-LD <citation>Hydra</citation>.
    </para>
    <para>
      JSON-LD is the JSON representation of the Linked Data concept. <firstterm>Linked Data</firstterm> is a method of 
      publishing structured data so that it can be interlinked and queried based on semantics. JSON-LD provides a 
      JSON-based media type that can define any semantics, and Hydra adds the Hydra Core Vocabulary that defines 
      semantics specific to REST APIs. The combination is thus an alternative for ALPS that is more in line with the 
      Semantic Web effort <citation>Semantic Web</citation>.
    </para>
    <para>
      Here's what an unpaid RESTBucks order could look like in JSON-LD with Hydra:
    </para>
    <programlisting>{ "@context": {
    "@vocab": "http://schema.org/",
    "hydra": "http://www.w3.org/ns/hydra/core#",
    "hydra:property": {
      "@type": "@vocab"
    },
    "pto": "http://www.productontology.org/doc/",
    "payment": "http://reference.data.gov.uk/def/payment#",
    "cc": "https://w3id.org/creditcard/v1/",
    "size": "height",
    "currency": "priceCurrency",
    "total": "price"
  },
  "@type": "Order", 
  "@id": "http://api.restbucks.com/orders/1234/",
  "orderedItem": [ {
    "@type": "Product",
    "name": "caffe latte",
    "size": "tall",
    "milk": {
      "@type": "pto:Milk",
      "@value": "whole"
    }
  } ],
  "total": 2.75,
  "currency": "USD",
  "hydra:operation": [ {
    "@type": "hydra:ReplaceResourceOperation",
    "hydra:httpMethod": "PUT",
    "hydra:expects": {
      "@type": "Order",
      "hydra:supportedProperty": [ {
        "@type": "orderedItem",
        "hydra:property": "orderedItem",
        "hydra:required": true
      }
    }, {
      "@type": "hydra:DeleteResourceOperation",
      "hydra:httpMethod": "DELETE"
    }, {
      "@type": "hydra:CreateResourceOperation",
      "hydra:httpMethod": "POST",
      "@id": "http://api.restbucks.com/orders/1234/payments/",
      "hydra:expects": {
        "@type": "payment:payment",
        "hydra:supportedProperty": [ {
          "@type": "price",
          "hydra:property": "amount",
          "hydra:required": true,
          "defaultValue": "2.75"
        }, {
          "@type": "priceCurrency",
          "hydra:property": "currency",
          "hydra:required": true,
          "defaultValue": "USD"
        }, {
          "@type": "acceptedPaymentMethod",
          "hydra:property": "paymentMethod",
          "hydra:required": true,
          "defaultValue": "creditcard"
        }, {
          "@type": "cc:name",
          "hydra:property": "cardholderName",
          "hydra:required": true
        }, {
          "@type": "cc:number",
          "hydra:property": "cardNumber",
          "hydra:required": true
        }, {
          "@type": "cc:expiryMonth",
          "hydra:property": "expiryMonth",
          "hydra:required": true
        }, {
          "@type": "cc:expiryYear",
          "hydra:property": "expiryYear",
          "hydra:required": true
        }, {
          "@type": "cc:verificationCode",
          "hydra:property": "cardSecurityCode",
          "hydra:required": true
        } ]
      }
    }
  } ]
}</programlisting>
    <para>
      JSON-LD uses keywords, indicated by the <literal>@</literal> symbol to distinguish predefined JSON keys from 
      arbitrary data, like HAL and Mason do. 
      The most important keyword is <literal>@context</literal>, which establishes the
      semantic context of the message. In this context you can refer to vocabularies and define aliases.
    </para>
    <para>
      Vocabularies assign meaning to names. In the example above, the <literal>@vocab</literal> sets the default 
      vocabulary to <literal>http://schema.org</literal>.
      Additional vocabularies are declared using JSON properties, where the name is a prefix, and the value is a
      URI to the vocabulary. For instance, <literal>"hydra": "http://www.w3.org/ns/hydra/core#"</literal> defines the
      prefix <literal>hydra</literal> for the Hydra Core Vocabulary.
    </para>
    <para>
      Aliases allow you to use different names from the ones defined in a vocabulary. For instance, 
      <literal>schema.org</literal> defines a <literal>height</literal>, but we want to use 
      <literal>size</literal> for the property name. Note that
      JSON-LD uses URIs extensively. So when we use <literal>"size": "height"</literal>, a JSON-LD processor
      actually reads that as <literal>height</literal> relative to the <literal>@vocab</literal>, or
      <literal>http://schema.org/height</literal>. If the value contains a colon, it is understood to start with
      a prefix and that prefix is replaced by the URI of the vocabulary. So <literal>hydra:operation</literal> resolves
      to <literal>http://www.w3.org/ns/hydra/core#operation</literal>.
    </para>
    <para>
      JSON-LD uses <literal>@id</literal> for the object itself, much like the <literal>self</literal> link relation.
      The meaning of an object is indicated using <literal>@type</literal>. The value of this property is a URI that 
      resolves to some name in some vocabulary. 
    </para>
    <para>
      The Hydra Core Vocabulary allows us to specify forms, much like Mason, Siren, and UBER, using 
      <literal>hydra:operation</literal>. It tells the client what HTTP method to use, what properties to specify in
      the payload, and what those properties mean.
    </para>
    <para>
      The example payload embeds the semantic context in the message so that we can see structure and semantics in one 
      place. That's convenient for explaining the media type in a book like this, but not what you should do in real 
      life. You should move the semantic context to a separate resource and add a profile link header to your messages.
      This has two advantages. First, it adheres to the Single Responsibility Principle <citation>SOLID</citation> by
      giving your messages a single reason to change (either semantics for the profile or structure for the resources). 
      Second, the semantic context is very likely the same for many, if not all, of your resources. A separate resource 
      can be cached, reducing the load on the server and maybe even semantic processing on the client.
    </para>
    
    <section>
      <title>JSON API</title>
      <para>
        TODO: Add description and example of <citation>JSON API</citation>.
      </para>
    </section>
    
    <section>
      <title>Making a Choice</title>
    </section>
    <para>
      The previous sections presented a bunch of hypermedia types that Mike Amundsen collectively calls the 
      "hypermedia zoo". Here is a summary of their characteristics:
    </para>
    <table rowsep="0" colsep="0" pgwide="1" tocentry="1" frame="topbot">
      <title>Comparison Of Hypermedia Types</title>
      <tgroup cols="7">
        <thead>
          <row>
            <entry><para>Hypermedia Type</para></entry>
            <entry><para>Standardization</para></entry>
            <entry><para>Message Structure</para></entry>
            <entry><para>Error Handling</para></entry>
            <entry><para>Forms</para></entry>
            <entry><para>Semantics</para></entry>
            <entry><para>Market Penetration</para></entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><para>HAL</para></entry>
            <entry><para>Open standard (in progress)</para></entry>
            <entry><para>Simple</para></entry>
            <entry><para>Using semantics</para></entry>
            <entry><para>No</para></entry>
            <entry><para>Using <literal>Link</literal> header, up to a point</para></entry>
            <entry><para>Popular projects like Spring use it</para></entry>
          </row>
          <row>
            <entry><para>Mason</para></entry>
            <entry><para>Personal standard</para></entry>
            <entry><para>Simple. Little quirk in <literal>type</literal> property</para></entry>
            <entry><para>Explicit structure</para></entry>
            <entry><para>Yes</para></entry>
            <entry><para>Using <literal>Link</literal> header, up to a point</para></entry>
            <entry><para>Low</para></entry>
          </row>
          <row>
            <entry><para>Siren</para></entry>
            <entry><para>Personal standard</para></entry>
            <entry><para>Complicated</para></entry>
            <entry><para>Using semantics</para></entry>
            <entry><para>Yes, but flat templates</para></entry>
            <entry><para>
              Using <literal>Link</literal> header. Explicit coupling between structure and semantics
            </para></entry>
            <entry><para>Low</para></entry>
          </row>
          <row>
            <entry><para>UBER</para></entry>
            <entry><para>Personal standard</para></entry>
            <entry><para>Complicated. No distinction between data, links, and forms</para></entry>
            <entry><para>Explicit structure</para></entry>
            <entry><para>Yes</para></entry>
            <entry><para>Using <literal>Link</literal> header</para></entry>
            <entry><para>Low</para></entry>
          </row>
          <row>
            <entry><para>JSON-LD with Hydra</para></entry>
            <entry><para>JSON-LD is an open standard; Hydra a corporate standard</para></entry>
            <entry><para>Simple (aliases)</para></entry>
            <entry><para>Using semantics</para></entry>
            <entry><para>Yes</para></entry>
            <entry><para>
              Inline or using <literal>Link</literal> header. Explicit coupling between structure and semantics
            </para></entry>
            <entry><para>All major search engines use JSON-LD. Hydra penetration is still low</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>
      From the table we can see that there really are only two contenders: HAL and the JSON-LD / Hydra combination.
      In the long run, we hope to see support for forms and semantics in REST APIs become the norm. When that happens,
      JSON-LD and Hydra would be the obvious choice. We hesitate to recommend this media type at this point in time,
      however, for a couple of reasons.
    </para>
    <para>
      First, HAL is supported a lot better in tools and libraries. This is to be expected, given that it's much simpler
      than the alternatives. If you live in a Spring world, you practically get HAL support for free.
      When faced with tight deadlines, it's hard to argue against such practicalities.
    </para>
    <para>
      Second, while JSON-LD is a mature and well-supported standard, the same is not true for Hydra. At the time of
      writing, important design patterns like collections are still being debated. And tying back to the previous point,
      it's hard to support a specification that is still a moving target.
    </para>
    <para>
      Third, market adoption of forms and semantics in REST APIs is currently still quite low. While we are convinced
      these are good things to have, they also increase complexity of the media type and this goes against our goal to
      provide a good DX, as discussed in <xref linkend="dx"/>. As the forms and semantics become more commonly
      supported, this will become less of an argument, but at the moment it is.
    </para>
    <para>
      Finally, the more self-describing messages are, the more bytes they contain. In some case of severely constrained
      connectivity, this might get in the way of decent performance. If you live in such a world, you may want to opt
      for a less verbose media type, most likely a binary one. For most REST APIs, however, this is not of great concern.
    </para>
    <para>
      All in all, we think that the prudent thing to do at this point in time is to go with HAL, but be prepared for a
      future with JSON-LD and Hydra. We'll use HAL in the remainder of the book, but we'll also show you how to make
      that choice easy to change should the market move forward.
    </para>
  </section>

  <section id="http-happy-path">
    <title>Validate The Design</title>
    <para>
      We've now completed the creative part of the design process. To validate that we did a good job, we should always 
      look at the result in the form that ultimately matters the most: the messages exchanged between client and server.
    </para>
    <para>
      Here is the whole sequence of HTTP messages for <xref linkend="bdd-customer-happy-path"/>:
      <!-- TODO: Use Spring RESTDocs to generate these messages -->
    </para>
    <orderedlist>
      <listitem>
		    <para>
		      Any RESTful interaction always starts with the client requesting the billboard URI to jumpstart the URI
		      discovery process:
          <programlisting>GET / HTTP/1.1
Host: api.restbucks.com
Accept: application/ld+json</programlisting>
		      The server responds with a representation of the <literal>Home</literal> resource:      
		      <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "http://api.restbucks.com/",
  "@type": "CafeOrCoffeeShop",
  "menu": "/menu/",
}</programlisting>
		      To understand what this representation means, the client looks for a <literal>Link</literal> header with
		      the <literal>http://www.w3.org/ns/json-ld#context</literal> relation. From this header it extracts the 
		      associated URI, so that it can retrieve the context that explains the semantics of the representation it just
		      received:
		      <programlisting>GET /context/ HTTP/1.1
Host: api.restbucks.com
Accept: application/ld+json</programlisting>
		      To which the server responds:
		      <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Cache-Control: max-age=86400, public

{ "@context": {
    "@vocab": "http://schema.org/",
    "currency": "priceCurrency",
    "dateTime": "orderDate",
    "item": {
      @type: "Offer"
    },
    "menu": {
      @type: ["menu", "makesOffer"]
    },
    "shop": "seller",
    "total": "price",
    "hydra": "http://www.w3.org/ns/hydra/core#",
    "hydra:property": {
      "@type": "@vocab"
    },
    "pay": "http://reference.data.gov.uk/def/payment#",
    "payment": "pay:payment",
    "cc": "https://w3id.org/creditcard/v1/",
    "cardholderName": "cc:name",
    "cardNumber": "cc:number",
    "cardSecurityCode": "cc:verificationCode",
    "expiryMonth": "cc:expiryMonth",
    "expiryYear": "cc:expiryYear",
    "pto": "http://www.productontology.org/doc/",
    "restbucks": "http://vocab.restbucks.com/",
    "restbucks:item": {
      "@type": "Product",
      "hydra:supportedProperty": [ {
        "@type": "hydra:SupportedProperty",
        "hydra:property": "name"
      }, {
        "@type": "hydra:SupportedProperty",
        "hydra:property": "size" 
      }, {
        "@type": "hydra:SupportedProperty",
        "hydra:property": "milk" 
      } ]
    },
    "item": "restbucks:item",
    "restbucks:items": {
      "@type": ["hydra:Collection", "offeredItems", "orderedItems"],
      "member": [ {
        "@type": "item",
      } ]
    },
    "items": "restbucks:items",
    "restbucks:serving": {
      "@type": ["@id", "Order"]
    },
    "serving": "restbucks:serving",
    "restbuckstypes": "http://types.restbucks.com/",
    "milk": {
      "@id": "pto:Milk",
      "@type": "restbuckstypes:milk"
    }
    "size": {
      "@id": "height",
      "@type": "restbuckstypes:size"
    }
  }
}</programlisting>
          The response contains a <literal>Cache-Control</literal> header. The <literal>max-age</literal> parameter in 
          this header tells the client that the response is valid for a whole day, so the client won't have to request 
          it again in the following interactions. The response is also marked as <literal>public</literal>, which means 
          it's valid for all users, even if authentication is used. We'll go into these topis in more detail in  
          <xref linkend="caching"/> and in <xref linkend="authentication"/>.
        </para>
        <para>
          From the JSON-LD context the client can see that it is dealing with a 
          <literal>http://schema.org/CafeOrCoffeeShop</literal> that offers a 
          <literal>http://schema.org/menu</literal>, since the default vocabulary is from <literal>schema.org</literal>.
          Typing RESTBucks as a coffee shop enables interaction with clients that don't even know the billboard URI and 
          happen to stumble upon the store. For instance, a spider program could try random IP addresses or follow
          random links and recognize the result as a coffee shop.
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      Since the client is programmed to understand the <literal>http://schema.org/menu</literal> concept, it knows
		      how to read the menu:
          <programlisting>GET /menu/ HTTP/1.1          
Host: api.restbucks.com
Accept: application/ld+json</programlisting>
          The server responds with a representation of the <literal>Menu</literal> resource:
          <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json          
Cache-Control: max-age=86400, public
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/menu/",
  "menu": [ {
    "@type": "Offer",
    "name": "caffe latte",
    "price": 2.75,
    "currency": "USD"
    "acceptedPaymentMethod": [ "creditcard" ]
  }, {
    <lineannotation>... Many more items ...</lineannotation>
  } ],
  "hydra:operation": [ {
	  "@id": "http://api.restbucks.com/orders/",
	  "@type": ["hydra:CreateResourceOperation", "OrderAction"],
	  "hydra:httpMethod": "POST",
	  "hydra:expects": {
	    "@type": "Order",
	    "hydra:supportedProperty": [ {
	      "@type": "items",
	      "hydra:property": "items",
	      "hydra:required": true
	    }, {
	      "@type": "customer",
	      "hydra:property": "customer",
        "hydra:required": true
	    } ]
	  }
  } ]
}</programlisting>
          The server doesn't expect the menu to change more than once a day, as indicated by the 
          <literal>Cache-Control</literal> header. So the client (or a intermediary proxy) can cache it for future use
          and reduce the load on the server.
          Every server response will contain a <literal>Link</literal> header pointing to the JSON-LD context, but we 
          can re-use the cached context from the previous response. Even if the client doesn't do the caching, we can
          insert a caching proxy on the server side to reduce the load on the server doing the actual work.
        </para>
        <para>
          The bulk of the menu representation is the collection of items, of which we show only one here for brevity. 
          We could have made each item its own resource, following the Collection pattern (see 
          <xref linkend="collection"/>). But that doesn't quite fit the way we think about the problem (see 
          <xref linkend="sd-customer"/>). Perhaps more importantly, it would mean that the client has to perform a whole 
          host of additional calls to request all the items, since it can't make a decision about what to order without 
          their details.
        </para>
        <para>
          This goes to show how important it is to look at the message flow in detail before declaring your design 
          done. As so often in our profession, the devil is in the details. There are many things to consider, and
          we'll talk about each of them  in subsequent chapters.
        </para>
        <para>
          The client also understands from the <literal>http://schema.org/acceptedPaymentMethod</literal> property that 
          this offer can only be paid using a credit card. If it can't handle that, it can abort the ordering process.
        </para>
        <para>
          The final part of the representation is a form that allows the client to place an order composed of the items
          on the menu. It lists the URI and HTTP method to use and what the request body should look like. The client
          discovers all this information at runtime, so it doesn't have to be programmed with this knowledge and won't
          break if the server changes it.
		    </para>
      </listitem>
      <listitem>
        <para>
          Since the client is programmed to understand the concepts <literal>http://schema.org/Order</literal> and 
          <literal>http://schema.org/OrderAction</literal>, it can place an order. The expected contents of the request 
          body is specified in the response: the client must supply <literal>items</literal> and 
          <literal>customer</literal> properties. The JSON-LD context tells the client that <literal>items</literal> is 
          a Hydra collection, so the client knows how to format it. The context also indicates that 
          <literal>customer</literal> is a <literal>http://schema.org/customer</literal>, which the client is 
          programmed to understand:
          <programlisting>POST /orders/ HTTP/1.1
Host: api.restbucks.com
Accept: application/ld+json
Content-Type: application/ld+json

{ "items": {
    "member": [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole"
    } ]
  },
  "customer": "Chrissy"
}</programlisting>
          The server responds with a representation of the created <literal>Order</literal> resource:
          <programlisting>HTTP/1.1 201 Created
Location: http://api.restbucks.com/orders/1234/          
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/",
  "@type": "Order",
  "items": {
    member: [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole",
      "price": 2.75,
      "currency": "USD"
    } ]
  },
  "total": 2.75,
  "currency": "USD",
  "customer": "Chrissy",
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/payments/",
    "@type": [ "hydra:CreateResourceOperation", "PayAction" ],
    "hydra:httpMethod": "POST",
    "hydra:expects": {
      "@type": "payment",
      "hydra:supportedProperty": [ {
        "@type": "price",
        "hydra:property": "amount"
      }, {
        "@type": "currency",
        "hydra:property": "currency"
      }, {
        "@type": "paymentMethod",
        "hydra:property": "paymentMethod"
      }, {
        "@type": "cc:name",
        "hydra:property": "cardholderName",
        "hydra:required": true
      }, {
        "@type": "cc:number",
        "hydra:property": "cardNumber",
        "hydra:required": true
      }, {
        "@type": "cc:expiryMonth",
        "hydra:property": "expiryMonth",
        "hydra:required": true
      }, {
        "@type": "cc:expiryYear",
        "hydra:property": "expiryYear",
        "hydra:required": true
      }, {
        "@type": "cc:verificationCode",
        "hydra:property": "cardSecurityCode",
        "hydra:required": true
      } ]
    }
  } ]
}</programlisting>
         The response contains the items, their total, and a form for paying the order. Note that 
          <literal>amount</literal>, <literal>currency</literal>, and <literal>paymentMethod</literal> are not required
          because there are decent defaults: the total and currency of the order, and <literal>creditcard</literal>,
          respectively.
        </para>
      </listitem>
      <listitem>
        <para>
          The client uses the form to pay the order:
          <programlisting>POST /orders/1234/payments/ HTTP/1.1
Accept: application/ld+json
Content-Type: application/ld.json

{ "amount": 2.75,
  "currency": "USD",
  "paymentMethod": "creditcard",
  "cardholderName": "C.C. Conway",
  "cardNumber": "5525366617069778", 
  "expiryMonth": "06",
  "expiryYear": "2019",
  "cardSecurityCode": "836"
}</programlisting>
          After processing the credit card, the server responds by redirecting the client to the 
          <literal>Receipt</literal> resource, since the payment is no longer interesting:
          <programlisting>HTTP/1.1 303 See Other
Location: http://api.restbucks.com/orders/1234/receipt/
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/receipt/"
}</programlisting>
          If we know or fear that it may take a long time to process a credit card payment, maybe because we've 
          outsourced that functionality and have to call into a third party service, we may change the design to move 
          from synchronous to asynchronous processing. We talk more about that pattern in <xref linkend="async"/>.
          Alternatively, we could implement the <literal>Payments</literal> resource to set an upper bound to the
          time we're prepared to wait for the external service. We'll talk more about that in 
          <xref linkend="implement-client"/>.
        </para>
      </listitem>
      <listitem>
        <para>
          The client follows the redirection to the receipt. Browsers do this automatically, and most HTTP libraries 
          can be instructed to do the same.
          <programlisting>GET /orders/1234/receipt/ HTTP/1.1
Accept: application/ld+json</programlisting>
          <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Link: &lt;/context/>; rel="http://www.w3.org/ns/json-ld#context"; 
    type="application/ld+json"

{ "@id": "/orders/1234/receipt/",
  "dateTime": "2015-03-16T19:58:00+01:00",
  "shop": "RESTBucks",
  "items": {
    member: [ {
      "name": "caffe latte",
      "size": "tall",
      "milk": "whole",
      "price": 2.75,
      "currency": "USD"
    } ]
  },
  "total": 2.75,
  "currency": "USD",
  "paymentMethod": "creditcard",
  "serving": "/orders/1234/serving/"
}</programlisting>
        </para>
      </listitem>
      <listitem>
        <para>
          The client understands from the JSON-LD context that the <literal>serving</literal> property contains a URI
          that points to the serving it is waiting for:
          <programlisting>GET /orders/1234/serving/ HTTP/1.1
Host: api.restbucks.com          
Accept: application/ld+json          
</programlisting>
          The response will depend on how fast the barista works, but in general the client will have to wait a bit:
          <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json
Retry-After: 30

{ "@id": "/orders/1234/serving",          
}</programlisting>
          The response doesn't contain any link for the customer to take her serving, which shows that the barista is
          still busy preparing it. The response contains the <literal>Retry-After</literal> header, which gives the 
          client an approximation of the time (in seconds) it still has to wait. This could be based on historical 
          data about how fast baristas prepare similar orders, or it could simply be a fixed value. This value is only 
          an advice, and the client is free to ignore it. But that most likely isn't going to speed the server up, so 
          there is little point. If all clients follow the advice, the server has more time to handle useful requests 
          and everybody is better off.
        </para>
      </listitem>
      <listitem>
        <para>
          After waiting a while, the client will try again. The response may be the same a couple of times, especially
          if the server doesn't use historical data to predict the retry time. But eventually the barista is done and
          the customer "gets notified" that the serving is ready:
          <programlisting>HTTP/1.1 200 OK
Content-Type: application/ld+json

{ "@id": "/orders/1234/serving",
  "hydra:operation": [ {
    "@id": "http://api.restbucks.com/orders/1234/serving/",
    "@type": "TakeAction",
    "hydra:httpMethod": "DELETE"
  } ]
}</programlisting>
          Since the serving is now ready, there is an operation to take it, as indicated by the 
          <literal>http://schema.org/TakeAction</literal> operation.
        </para>
      </listitem>
      <listitem>
        <para>
          The client finally takes the serving:
          <programlisting>DELETE /orders/1234/serving/ HTTP/1.1
Accept: application/ld+json          
</programlisting>
          To which the server responds that the process is done:
          <programlisting>HTTP/1.1 204 No Content</programlisting>
        </para>
      </listitem>
    </orderedlist>
  </section>
  
  <section id="api-description">
    <title>API Description Languages</title>
    <para>
      It's perfectly possible to implement the design approach presented in this chapter manually.
      However, it can be helpful to have support from tools, especially when you're new to the game,
      or have a large API or a large number of APIs to develop. 
    </para>
    <para>
      One tool could produce human-readable documentation, say in HTML or PDF form, that supports client developers.
      Another tool could produce skeleton code for a server implementing the API, a client consuming it, or an SDK 
      for developing a client for it (see <xref linkend="sdk"/>). Yet another tool could test whether a server 
      implements the documented API correctly. Another one could fuzz requests
      to test input validation (see <xref linkend="input-validation"/> and <xref linkend="test-security"/>).
      There are many possibilities.
    </para>
    <para>
      These tools can significantly increase the speed of the development process. Some shorten or reduce manual
      activities, while others run completely autonomously and thus can be included in a continuous integration or
      deployment pipeline <citation>HumbleFarley10</citation>.
    </para>
    <para>
      All these tools need to understand the APIs they work with, which means we need to be able to describe APIs in a
      machine-processable way. A language for doing so is known as an <firstterm>API description language</firstterm>.
    </para>
    <para>
     There have been several attempts at API description languages. Web Service Description Language
     is the standard description language for SOAP-based APIs <citation>WSDL</citation>.
     We've recently seen a bunch of new description languages pop up that vie for the same status in
     the REST space <citation>API Blueprint</citation> <citation>RADL</citation>
     <citation>RAML</citation> <citation>Swagger</citation> <citation>WADL</citation>.
     Of these, Swagger and RAML have gained the most support to date.
    </para>
    <para> 
      So how do we choose from among this list? We propose the following criteria that API description 
      languages must meet, in order of importance:
    </para>
    <orderedlist>
      <listitem>
        <para>
          The API description language must be able to describe APIs on the highest levels (3 and 4) of the maturity 
          model (see <xref linkend="maturity"/>). It would be nice if it can also describe lower levels, but that
          doesn't have much priority for us since we want to encourage higher-level APIs.
        </para>
      </listitem>
      <listitem>
        <para>
          The description language must be machine-processable, so that it can support tools. It would be nice if the
          language is also somewhat human-readable, but that is not a priority since editing tools can hide most
          (if not all) of the syntax.
        </para>
      </listitem>
      <listitem>
        <para>
          The language must allow for capturing both structured and unstructured data. Ideally most of the data is
          stored in a structured way, so that tools can more easily process it, but there will always be a need to
          store free-form documentation to capture more subtle points about the API.
        </para>
      </listitem>
      <listitem>
        <para>
          The language should support both the design-first and the code-first style of API development. In this book, 
          we're focusing on design-first, because that's a more convenient approach to teach. It is not the only way, 
          however, or the best way in every situation. For existing projects, it can be much more convenient to work 
          your way back from the code that already exists to arrive at a design and then improve or expand the design.
          This is especially true when there is no design documentation, or when that documentation is out-of-date.
        </para>
      </listitem>
      <listitem>
        The language should be an open standard supported by open source tools. Both should be
        maintained by a large enough community. 
      </listitem>
      <listitem>
        <para>
          The language should take the API designer by the hand and guide them into making the right choices. It should
          be easy to do the right thing, even if the designer isn't 100% up to speed with what the right thing actually
          is.
          In particular, it would be great if the description language would guide people through the API design process
          of <xref linkend="design"/>, or a similarly detailed process. This guidance must not, however, restrict more
          experienced API designers. Nor must it get in the way of a code-first approach.
        </para>
      </listitem>
    </orderedlist>
    <para>
     <xref linkend="api-description-languages"/>
     shows how the existing API description languages score on these requirements. Technically, RADL
     is the best option, but its community is so small that it presents a real risk. None of the other
     contenders meet our most important criterion of being able to describe hypermedia APIs.
    </para>
    <para>
      We hope the situation will improve as the hypermedia aspect of APIs become better understood
      by the API community at large. In the meantime, you'll have to work with sub-optimal tools
      or communities, or do without an API description language altogether.
    </para>
    <para>
      An alternative for a full-blown API description language is Spring REST Docs,
      which combines hand-written documentation with auto-generated snippets produced by Spring MVC
      Test <citation>Spring REST Docs</citation>. This approach is particularly interesting if you're
      using Spring and have good test coverage (see <xref linkend="test"/>). It ensures the code
      samples in your documentation are always up-to-date.
    </para>
    <table pgwide="1" id="api-description-languages">
      <title>Comparison Of API Description Languages</title>
      <thead>
        <tr>
          <th>Criterion</th>
          <th>API Blueprint</th>
          <th>RADL</th>
          <th>RAML</th>
          <th>Swagger</th>
          <th>WADL</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Supported maturity levels</td>
          <td>0-2/3</td>
          <td>0-4</td>
          <td>0-2</td>
          <td>0-2</td>
          <td>0-2</td>
        </tr>
        <tr>
          <td>Machine-processable</td>
          <td>Markdown has limited support, but API Blueprint AST has JSON and YAML serializations</td>
          <td>XML is widely supported</td>
          <td>YAML has decent support</td>
          <td>JSON is widely supported; YAML has decent support</td>
          <td>XML is widely supported</td>
        </tr>
        <tr>
          <td>Structured vs unstructured</td>
          <td>GitHub Flavored Markdown for structured and unstructured data</td>
          <td>Mostly structured, can add free-form text and HTML in <literal>&lt;documentation&gt;</literal> elements</td>
          <td>YAML for structured data; Markdown for documentation</td>
          <td>JSON or YAML for structured data; GitHub-flavored Markdown for documentation</td>
          <td>Mostly structured, can add free-form text in <literal>&lt;doc&gt;</literal> elements</td>
        </tr>
        <tr>
          <td>Supports code-first</td>
          <td>Grape (GrapeApiary)</td>
          <td>JAX-RS and Spring (radl-java)</td>
          <td>JAX-RS (RAML for JAX-RS)</td>
          <td>JAX-RS (JAX-RS analyzer)</td>
          <td>JAX-RS (Jersey)</td>
        </tr>
        <tr>
          <td>Community</td>
          <td>Medium</td>
          <td>Very small</td>
          <td>Large</td>
          <td>Large</td>
          <td>Small</td>
        </tr>
        <tr>
          <td>Guides designer</td>
          <td>No</td>
          <td>Yes</td>
          <td>No</td>
          <td>No</td>
          <td>No</td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <title>Summary</title>
    <para>
      This chapter shows how to design a REST API:
    </para>
    <orderedlist>
      <listitem>
		    <para>
		      We start from the requirements, captured 
		      as state diagrams. From the transitions between states, we can discover the resources and methods that will help
		      us meet the requirements. 
		    </para>
      </listitem>
      <listitem>
		    <para>
		      We name the resources with URIs, and the state transitions with link relations that allow the client to discover
		      those URIs.
		    </para>
      </listitem>
      <listitem>
		    <para>
		      We design the structure of our messages, define their precise meanings, and select a media type to serialize
		      the messages into the bytes we sent over the wire.
		    </para>
      </listitem>
      <listitem>
		    <para>
		      We validate the design by looking at the HTTP messages exchanged between client and server.
		    </para>
      </listitem>
    </orderedlist>
    <para>
      While designing a REST API, we'll encounter similar patterns over and over again. Understanding these patterns
      and when to apply them makes it a lot easier to answer the myriad of design questions that invariably come up. 
      The next chapter describes some of those patterns.
    </para>
  </section>
</chapter>
